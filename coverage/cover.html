
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2025_1_ChillGuys/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2025_1_ChillGuys/cmd/migrations/main.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2025_1_ChillGuys/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2025_1_ChillGuys/docs/docs.go (0.0%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/app/app.go (0.0%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio/minio_client.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/basket/basket.go (79.1%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/category/category.go (90.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/dbconnector.go (0.0%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/order/order.go (0.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/product/product.go (84.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/user/user.go (90.2%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs/errors.go (66.7%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/order.go (0.0%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/product.go (59.1%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/basket/basket.go (82.4%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/category/category.go (100.0%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/basket.go (100.0%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/category.go (100.0%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/dto.go (71.4%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/product.go (100.0%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt/jwt.go (0.0%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/cors.go (100.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/jwt.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx/logctx.go (100.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logger.go (100.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/order/order.go (0.0%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/product/product.go (60.6%)</option>
				
				<option value="file28">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/user/user.go (0.0%)</option>
				
				<option value="file29">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/cookie/cookie.go (0.0%)</option>
				
				<option value="file30">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request/request.go (85.7%)</option>
				
				<option value="file31">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response/response.go (47.9%)</option>
				
				<option value="file32">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator/validator.go (0.0%)</option>
				
				<option value="file33">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/basket/basket.go (97.1%)</option>
				
				<option value="file34">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/category/category.go (100.0%)</option>
				
				<option value="file35">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers/passwordHash.go (100.0%)</option>
				
				<option value="file36">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers/userID.go (100.0%)</option>
				
				<option value="file37">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/order/order.go (0.0%)</option>
				
				<option value="file38">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/product/product.go (100.0%)</option>
				
				<option value="file39">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/user/user.go (76.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//        @title                        ChillGuys API
//        @version                1.0
//        @description        API for ChillGuys marketplace
//        @host                        90.156.217.63:8081
//        @BasePath                /api/v1

//        @securityDefinitions.basic        BasicAuth
//        @securityDefinitions.apikey        TokenAuth
//        @in                                                        cookie
//        @name                                                token

package main

import (
        "log"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/app"
        _ "github.com/lib/pq"
)

func main() <span class="cov0" title="0">{
        conf, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("config error: %v", err)
        }</span>

        <span class="cov0" title="0">application, err := app.NewApp(conf)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create app: %v", err)
        }</span>

        <span class="cov0" title="0">if err := application.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("server error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/lib/pq"
        "github.com/pkg/errors"
        "log"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading configuration: %v", err)
        }</span>

        <span class="cov0" title="0">dsn, err := postgres.GetConnectionString(cfg.DBConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Can't connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">migrationsPath := cfg.MigrationsConfig.Path

        m, err := migrate.New(migrationsPath, dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("Error initializing migrations: %v", err)
        }</span>

        <span class="cov0" title="0">if err = m.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                log.Fatalf("Error applying migrations: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Migrations applied successfully.")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "database/sql"
        "errors"
        "fmt"
        "github.com/joho/godotenv"
        "os"
        "strconv"
        "time"
)

// Config объединяет все конфигурационные настройки приложения.
type Config struct {
        MinioConfig      *MinioConfig
        DBConfig         *DBConfig
        ServerConfig     *ServerConfig
        JWTConfig        *JWTConfig
        MigrationsConfig *MigrationsConfig
}

// NewConfig загружает переменные окружения и инициализирует все компоненты конфига.
func NewConfig() (*Config, error) <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error loading .env file: %v", err)
        }</span>

        <span class="cov0" title="0">minioConf, err := newMinioConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dbConfig, err := newDBConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverConfig, err := newServerConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">jwtConfig, err := newJWTConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">migrationsConfig, err := newMigrationsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                MinioConfig:      minioConf,
                DBConfig:         dbConfig,
                ServerConfig:     serverConfig,
                JWTConfig:        jwtConfig,
                MigrationsConfig: migrationsConfig,
        }, nil</span>
}

type MinioConfig struct {
        Port         string
        Endpoint     string
        BucketName   string
        RootUser     string
        RootPassword string
        UseSSL       bool
        PublicURL          string
}

func newMinioConfig() (*MinioConfig, error) <span class="cov0" title="0">{
        endpoint, endpointExists := os.LookupEnv("MINIO_ENDPOINT")
        rootUser, userExists := os.LookupEnv("MINIO_ROOT_USER")
        rootPassword, passwordExists := os.LookupEnv("MINIO_ROOT_PASSWORD")
        port, portExists := os.LookupEnv("PORT")
        bucketName, bucketExists := os.LookupEnv("MINIO_BUCKET_NAME")
        useSSL, err := getEnvAsBool("MINIO_USE_SSL")
        publicURL, publicURLExists := os.LookupEnv("MINIO_PUBLIC_URL")

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !endpointExists || !userExists || !passwordExists || !portExists || !bucketExists || !publicURLExists</span><span class="cov0" title="0">{
                return nil, errors.New("incomplete MinIO configuration: missing required environment variables")
        }</span>
        <span class="cov0" title="0">return &amp;MinioConfig{
                Port:         port,
                Endpoint:     endpoint,
                BucketName:   bucketName,
                RootUser:     rootUser,
                RootPassword: rootPassword,
                UseSSL:       useSSL,
                PublicURL: publicURL,
        }, nil</span>
}

type DBConfig struct {
        User            string
        Password        string
        DB              string
        Port            int
        Host            string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

func newDBConfig() (*DBConfig, error) <span class="cov0" title="0">{
        user, userExists := os.LookupEnv("POSTGRES_USER")
        password, passwordExists := os.LookupEnv("POSTGRES_PASSWORD")
        dbname, dbExists := os.LookupEnv("POSTGRES_DB")
        host, hostExists := os.LookupEnv("POSTGRES_HOST")
        portStr, portExists := os.LookupEnv("POSTGRES_PORT")
        if !userExists || !passwordExists || !dbExists || !hostExists || !portExists </span><span class="cov0" title="0">{
                return nil, errors.New("incomplete database connection information")
        }</span>
        <span class="cov0" title="0">port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid POSTGRES_PORT value")
        }</span>

        <span class="cov0" title="0">maxOpenConns := 25
        if val, exists := os.LookupEnv("DB_MAX_OPEN_CONNS"); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        maxOpenConns = parsed
                }</span>
        }
        <span class="cov0" title="0">maxIdleConns := 25
        if val, exists := os.LookupEnv("DB_MAX_IDLE_CONNS"); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        maxIdleConns = parsed
                }</span>
        }
        <span class="cov0" title="0">connMaxLifetime := 5 * time.Minute
        if val, exists := os.LookupEnv("DB_CONN_MAX_LIFETIME"); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        connMaxLifetime = time.Duration(parsed) * time.Minute
                }</span>
        }

        <span class="cov0" title="0">return &amp;DBConfig{
                User:            user,
                Password:        password,
                DB:              dbname,
                Port:            port,
                Host:            host,
                MaxOpenConns:    maxOpenConns,
                MaxIdleConns:    maxIdleConns,
                ConnMaxLifetime: connMaxLifetime,
        }, nil</span>
}

func ConfigureDB(db *sql.DB, cfg *DBConfig) <span class="cov0" title="0">{
        db.SetMaxOpenConns(cfg.MaxOpenConns)
        db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
}</span>

type ServerConfig struct {
        Port               string
        AllowOrigin        string
        AllowMethods       string
        AllowHeaders       string
        AllowCredentials   string
        WriteTimeout       time.Duration
        ReadTimeout        time.Duration
        IdleTimeout        time.Duration
        MaxMultipartMemory int64
        AvatarKey          string
}

func newServerConfig() (*ServerConfig, error) <span class="cov0" title="0">{
        port, portExist := os.LookupEnv("SERVER_PORT")
        allowOrigin, originExist := os.LookupEnv("ALLOW_ORIGIN")
        if !portExist || !originExist </span><span class="cov0" title="0">{
                return nil, errors.New("incomplete server configuration: missing required environment variable")
        }</span>

        <span class="cov0" title="0">allowMethods := getEnvWithDefault("ALLOW_METHODS", "POST,GET,PUT,DELETE,OPTIONS")
        allowHeaders := getEnvWithDefault("ALLOW_HEADERS", "Content-Type,X-CSRF-Token")
        allowCredentials := getEnvWithDefault("ALLOW_CREDENTIALS", "true")

        writeTimeout := getEnvAsDuration("SERVER_WRITE_TIMEOUT", 10*time.Second)
        readTimeout := getEnvAsDuration("SERVER_READ_TIMEOUT", 10*time.Second)
        idleTimeout := getEnvAsDuration("SERVER_IDLE_TIMEOUT", 30*time.Second)

        maxMultipartMemory := int64(10 &lt;&lt; 20) // 10 MB по умолчанию
        if val, exists := os.LookupEnv("SERVER_MAX_MULTIPART_MEMORY"); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov0" title="0">{
                        maxMultipartMemory = parsed
                }</span>
        }

        <span class="cov0" title="0">avatarKey := "file"
        if val, exists := os.LookupEnv("SERVER_AVATAR_KEY"); exists </span><span class="cov0" title="0">{
                avatarKey = val
        }</span>

        <span class="cov0" title="0">return &amp;ServerConfig{
                Port:               port,
                AllowOrigin:        allowOrigin,
                AllowMethods:       allowMethods,
                AllowHeaders:       allowHeaders,
                AllowCredentials:   allowCredentials,
                WriteTimeout:       writeTimeout,
                ReadTimeout:        readTimeout,
                IdleTimeout:        idleTimeout,
                MaxMultipartMemory: maxMultipartMemory,
                AvatarKey:          avatarKey,
        }, nil</span>
}

type JWTConfig struct {
        Signature     string
        TokenLifeSpan time.Duration
}

func newJWTConfig() (*JWTConfig, error) <span class="cov0" title="0">{
        signature, exists := os.LookupEnv("JWT_SIGNATURE")
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("jwt signature is not set")
        }</span>

        <span class="cov0" title="0">tokenLifeSpan := getEnvAsDuration("JWT_TOKEN_LIFESPAN", 24*time.Hour)

        return &amp;JWTConfig{
                Signature:     signature,
                TokenLifeSpan: tokenLifeSpan,
        }, nil</span>
}

type MigrationsConfig struct {
        Path string
}

func newMigrationsConfig() (*MigrationsConfig, error) <span class="cov0" title="0">{
        path, exists := os.LookupEnv("MIGRATIONS_PATH")
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("MIGRATIONS_PATH is not set")
        }</span>
        <span class="cov0" title="0">return &amp;MigrationsConfig{
                Path: path,
        }, nil</span>
}

func getEnvAsBool(key string) (bool, error) <span class="cov0" title="0">{
        valueStr, ok := os.LookupEnv(key)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("environment variable %s is required", key)
        }</span>
        <span class="cov0" title="0">value, err := strconv.ParseBool(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func getEnvAsDuration(key string, defaultVal time.Duration) time.Duration <span class="cov0" title="0">{
        if val, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func getEnvWithDefault(key string, defaultVal string) string <span class="cov0" title="0">{
        if val, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/basket": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Возвращает все товары в корзине пользователя",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "basket"
                ],
                "summary": "Получить содержимое корзины",
                "responses": {
                    "200": {
                        "description": "Содержимое корзины",
                        "schema": {
                            "$ref": "#/definitions/dto.BasketResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Корзина не найдена",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/basket/{id}": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Добавляет товар в корзину пользователя или увеличивает количество, если товар уже есть",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "basket"
                ],
                "summary": "Добавить товар в корзину",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID товара",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Добавленный товар",
                        "schema": {
                            "$ref": "#/definitions/models.BasketItem"
                        }
                    },
                    "400": {
                        "description": "Некорректный ID",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Товар не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Удаляет товар из корзины пользователя",
                "tags": [
                    "basket"
                ],
                "summary": "Удалить товар из корзины",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID товара",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Товар успешно удалён"
                    },
                    "400": {
                        "description": "Некорректный ID",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Товар не найден в корзине",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Изменяет количество указанного товара в корзине",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "basket"
                ],
                "summary": "Обновить количество товара",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID товара",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Новое количество",
                        "name": "quantity",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.UpdateQuantityRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Обновленный товар",
                        "schema": {
                            "$ref": "#/definitions/models.BasketItem"
                        }
                    },
                    "400": {
                        "description": "Некорректные данные",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Товар не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/products/category/{id}": {
            "get": {
                "description": "Возвращает список всех одобренных товаров, принадлежащих указанной категории.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "products"
                ],
                "summary": "Получить товары по категории",
                "parameters": [
                    {
                        "type": "string",
                        "description": "UUID категории в формате строки",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешный запрос. Возвращает массив товаров.",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Product"
                            }
                        }
                    },
                    "400": {
                        "description": "Неверный формат UUID категории",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Категория не найдена",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "TokenAuth": []
                    }
                ],
                "description": "Выход пользователя",
                "tags": [
                    "auth"
                ],
                "summary": "Logout user",
                "responses": {
                    "200": {
                        "description": "No Content",
                        "schema": {
                            "type": ""
                        }
                    },
                    "401": {
                        "description": "Пользователь не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Создает нового пользователя, хеширует пароль и устанавливает JWT-токен в куки",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register user",
                "parameters": [
                    {
                        "description": "Данные для регистрации",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.UserRegisterRequestDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content",
                        "schema": {
                            "type": ""
                        },
                        "headers": {
                            "Set-Set": {
                                "type": "string",
                                "description": "Устанавливает JWT-токен в куки"
                            }
                        }
                    },
                    "400": {
                        "description": "Некорректный запрос",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Пользователь уже существует",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/basket": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Полностью удаляет все товары из корзины пользователя",
                "tags": [
                    "basket"
                ],
                "summary": "Очистить корзину",
                "responses": {
                    "204": {
                        "description": "Корзина успешно очищена"
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/categories": {
            "get": {
                "description": "Возвращает список всех доступных категорий товаров",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "categories"
                ],
                "summary": "Получить все категории",
                "responses": {
                    "200": {
                        "description": "Список категорий",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Category"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/files/{objectID}": {
            "get": {
                "description": "Возвращает URL для доступа к файлу в MinIO",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "files"
                ],
                "summary": "Получить файл по ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID объекта в MinIO",
                        "name": "objectID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Ссылка на файл",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Неверный ID объекта",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Файл не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/order": {
            "post": {
                "description": "Создает новый заказ для пользователя",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "order"
                ],
                "summary": "Create new order",
                "parameters": [
                    {
                        "description": "Данные для создания заказа",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateOrderDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Order successfully created",
                        "schema": {
                            "type": ""
                        }
                    },
                    "400": {
                        "description": "Некорректный запрос",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не найден в контексте",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Ошибка при создании заказа",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/products": {
            "get": {
                "description": "Возвращает список всех продуктов",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "products"
                ],
                "summary": "Получить все продукты",
                "responses": {
                    "200": {
                        "description": "Список продуктов",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Product"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/products/upload": {
            "post": {
                "description": "Загружает один файл в хранилище MinIO",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "products"
                ],
                "summary": "Загрузить файл в MinIO",
                "parameters": [
                    {
                        "type": "file",
                        "description": "Файл для загрузки",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Информация о загруженном файле",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка в запросе",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/products/{id}": {
            "get": {
                "description": "Возвращает продукт по его ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "products"
                ],
                "summary": "Получить продукт по ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID продукта",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Информация о продукте",
                        "schema": {
                            "$ref": "#/definitions/models.Product"
                        }
                    },
                    "400": {
                        "description": "Некорректный ID",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Продукт не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/avatar": {
            "post": {
                "security": [
                    {
                        "TokenAuth": []
                    }
                ],
                "description": "Загружает аватар пользователя",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Upload avatar",
                "parameters": [
                    {
                        "type": "file",
                        "description": "Файл изображения",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "URL загруженного аватара",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка при обработке формы",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка загрузки файла",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "security": [
                    {
                        "TokenAuth": []
                    }
                ],
                "description": "Получение информации о текущем пользователе",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user info",
                "responses": {
                    "200": {
                        "description": "Информация о пользователе",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Некорректный запрос",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Пользователь не найден",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.BasketResponse": {
            "type": "object",
            "properties": {
                "products": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.BasketItem"
                    }
                },
                "total": {
                    "type": "integer"
                },
                "total_price": {
                    "type": "number"
                },
                "total_price_discount": {
                    "type": "number"
                }
            }
        },
        "dto.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "dto.UpdateQuantityRequest": {
            "type": "object",
            "properties": {
                "quantity": {
                    "type": "integer"
                }
            }
        },
        "dto.UserRegisterRequestDTO": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "surname": {
                    "type": "string"
                }
            }
        },
        "models.BasketItem": {
            "type": "object",
            "properties": {
                "basket_id": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "price_discount": {
                    "type": "number"
                },
                "product_id": {
                    "type": "string"
                },
                "product_image": {
                    "type": "string"
                },
                "product_name": {
                    "type": "string"
                },
                "product_price": {
                    "type": "number"
                },
                "quantity": {
                    "type": "integer"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.Category": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.CreateOrderDTO": {
            "type": "object",
            "properties": {
                "address_id": {
                    "type": "string"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.CreateOrderItemDTO"
                    }
                },
                "userID": {
                    "type": "string"
                }
            }
        },
        "models.CreateOrderItemDTO": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "product_id": {
                    "type": "string"
                },
                "product_price": {
                    "type": "number"
                },
                "quantity": {
                    "type": "integer"
                }
            }
        },
        "models.Product": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "preview_image_url": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                },
                "quantity": {
                    "type": "integer"
                },
                "rating": {
                    "type": "integer"
                },
                "reviews_count": {
                    "type": "integer"
                },
                "seller_id": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/models.ProductStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.ProductStatus": {
            "type": "integer",
            "enum": [
                0,
                1,
                2
            ],
            "x-enum-comments": {
                "ProductApproved": "Одобрено",
                "ProductPending": "Ожидает",
                "ProductRejected": "Отказано"
            },
            "x-enum-varnames": [
                "ProductPending",
                "ProductRejected",
                "ProductApproved"
            ]
        },
        "models.User": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "imageURL": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "surname": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        },
        "TokenAuth": {
            "type": "apiKey",
            "name": "token",
            "in": "cookie"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "90.156.217.63:8081",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "ChillGuys API",
        Description:      "API for ChillGuys marketplace",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "database/sql"
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres"
        basketrepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/basket"
        orderrepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/order"
        categoryrepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/category"
        productrepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/product"
        userrepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/user"
        baskett "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/basket"
        categoryt "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/category"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/order"
        producttr "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/product"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/user"
        basketuc "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/basket"
        categoryuc "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/category"
        orderus "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/order"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/product"
        userus "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/user"
        "github.com/gorilla/mux"
        "github.com/sirupsen/logrus"
        httpSwagger "github.com/swaggo/http-swagger"
)

// App объединяет в себе все компоненты приложения.
type App struct {
        conf   *config.Config
        logger *logrus.Logger
        db     *sql.DB
        router *mux.Router
        // Дополнительно можно добавить другие компоненты, если потребуется.
}

func OptionsRequest(w http.ResponseWriter, r *http.Request)<span class="cov0" title="0">{
        w.WriteHeader(http.StatusNoContent)
}</span>

// NewApp инициализирует приложение, создавая все необходимые компоненты.
func NewApp(conf *config.Config) (*App, error) <span class="cov0" title="0">{
        logger := logrus.New()

        // Подключение к базе данных.
        str, err := postgres.GetConnectionString(conf.DBConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection string error: %w", err)
        }</span>
        <span class="cov0" title="0">db, err := sql.Open("postgres", str)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection error: %w", err)
        }</span>

        // Применяем параметры пула соединений из конфигурации.
        <span class="cov0" title="0">config.ConfigureDB(db, conf.DBConfig)

        // Инициализация клиента Minio.
        minioClient, err := minio.NewMinioProvider(conf.MinioConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("minio initialization error: %w", err)
        }</span>

        // Инициализация репозиториев и use-case-ов.
        <span class="cov0" title="0">userRepo := userrepo.NewUserRepository(db)
        tokenator := jwt.NewTokenator(userRepo, conf.JWTConfig)
        userUsecase := userus.NewAuthUsecase(userRepo, tokenator, minioClient)
        userService := user.NewAuthService(userUsecase, minioClient, conf)

        productRepo := productrepo.NewProductRepository(db)
        productUsecase := product.NewProductUsecase(productRepo)
        ProductService := producttr.NewProductService(productUsecase, minioClient)

        orderRepo := orderrepo.NewOrderRepository(db)
        orderUsecase := orderus.NewOrderUsecase(orderRepo, logger)
        orderService := order.NewOrderService(orderUsecase, logger)

        basketRepo := basketrepo.NewBasketRepository(db)
        basketUsecase := basketuc.NewBasketUsecase(basketRepo)
        basketService := baskett.NewBasketService(basketUsecase)

        categoryRepo := categoryrepo.NewCategoryRepository(db)
        categoryUsecase := categoryuc.NewCategoryUsecase(categoryRepo)
        categoryService := categoryt.NewCategoryService(categoryUsecase)

        router := mux.NewRouter()
        router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)
        apiRouter := router.PathPrefix("/api").Subrouter()
        apiRouter = apiRouter.PathPrefix("/v1").Subrouter()

        router.PathPrefix("/").HandlerFunc(OptionsRequest).Methods(http.MethodOptions)

        apiRouter.Use(func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return middleware.CORSMiddleware(next, conf.ServerConfig)
        }</span>)
        <span class="cov0" title="0">apiRouter.Use(func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return middleware.LogRequest(logger, next)
        }</span>)

        // Маршруты для продуктов.
        <span class="cov0" title="0">productsRouter := apiRouter.PathPrefix("/products").Subrouter()
        </span><span class="cov0" title="0">{
                productsRouter.HandleFunc("", ProductService.GetAllProducts).Methods(http.MethodGet)
                productsRouter.HandleFunc("/{id}", ProductService.GetProductByID).Methods(http.MethodGet)
                productsRouter.HandleFunc("/category/{id}", ProductService.GetProductsByCategory).Methods(http.MethodGet)
        }</span>

        // Маршруты для категорий.
        <span class="cov0" title="0">catalogRouter := apiRouter.PathPrefix("/categories").Subrouter()
        </span><span class="cov0" title="0">{
                catalogRouter.HandleFunc("", categoryService.GetAllCategories).Methods(http.MethodGet)
        }</span>

        <span class="cov0" title="0">basketRouter := apiRouter.PathPrefix("/basket").Subrouter()
        </span><span class="cov0" title="0">{
                basketRouter.Handle("", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(basketService.Get)),
                ).Methods(http.MethodGet)

                basketRouter.Handle("/{id}", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(basketService.Add)),
                ).Methods(http.MethodPost)

                basketRouter.Handle("/{id}", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(basketService.Delete)),
                ).Methods(http.MethodDelete)

                basketRouter.Handle("/{id}", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(basketService.UpdateQuantity)),
                ).Methods(http.MethodPatch)

                basketRouter.Handle("", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(basketService.Clear)),
                ).Methods(http.MethodDelete)
        }</span>

        <span class="cov0" title="0">productCoverRouter := apiRouter.PathPrefix("/cover").Subrouter()
        </span><span class="cov0" title="0">{
                productCoverRouter.HandleFunc("/upload", ProductService.CreateOne).Methods(http.MethodPost)
        }</span>

        // Маршруты для аутентификации.
        <span class="cov0" title="0">authRouter := apiRouter.PathPrefix("/auth").Subrouter()
        </span><span class="cov0" title="0">{
                authRouter.HandleFunc("/login", userService.Login).Methods(http.MethodPost)
                authRouter.HandleFunc("/register", userService.Register).Methods(http.MethodPost)
                authRouter.Handle("/logout", middleware.JWTMiddleware(tokenator, http.HandlerFunc(userService.Logout))).
                        Methods(http.MethodPost)
        }</span>

        // Маршруты для работы с пользователями.
        <span class="cov0" title="0">userRouter := apiRouter.PathPrefix("/users").Subrouter()
        </span><span class="cov0" title="0">{
                userRouter.Handle("/me", middleware.JWTMiddleware(tokenator, http.HandlerFunc(userService.GetMe))).
                        Methods(http.MethodGet)
                userRouter.Handle("/upload-avatar", middleware.JWTMiddleware(tokenator, http.HandlerFunc(userService.UploadAvatar))).
                        Methods(http.MethodPost)
        }</span>

        <span class="cov0" title="0">orderRouter := apiRouter.PathPrefix("/order").Subrouter()
        </span><span class="cov0" title="0">{
                orderRouter.Handle("/", middleware.JWTMiddleware(
                        tokenator,
                        http.HandlerFunc(orderService.CreateOrder),
                )).Methods(http.MethodPost)
        }</span>

        <span class="cov0" title="0">app := &amp;App{
                conf:   conf,
                logger: logger,
                db:     db,
                router: router,
        }

        return app, nil</span>
}

// Run запускает HTTP-сервер.
func (a *App) Run() error <span class="cov0" title="0">{
        server := &amp;http.Server{
                Handler:      a.router,
                Addr:         fmt.Sprintf(":%s", a.conf.ServerConfig.Port),
                WriteTimeout: a.conf.ServerConfig.WriteTimeout,
                ReadTimeout:  a.conf.ServerConfig.ReadTimeout,
                IdleTimeout:  a.conf.ServerConfig.IdleTimeout,
        }

        a.logger.Infof("starting server on port %s", a.conf.ServerConfig.Port)
        return server.ListenAndServe()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package minio

import (
        "bytes"
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/google/uuid"
        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
        "github.com/sirupsen/logrus"
)

//go:generate mockgen -source=minio_client.go -destination=./mocks/minio_Provider_mock.go -package=mocks Provider
type Provider interface {
        CreateOne(context.Context, FileData) (*UploadResponse, error)
        // CreateMany(context.Context, map[string]FileData) ([]string, error)
        // GetOne(context.Context, string) ([]byte, error)
        // GetMany(context.Context, []string) ([]string, error)
        // DeleteOne(context.Context, string) error
        // DeleteMany(context.Context, []string) error
}

type minioProvider struct {
        mc     *minio.Client
        config *config.MinioConfig
        log    *logrus.Logger
}

func NewMinioProvider(config *config.MinioConfig, log *logrus.Logger) (Provider, error) <span class="cov0" title="0">{
        Provider, err := initMinio(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;minioProvider{
                mc:     Provider,
                config: config,
                log:    log,
        }, nil</span>
}

// InitMinio подключается к Minio и создает бакет, если не существует
// Бакет - это контейнер для хранения объектов в Minio. Он представляет собой пространство имен, в котором можно хранить и организовывать файлы и папки.
func initMinio(config *config.MinioConfig) (*minio.Client, error) <span class="cov0" title="0">{
        // Создание контекста с возможностью отмены операции
        ctx := context.Background()

        // Подключение к Minio с использованием имени пользователя и пароля
        Provider, err := minio.New(config.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(config.RootUser, config.RootPassword, ""),
                Secure: config.UseSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Проверка наличия бакета и его создание, если не существует
        <span class="cov0" title="0">exists, err := Provider.BucketExists(ctx, config.BucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                policy := `{
                        "Version": "2012-10-17",
                        "Statement": [
                                {
                                        "Effect": "Allow",
                                        "Principal": {"AWS": ["*"]},
                                        "Action": ["s3:GetObject"],
                                        "Resource": ["arn:aws:s3:::%s/*"]
                                }
                        ]
                }`
                if err = Provider.SetBucketPolicy(ctx, config.BucketName, fmt.Sprintf(policy, config.BucketName)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set bucket policy: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return Provider, nil</span>
}

// CreateOne создает один объект в бакете Minio.
// Метод принимает структуру fileData, которая содержит имя файла и его данные.
// В случае успешной загрузки данных в бакет, метод возвращает nil, иначе возвращает ошибку.
// Все операции выполняются в контексте задачи.
func (m *minioProvider) CreateOne(ctx context.Context, file FileData) (*UploadResponse, error) <span class="cov0" title="0">{
        // Генерация уникального идентификатора для нового объекта.
        objectID := uuid.New().String()
        logFields := logrus.Fields{
                "object_id": objectID,
                "file_name": file.Name,
                "size":      len(file.Data),
        }

        m.log.WithFields(logFields).Debug("attempting to upload file to MinIO")

        // Создание потока данных для загрузки в бакет Minio.
        reader := bytes.NewReader(file.Data)

        // Загрузка данных в бакет Minio с использованием контекста для возможности отмены операции.
        uploadInfo, err := m.mc.PutObject(
                ctx, 
                m.config.BucketName, 
                objectID, 
                reader, 
                int64(len(file.Data)), 
                minio.PutObjectOptions{ContentType: "image/jpeg"},
        )
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithFields(logFields).WithError(err).Error("failed to upload file to MinIO")
                return nil, fmt.Errorf("failed to create object %s: %v", file.Name, err)
        }</span>

        // Добавляем информацию о загрузке в логи
        <span class="cov0" title="0">logFields["upload_info"] = uploadInfo
        m.log.WithFields(logFields).Debug("file upload details")


        m.log.WithFields(logFields).Info("file successfully uploaded to MinIO")

        url := fmt.Sprintf("%s%s", m.config.PublicURL, objectID)

    return &amp;UploadResponse{
        URL:      url,
        ObjectID: objectID,
    }, nil</span>
}

// CreateMany создает несколько объектов в хранилище MinIO из переданных данных.
// Если происходит ошибка при создании объекта, метод возвращает ошибку,
// указывающую на неудачные объекты.
// func (m *minioProvider) CreateMany(ctx context.Context, data map[string]FileData) ([]string, error) {
//         logFields := logrus.Fields{
//         "total_files": len(data),
//     }

//         ctx, cancel := context.WithCancel(ctx)
//         defer cancel()

//         // Создание канала для передачи URL-адресов с размером, равным количеству переданных данных.
//         urlCh := make(chan string, len(data))
//         errCh := make(chan error, len(data))

//         var wg sync.WaitGroup

//         // Запуск горутин для создания каждого объекта.
//         for objectID, file := range data {
//                 wg.Add(1)
//                 go func(objectID string, file FileData) {
//                         defer wg.Done() // Уменьшение счетчика WaitGroup после завершения горутины.

//                         fileLogFields := logrus.Fields{
//                                 "object_id": objectID,
//                                 "file_name": file.Name,
//                                 "size":      len(file.Data),
//                         }

//                         uploadInfo, err := m.mc.PutObject(
//                                 ctx,
//                                 m.config.BucketName,
//                                 objectID,
//                                 bytes.NewReader(file.Data),
//                                 int64(len(file.Data)),
//                                 minio.PutObjectOptions{
//                                 ContentType: "image/jpeg",
//                         })
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to upload file")
//                                 errCh &lt;- fmt.Errorf("failed to upload object %s: %v", objectID, err)
//                                 cancel()
//                                 return
//                         }

//                         // Логируем информацию о загрузке
//                         fileLogFields["upload_info"] = uploadInfo
//                         m.log.WithFields(fileLogFields).Debug("file upload details")

//                         // Получение URL для загруженного объекта
//                         url, err := m.mc.PresignedGetObject(ctx, m.config.BucketName, objectID, time.Second*24*60*60, nil)
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to generate presigned URL")
//                                 errCh &lt;- fmt.Errorf("failed to generate URL for object %s: %v", objectID, err)
//                                 cancel()
//                                 return
//                         }

//                         m.log.WithFields(fileLogFields).Debug("file successfully uploaded")
//                         urlCh &lt;- url.String()
//                 }(objectID, file)
//         }

//         // Ожидание завершения всех горутин и закрытие канала с URL-адресами.
//         go func() {
//                 wg.Wait()    // Блокировка до тех пор, пока счетчик WaitGroup не станет равным 0.
//                 close(urlCh) // Закрытие канала с URL-адресами после завершения всех горутин.
//                 close(errCh)
//         }()

//         var urls []string
//     for i := 0; i &lt; len(data); i++ {
//         select {
//         case url := &lt;-urlCh:
//             urls = append(urls, url)
//         case err := &lt;-errCh:
//             m.log.WithFields(logFields).WithError(err).Error("upload failed")
//             return urls, err // Частичные результаты + ошибка
//         }
//     }

//     m.log.WithFields(logFields).Info("all files successfully uploaded")
//         return urls, nil
// }

// GetOne получает один объект из бакета Minio по его идентификатору.
// Он принимает строку `objectID` в качестве параметра и возвращает срез байт данных объекта и ошибку, если такая возникает.
// func (m *minioProvider) GetOne(ctx context.Context, objectID string) ([]byte, error) {
//         logFields := logrus.Fields{
//                 "object_id": objectID,
//         }

//         m.log.WithFields(logFields).Debug("attempting to get file URL from MinIO")

//         reader, err := m.mc.GetObject(ctx, m.config.BucketName, objectID, minio.GetObjectOptions{})
//     if err != nil {
//         m.log.WithFields(logFields).WithError(err).Error("failed to get object from MinIO")
//         return nil, fmt.Errorf("failed to get object: %v", err)
//     }
//         defer reader.Close()
//         if err != nil {
//                 m.log.Fatal(err)
//         }

//         data, err := io.ReadAll(reader)
//     if err != nil {
//         m.log.WithFields(logFields).WithError(err).Error("failed to read object data")
//         return nil, fmt.Errorf("failed to read object data: %v", err)
//     }
//         if len(data) == 0 {
//         m.log.WithFields(logFields).Warn("object data is empty")
//         return nil, fmt.Errorf("object data is empty")
//     }

//     m.log.WithFields(logFields).Debug("successfully retrieved file data")
//         return data, nil
// }

// GetMany получает несколько объектов из бакета Minio по их идентификаторам.
// func (m *minioProvider) GetMany(ctx context.Context, objectIDs []string) ([]string, error) {
//         logFields := logrus.Fields{
//                 "total_objects": len(objectIDs),
//         }

//         m.log.WithFields(logFields).Debug("attempting to get multiple file URLs from MinIO")

//         // Создание каналов для передачи URL-адресов объектов и ошибок
//         urlCh := make(chan string, len(objectIDs))
//         errCh := make(chan OperationError, len(objectIDs))

//         var wg sync.WaitGroup                // WaitGroup для ожидания завершения всех горутин
//         ctx, cancel := context.WithCancel(ctx) // Создание контекста с возможностью отмены операции
//         defer cancel()                       // Отложенный вызов функции отмены контекста при завершении функции GetMany

//         // Запуск горутин для получения URL-адресов каждого объекта.
//         for _, objectID := range objectIDs {
//                 wg.Add(1)
//                 go func(objectID string) {
//                         defer wg.Done()
//                         fileLogFields := logrus.Fields{
//                                 "object_id": objectID,
//                         }

//                         url, err := m.GetOne(ctx, objectID)
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to get file URL")
//                                 errCh &lt;- OperationError{ObjectID: objectID, Error: fmt.Errorf("failed to retrieve object %s: %v", objectID, err)}
//                                 cancel()
//                                 return
//                         }
//                         m.log.WithFields(fileLogFields).Debug("successfully retrieved file URL")
//                         urlCh &lt;- url
//                 }(objectID)
//         }

//         // Закрытие каналов после завершения всех горутин.
//         go func() {
//                 wg.Wait()    // Блокировка до тех пор, пока счетчик WaitGroup не станет равным 0
//                 close(urlCh) // Закрытие канала с URL-адресами после завершения всех горутин
//                 close(errCh) // Закрытие канала с ошибками после завершения всех горутин
//         }()

//         // Сбор URL-адресов объектов и ошибок из каналов.
//         var urls []string
//     for i := 0; i &lt; len(objectIDs); i++ {
//         select {
//         case url := &lt;-urlCh:
//             urls = append(urls, url)
//         case err := &lt;-errCh:
//             m.log.WithFields(logFields).WithError(err.Error).Error("error occurred while getting URLs")
//             return urls, err.Error // Возвращаем то, что успели собрать + ошибку
//         }
//     }

//         m.log.WithFields(logFields).Info("successfully retrieved all file URLs")
//         return urls, nil
// }

// DeleteOne удаляет один объект из бакета Minio по его идентификатору.
// func (m *minioProvider) DeleteOne(ctx context.Context, objectID string) error {
//         logFields := logrus.Fields{
//                 "object_id": objectID,
//         }

//         m.log.WithFields(logFields).Debug("attempting to delete file from MinIO")

//         // Удаление объекта из бакета Minio.
//         if err := m.mc.RemoveObject(ctx, m.config.BucketName, objectID, minio.RemoveObjectOptions{}); err != nil {
//                 err = fmt.Errorf("failed to delete object %s: %w", objectID, err)
//                 m.log.WithFields(logFields).WithError(err).Error("failed to delete file")
//                 return err
//         }

//         m.log.WithFields(logFields).Info("successfully deleted file")
//         return nil
// }

// // DeleteMany удаляет несколько объектов из бакета Minio по их идентификаторам с использованием горутин.
// func (m *minioProvider) DeleteMany(ctx context.Context, objectIDs []string) error {
//     logFields := logrus.Fields{
//         "total_objects": len(objectIDs),
//     }

//     m.log.WithFields(logFields).Debug("attempting to delete multiple objects from MinIO")

//     ctx, cancel := context.WithCancel(ctx)
//     defer cancel()

//     errCh := make(chan error, 1) // Только первая ошибка
//     var wg sync.WaitGroup

//     for _, objectID := range objectIDs {
//         wg.Add(1)
//         go func(id string) {
//             defer wg.Done()
            
//             select {
//             case &lt;-ctx.Done():
//                 return
//             default:
//             }

//             // Используем DeleteOne вместо прямого вызова RemoveObject
//             if err := m.DeleteOne(ctx, id); err != nil {
//                 select {
//                 case errCh &lt;- fmt.Errorf("failed to delete object %s: %w", id, err):
//                     cancel()
//                 default:
//                 }
//             }
//         }(objectID)
//     }

//     go func() {
//         wg.Wait()
//         close(errCh)
//     }()

//     select {
//     case err := &lt;-errCh:
//         m.log.WithFields(logFields).WithError(err).Error("errors occurred while deleting objects")
//         return err
//     default:
//         m.log.WithFields(logFields).Info("all objects successfully deleted")
//         return nil
//     }
// }

type FileData struct {
        Name string
        Data     []byte
}

type OperationError struct {
        ObjectID string
        Error    error
}

type UploadResponse struct {
        URL      string `json:"url"`
        ObjectID string `json:"object_id"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package basket

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const(
        queryGetBasketByUserID = `SELECT id FROM bazaar.basket WHERE user_id = $1 LIMIT 1`

        queryGetInfoBasket = `
                SELECT id, user_id, total_price, total_price_discount 
                        FROM bazaar.basket WHERE id = $1
        `

        queryAddProductInBasket = `
                INSERT INTO bazaar.basket_item (id, basket_id, product_id, quantity)
                        VALUES ($1, $2, $3, 1)
                        ON CONFLICT (basket_id, product_id) 
                        DO UPDATE SET 
                                quantity = basket_item.quantity + 1
                        RETURNING id, basket_id, product_id, quantity, updated_at
        `

        queryGetProductsInBasket = `
                SELECT 
                        bi.id, 
                        bi.basket_id, 
                        bi.product_id, 
                        bi.quantity, 
                        bi.updated_at,
                        p.name,
                        p.price,
                        p.preview_image_url,
                        d.discounted_price
                FROM 
                        bazaar.basket_item bi
                JOIN 
                        bazaar.product p ON bi.product_id = p.id
                LEFT JOIN LATERAL (
                        SELECT 
                                discounted_price
                        FROM 
                                bazaar.discount
                        WHERE 
                                product_id = bi.product_id
                                AND now() BETWEEN start_date AND end_date
                        ORDER BY 
                                start_date DESC
                        LIMIT 1
                ) d ON true
                WHERE 
                        bi.basket_id = $1
                        AND p.status = 'approved'
    `

        queryDelProductFromBasket = `
                DELETE FROM bazaar.basket_item
                WHERE basket_id = $1 AND product_id = $2
                RETURNING id
        `

        queryUpdateProductQuantity = `
                UPDATE bazaar.basket_item
                SET quantity = $1
                WHERE basket_id = $2 AND product_id = $3
                RETURNING id, basket_id, product_id, quantity, updated_at
        `

        queryGetQuantityProduct = `SELECT quantity FROM bazaar.product WHERE id = $1`

        queryClearBasket = `
                DELETE FROM bazaar.basket_item
                WHERE basket_id = $1
        `
)

type BasketRepository struct{
        DB  *sql.DB
}

func NewBasketRepository(db *sql.DB) *BasketRepository <span class="cov8" title="1">{
        return &amp;BasketRepository{
                DB:  db,
        }
}</span>

func (r *BasketRepository) getBasket(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) <span class="cov8" title="1">{
        const op = "BasketRepository.getBasket"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)
        
        var basketID uuid.UUID

        err := r.DB.QueryRowContext(ctx, queryGetBasketByUserID, userID).Scan(&amp;basketID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("basket not found")
            return uuid.Nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("get basket")
        return uuid.Nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return basketID, nil</span>
}

func (r*BasketRepository) getQuantityProduct(ctx context.Context, productID uuid.UUID) (uint, error) <span class="cov8" title="1">{
        const op = "BasketRepository.getQuantityProduct"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", productID)

        var quantity uint

        err := r.DB.QueryRowContext(ctx, queryGetQuantityProduct, productID).Scan(&amp;quantity)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("basket not found")
            return 0, errs.NewNotFoundError(op)
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("get basket")
        return 0, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return quantity, nil</span>
}

func (r *BasketRepository) Get(ctx context.Context, userID uuid.UUID) ([]*models.BasketItem, error) <span class="cov8" title="1">{
        const op = "BasketRepository.Get"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">productsList := []*models.BasketItem{}

        rows, err := r.DB.QueryContext(ctx, queryGetProductsInBasket, basketID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
            logger.Warn("no products in basket")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("query basket products")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                item := &amp;models.BasketItem{}
                var priceDiscount sql.NullFloat64
                err = rows.Scan(
                        &amp;item.ID,
                        &amp;item.BasketID,
                        &amp;item.ProductID,
                        &amp;item.Quantity,
                        &amp;item.UpdatedAt,
                        &amp;item.ProductName,
                        &amp;item.Price,
                        &amp;item.ProductImage,
                        &amp;priceDiscount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan basket item")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">item.PriceDiscount = priceDiscount.Float64
                productsList = append(productsList, item)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}

func (r *BasketRepository) Add(ctx context.Context, userID uuid.UUID, productID uuid.UUID) (*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketRepository.Add"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID)

        basketID, err := r.getBasket(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">item := &amp;models.BasketItem{}
        newItemID := uuid.New()

        err = r.DB.QueryRowContext(ctx, queryAddProductInBasket, newItemID, basketID, productID).Scan(
                &amp;item.ID,
                &amp;item.BasketID,
                &amp;item.ProductID,
                &amp;item.Quantity,
                &amp;item.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("add product to basket - not found")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("add product to basket")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return item, nil</span>
}

func (r *BasketRepository) Delete(ctx context.Context, userID uuid.UUID, productID uuid.UUID) error <span class="cov8" title="1">{
        const op = "BasketRepository.Delete"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">var deletedID uuid.UUID
        err = r.DB.QueryRowContext(ctx, queryDelProductFromBasket, basketID, productID).Scan(&amp;deletedID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("product not found in basket")
            return fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("delete product from basket")
        return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *BasketRepository) UpdateQuantity(ctx context.Context, userID uuid.UUID, productID uuid.UUID, quantity int) (*models.BasketItem, int, error) <span class="cov8" title="1">{
        const op = "BasketRepository.UpdateQuantity"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID).
        WithField("quantity", quantity)

        quantityProduct, err := r.getQuantityProduct(ctx, productID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get basket ID")
        return nil, -1, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if uint(quantity) &gt; quantityProduct </span><span class="cov8" title="1">{
        logger.Warn("requested quantity exceeds available")
        return nil, -1, errs.NewBusinessLogicError("requested quantity exceeds available stock")
    }</span>

        <span class="cov8" title="1">basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("failed to get basket ID")
        return nil, -1, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">item := &amp;models.BasketItem{}
        err = r.DB.QueryRowContext(ctx, queryUpdateProductQuantity, quantity, basketID, productID).Scan(
                &amp;item.ID,
                &amp;item.BasketID,
                &amp;item.ProductID,
                &amp;item.Quantity,
                &amp;item.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
            logger.Warn("product not found in basket")
            return nil, -1, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("update product quantity")
        return nil, -1, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return item, int(quantityProduct)-quantity, nil</span>
}

func (r *BasketRepository) Clear(ctx context.Context, userID uuid.UUID) error <span class="cov8" title="1">{
        const op = "BasketRepository.Clear"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">_, err = r.DB.ExecContext(ctx, queryClearBasket, basketID)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("clear basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package category

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

const (
        queryGetAllCategories = `
                        SELECT id, name FROM bazaar.category
                `
)

type CategoryRepository struct {
        DB  *sql.DB
}

func NewCategoryRepository(db *sql.DB) *CategoryRepository <span class="cov8" title="1">{
        return &amp;CategoryRepository{
                DB:  db,
        }
}</span>

func (p *CategoryRepository) GetAllCategories(ctx context.Context) ([]*models.Category, error) <span class="cov8" title="1">{
        const op = "CategoryRepository.GetAllCategories"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        categoriesList := []*models.Category{}

        rows, err := p.DB.QueryContext(ctx, queryGetAllCategories)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all categories")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                category := &amp;models.Category{}
                err = rows.Scan(
                        &amp;category.ID,
                        &amp;category.Name,
                )
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan category row")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">categoriesList = append(categoriesList, category)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return categoriesList, nil</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package postgres

import (
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
)

func GetConnectionString(conf *config.DBConfig) (string, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable",
                conf.User, conf.Password, conf.Host, conf.Port, conf.DB,
        )

        return connStr, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package order

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryCreateOrder           = `INSERT INTO bazaar."order" (id, user_id, status, total_price, total_price_discount, address_id) VALUES ($1, $2, $3, $4, $5, $6)`
        queryAddOrderItem          = `INSERT INTO bazaar."order_item" (id, order_id, product_id, price, quantity) VALUES ($1, $2, $3, $4, $5)`
        queryGetProductPrice       = `SELECT price, status, quantity FROM bazaar.product WHERE id = $1`
        queryGetProductDiscount    = `SELECT discounted_price, start_date, end_date FROM bazaar.discount WHERE product_id = $1`
        queryUpdateProductQuantity = `UPDATE bazaar.product SET quantity = $1 WHERE id = $2`
)

type IOrderRepository interface {
        CreateOrder(context.Context, models.CreateOrderRepoReq) error
        ProductPrice(context.Context, uuid.UUID) (*models.Product, error)
        ProductDiscounts(context.Context, uuid.UUID) ([]models.ProductDiscount, error)
        UpdateProductQuantity(context.Context, uuid.UUID, uint) error
}

type OrderRepository struct {
        db  *sql.DB
}

func NewOrderRepository(db *sql.DB) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{
                db:  db,
        }
}</span>

func (r *OrderRepository) CreateOrder(ctx context.Context, in models.CreateOrderRepoReq) error <span class="cov0" title="0">{
        const op = "OrderRepository.CreateOrder"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to begin transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        // Создаём заказ
        <span class="cov0" title="0">if _, err = tx.ExecContext(ctx, queryCreateOrder,
                in.Order.ID,
                in.Order.UserID,
                in.Order.Status.String(),
                in.Order.TotalPrice,
                in.Order.TotalPriceDiscount,
                in.Order.AddressID,
        ); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                logger.WithError(err).Error("create order")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        // Обновляем количество товаров в наличии
        <span class="cov0" title="0">for productID, updatedQuantity := range in.UpdatedQuantities </span><span class="cov0" title="0">{
                if err = r.UpdateProductQuantity(ctx, productID, updatedQuantity); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        logger.WithError(err).WithField("product_id", productID).Error("update product quantity")
                        return fmt.Errorf("%s: %w", op, err)
                }</span>
        }

        // Добавляем товары заказа
        <span class="cov0" title="0">for _, item := range in.Order.Items </span><span class="cov0" title="0">{
                if _, err = tx.ExecContext(ctx, queryAddOrderItem,
                        item.ID, in.Order.ID, item.ProductID, item.Price, item.Quantity,
                ); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        logger.WithError(err).WithField("product_id", item.ProductID).Error("add order item")
                        return fmt.Errorf("%s: %w", op, err)
                }</span>
        }

        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("commit transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *OrderRepository) ProductPrice(ctx context.Context, ProductID uuid.UUID) (*models.Product, error) <span class="cov0" title="0">{
        const op = "OrderRepository.ProductPrice"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var product models.Product
        var productStatusString string

        if err := r.db.QueryRowContext(ctx, queryGetProductPrice, ProductID).Scan(
                &amp;product.Price,
                &amp;productStatusString,
                &amp;product.Quantity,
        ); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.WithField("product_id", ProductID).Warn("product not found")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov0" title="0">logger.WithError(err).WithField("product_id", ProductID).Error("get product price")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">productStatus, err := models.ParseProductStatus(productStatusString)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("status", productStatusString).Error("parse product status")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov0" title="0">product.Status = productStatus

        return &amp;product, nil</span>
}

func (r *OrderRepository) ProductDiscounts(ctx context.Context, productID uuid.UUID) ([]models.ProductDiscount, error) <span class="cov0" title="0">{
        const op = "OrderRepository.ProductDiscounts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetProductDiscount, productID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("product_id", productID).Error("query product discounts")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var discounts []models.ProductDiscount
        for rows.Next() </span><span class="cov0" title="0">{
                var discount models.ProductDiscount
                if err = rows.Scan(
                        &amp;discount.DiscountedPrice,
                        &amp;discount.DiscountStartDate,
                        &amp;discount.DiscountEndDate,
                ); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan discount row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov0" title="0">discounts = append(discounts, discount)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">if len(discounts) == 0 </span><span class="cov0" title="0">{
                logger.WithField("product_id", productID).Warn("no discounts found")
                return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>


        <span class="cov0" title="0">return discounts, nil</span>
}

func (r *OrderRepository) UpdateProductQuantity(ctx context.Context, productID uuid.UUID, quantity uint) error <span class="cov0" title="0">{
        const op = "OrderRepository.UpdateProductQuantity"
        logger := logctx.GetLogger(ctx).WithField("op", op)
        
        res, err := r.db.ExecContext(ctx, queryUpdateProductQuantity, quantity, productID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("product_id", productID).Error("update product quantity")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get rows affected")
                return fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                logger.WithField("product_id", productID).Warn("product not found")
                return fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package product

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

const (
        queryGetAllProducts = `
                SELECT p.id, p.seller_id, p.name, p.preview_image_url, p.description, 
                                p.status, p.price, p.quantity, p.updated_at, p.rating, p.reviews_count 
                FROM bazaar.product p 
                WHERE p.status = 'approved'
        `
        queryGetProductByID = `
                SELECT id, seller_id, name, preview_image_url, description, 
                                status, price, quantity, updated_at, rating, reviews_count 
                        FROM bazaar.product WHERE id = $1
        `
        queryGetProductsByCategory = `
        SELECT p.id, p.seller_id, p.name, p.preview_image_url, p.description, 
                p.status, p.price, p.quantity, p.updated_at, p.rating, p.reviews_count 
                        FROM bazaar.product p
                        JOIN bazaar.product_category pc ON p.id = pc.product_id
                        WHERE pc.category_id = $1 AND p.status = 'approved'
    `
)

type ProductRepository struct {
        DB  *sql.DB
}

func NewProductRepository(db *sql.DB) *ProductRepository <span class="cov8" title="1">{
        return &amp;ProductRepository{
                DB:  db,
        }
}</span>

// получение основной информации всех товаров
func (p *ProductRepository) GetAllProducts(ctx context.Context) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetAllProducts"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        productsList := []*models.Product{}

        rows, err := p.DB.QueryContext(ctx, queryGetAllProducts)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all products")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                product := &amp;models.Product{}
                err = rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">productsList = append(productsList, product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}

// получение товара по id
func (p *ProductRepository) GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetProductByID"
    logger := logctx.GetLogger(ctx).WithField("op", op)
        
        product := &amp;models.Product{}
        err := p.DB.QueryRowContext(ctx, queryGetProductByID, id).
                Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                )

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("product not found by ID")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("failed to get product by ID")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return product, nil</span>
}

func (p *ProductRepository) GetProductsByCategory(ctx context.Context, id uuid.UUID) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetProductsByCategory"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        productsList := []*models.Product{}

        rows, err := p.DB.QueryContext(ctx, queryGetProductsByCategory, id)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query products by category")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                product := &amp;models.Product{}
                err = rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">productsList = append(productsList, product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryCreateUser        = `INSERT INTO bazaar."user" (id, email, name, surname, password_hash, image_url) VALUES($1, $2, $3, $4, $5, $6);`
        queryCreateUserVersion = `INSERT INTO bazaar."user_version" (id, user_id, version, updated_at) VALUES($1, $2, $3, $4);`
        queryGetUserVersion    = `SELECT version FROM bazaar."user_version" WHERE user_id = $1 LIMIT 1`
        queryGetUserByEmail    = `
        SELECT
                u.id,
                u.email,
                u.name,
                u.surname,
                u.password_hash,
                u.image_url,
                uv.id AS user_version_id,
                uv.version,
                uv.updated_at
        FROM bazaar."user" u
                         LEFT JOIN bazaar.user_version uv ON u.id = uv.user_id
        WHERE u.email = $1;
        `
        queryGetUserByID = `
        SELECT 
                u.id, 
                u.email, 
                u.name, 
                u.surname, 
                u.password_hash, 
                u.image_url, 
                uv.id AS user_version_id, 
                uv.version, 
                uv.updated_at
        FROM bazaar."user" u
        LEFT JOIN bazaar.user_version uv ON u.id = uv.user_id
        WHERE u.id = $1;
        `
        queryIncrementUserVersion = `UPDATE bazaar."user_version" SET version = version + 1 WHERE user_id = $1`
        queryCheckUserExists      = `SELECT EXISTS(SELECT 1 FROM bazaar."user" WHERE email = $1)`
        queryUpdateUserImageURL   = `UPDATE bazaar."user" SET image_url = $1 WHERE id = $2`
        queryCreateBasket                   = `
                        INSERT INTO bazaar.basket (id, user_id, total_price, total_price_discount)
                        SELECT $1, $2, 0, 0
        `
)

type UserRepository struct {
        db  *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov8" title="1">{
        return &amp;UserRepository{
                db:  db,
        }
}</span>

func (r *UserRepository) Create(ctx context.Context, user dto.UserDB) error <span class="cov8" title="1">{
        const op = "UserRepository.Create"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("begin transaction")
                return err
        }</span>

        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryCreateUser,
                user.ID, user.Email, user.Name, user.Surname, user.PasswordHash, user.ImageURL,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("create user")
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryCreateUserVersion,
                user.UserVersion.ID, user.UserVersion.UserID, user.UserVersion.Version, user.UserVersion.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("create user version")
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">basketID := uuid.New()
    _, err = tx.ExecContext(ctx, queryCreateBasket,
        basketID,
        user.ID, 
    )
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("failed to create basket")
        return err
    }</span>

        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("commit transaction")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *UserRepository) GetCurrentVersion(ctx context.Context, userID string) (int, error) <span class="cov8" title="1">{
        const op = "UserRepository.GetCurrentVersion"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var version int

        err := r.db.QueryRowContext(ctx, queryGetUserVersion, userID).Scan(&amp;version)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Warn("user version not found")
                        return 0, errs.NewNotFoundError(op)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user version")
                return 0, err</span>
        }

        <span class="cov8" title="1">return version, nil</span>
}

func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*dto.UserDB, error) <span class="cov8" title="1">{
        const op = "UserRepository.GetByEmail"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var user dto.UserDB

        if err := r.db.QueryRowContext(ctx, queryGetUserByEmail, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.UserVersion.ID,
                &amp;user.UserVersion.Version,
                &amp;user.UserVersion.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Warn("user not found by email")
                        return nil, errs.NewNotFoundError(op)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user by email")
                return nil, err</span>
        }

        <span class="cov8" title="1">user.UserVersion.UserID = user.ID

        return &amp;user, nil</span>
}

func (r *UserRepository) GetByID(ctx context.Context, id uuid.UUID) (*dto.UserDB, error) <span class="cov8" title="1">{
        const op = "UserRepository.GetByID"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var user dto.UserDB

        err := r.db.QueryRowContext(ctx, queryGetUserByID, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.UserVersion.ID,
                &amp;user.UserVersion.Version,
                &amp;user.UserVersion.UpdatedAt,
        )
        user.UserVersion.UserID = user.ID

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Warn("user not found by ID")
                        return nil, errs.NewNotFoundError(op)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user by ID")
                return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) IncrementVersion(ctx context.Context, userID string) error <span class="cov8" title="1">{
        const op = "UserRepository.IncrementVersion"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        res, err := r.db.ExecContext(ctx, queryIncrementUserVersion, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("increment version")
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get rows affected")
                return err
        }</span>
        
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                logger.Warn("no rows affected when incrementing version")
                return errs.NewNotFoundError(op)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *UserRepository) CheckVersion(ctx context.Context, userID string, version int) bool <span class="cov8" title="1">{
        const op = "UserRepository.CheckVersion"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var currentVersion int

        if err := r.db.QueryRowContext(ctx, queryGetUserVersion, userID).Scan(&amp;currentVersion); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("check version")
                return false
        }</span>

        <span class="cov8" title="1">return currentVersion == version</span>
}

func (r *UserRepository) CheckExistence(ctx context.Context, email string) (bool, error) <span class="cov8" title="1">{
        const op = "UserRepository.CheckExistence"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var exists bool

        if err := r.db.QueryRowContext(ctx, queryCheckUserExists, email).Scan(&amp;exists); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to check user existence")
                return false, err
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

func (r *UserRepository) UpdateImageURL(ctx context.Context, userID uuid.UUID, imageURL string) error <span class="cov8" title="1">{
        const op = "UserRepository.UpdateImageURL"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        res, err := r.db.ExecContext(ctx, queryUpdateUserImageURL, imageURL, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update image URL")
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get rows affected")
                return err
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                logger.Warn("no rows affected when updating image URL")
                return errs.NewNotFoundError(op)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package errs

import (
        "errors"
        "fmt"
)

var (
        ErrReadRequestData    = errors.New("failed to read request body")
        ErrParseRequestData   = errors.New("failed to parse request body")
        ErrNotFound           = errors.New("not found")
        ErrInvalidToken       = errors.New("invalid token")
        ErrAlreadyExists      = errors.New("already exists")
        ErrInvalidID          = errors.New("invalid id format")
        ErrInvalidCredentials = errors.New("invalid credentials")
        ErrBusinessLogic      = errors.New("business logic error")
        ErrProductNotApproved = errors.New("product not approved")
        ErrNotEnoughStock     = errors.New("not enough stock")
)

func NewBusinessLogicError(msg string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", ErrBusinessLogic, msg)
}</span>

func NewNotFoundError(msg string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", ErrNotFound, msg)
}</span>

func NewAlreadyExistsError(msg string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s", ErrAlreadyExists, msg)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import "github.com/google/uuid"

type OrderStatus int

const (
        Pending                   OrderStatus = iota // Ожидает
        Placed                                       // Оформлен
        AwaitingConfirmation                         // Ожидает подтверждения
        BeingPrepared                                // Готовится
        Shipped                                      // Отправлен
        InTransit                                    // В пути
        DeliveredToPickupPoint                       // Доставлен в пункт самовывоза
        Delivered                                    // Доставлен
        Canceled                                     // Отменен
        AwaitingPayment                              // Ожидает оплаты
        Paid                                         // Оплачено (опечатка в оригинале: должно быть Paid)
        PaymentFailed                                // Платеж не удался
        ReturnRequested                              // Возврат запрашивается
        ReturnProcessed                              // Возврат обработан
        ReturnInitiated                              // Возврат инициирован
        ReturnCompleted                              // Возврат завершен
        CanceledByUser                               // Отменен пользователем
        CanceledBySeller                             // Отменен продавцом
        CanceledDueToPaymentError                    // Отменен из-за ошибки платежа
)

func (s OrderStatus) String() string <span class="cov0" title="0">{
        return [...]string{
                "pending",
                "placed",
                "awaiting_confirmation",
                "being_prepared",
                "shipped",
                "in_transit",
                "delivered_to_pickup_point",
                "delivered",
                "canceled",
                "awaiting_payment",
                "paid",
                "payment_failed",
                "return_requested",
                "return_processed",
                "return_initiated",
                "return_completed",
                "canceled_by_user",
                "canceled_by_seller",
                "canceled_due_to_payment_error",
        }[s]
}</span>

type Order struct {
        ID                 uuid.UUID
        UserID             uuid.UUID
        Status             OrderStatus
        TotalPrice         float64
        TotalPriceDiscount float64
        AddressID          uuid.UUID
        Items              []CreateOrderItemDTO
}

type OrderDB struct {
        ID         uuid.UUID `db:"id"`
        UserID     string    `db:"user_id"`
        Status     string    `db:"status"`
        TotalPrice float64   `db:"total_price"`
        AddressID  uuid.UUID `db:"address_id"`
}

type OrderItemDB struct {
        ID        uuid.UUID `db:"id"`
        OrderID   uuid.UUID `db:"order_id"`
        ProductID uuid.UUID `db:"product_id"`
        Price     float64   `db:"product_price"`
        Quantity  uint      `db:"quantity"`
}

type CreateOrderDTO struct {
        UserID    uuid.UUID
        Items     []CreateOrderItemDTO `json:"items"`
        AddressID uuid.UUID            `json:"address_id"`
}

type CreateOrderItemDTO struct {
        ID        uuid.UUID
        ProductID uuid.UUID `json:"product_id"`
        Price     float64   `json:"product_price"`
        Quantity  uint      `json:"quantity"`
}

type CreateOrderRepoReq struct {
        Order             *Order
        UpdatedQuantities map[uuid.UUID]uint
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

const (
        MediaFolder          = "./media"
        CoverName            = "cover.jpeg"
        DefaultPathCoverName = "product-default"
)

// Константы статусов товара
const (
        ProductPending  ProductStatus = iota // Ожидает
        ProductRejected                      // Отказано
        ProductApproved                      // Одобрено
)

// ProductStatus представляет статус товара
type ProductStatus int

type Product struct {
        ID              uuid.UUID     `json:"id" db:"id"`
        SellerID        uuid.UUID     `json:"seller_id" db:"seller_id"`
        Name            string        `json:"name" db:"name"`
        PreviewImageURL string        `json:"preview_image_url,omitempty" db:"preview_image_url"`
        Description     string        `json:"description,omitempty" db:"description"`
        Status          ProductStatus `json:"status" db:"status"`
        Price           float64       `json:"price" db:"price"`
        Quantity        uint          `json:"quantity" db:"quantity"`
        UpdatedAt       time.Time     `json:"updated_at" db:"updated_at"`
        Rating          uint          `json:"rating,omitempty" db:"rating"`
        ReviewsCount    uint          `json:"reviews_count" db:"reviews_count"`
}

type ProductDiscount struct {
        DiscountedPrice   float64   `db:"discounted_price"`
        DiscountEndDate   time.Time `db:"end_date"`
        DiscountStartDate time.Time `db:"start_date"`
}

// String возвращает строковое представление статуса
func (s ProductStatus) String() string <span class="cov8" title="1">{
        return [...]string{
                "pending",
                "rejected",
                "approved",
        }[s]
}</span>

// ParseProductStatus преобразует строку в ProductStatus
func ParseProductStatus(status string) (ProductStatus, error) <span class="cov8" title="1">{
        switch status </span>{
        case "pending":<span class="cov0" title="0">
                return ProductPending, nil</span>
        case "rejected":<span class="cov0" title="0">
                return ProductRejected, nil</span>
        case "approved":<span class="cov8" title="1">
                return ProductApproved, nil</span>
        default:<span class="cov0" title="0">
                return ProductPending, fmt.Errorf("unknown product status: %s", status)</span>
        }
}

// Scan реализует интерфейс sql.Scanner для чтения из БД
func (s *ProductStatus) Scan(value interface{}) error <span class="cov8" title="1">{
    if value == nil </span><span class="cov0" title="0">{
        *s = ProductPending
        return nil
    }</span>

    <span class="cov8" title="1">var statusStr string
    
    // Обрабатываем разные типы, которые могут прийти из БД
    switch v := value.(type) </span>{
    case string:<span class="cov8" title="1">
        statusStr = v</span>
    case []byte:<span class="cov0" title="0">
        statusStr = string(v)</span>
    default:<span class="cov0" title="0">
        return fmt.Errorf("failed to scan ProductStatus: unsupported type %T", value)</span>
    }

    <span class="cov8" title="1">status, err := ParseProductStatus(statusStr)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov8" title="1">*s = status
    return nil</span>
}

// Value реализует интерфейс driver.Valuer для записи в БД
func (s ProductStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        return s.String(), nil
}</span>

func (p Product) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
    type Alias Product
    return json.Marshal(&amp;struct {
        Status string `json:"status"`
        *Alias
    }{
        Status: p.Status.String(),
        Alias:  (*Alias)(&amp;p),
    })
}</pre>
		
		<pre class="file" id="file15" style="display: none">package basket

import (
        "context"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "github.com/sirupsen/logrus"
)

//go:generate mockgen -source=basket.go -destination=../../usecase/mocks/basket_usecase_mock.go -package=mocks IBasketUsecase
type IBasketUsecase interface{
        Get(ctx context.Context)([]*models.BasketItem, error)
        Add(ctx context.Context, productID uuid.UUID)(*models.BasketItem, error)
        Delete(ctx context.Context, productID uuid.UUID)(error)
        UpdateQuantity(ctx context.Context, productID uuid.UUID, quantity int)(*models.BasketItem, int, error)
        Clear(ctx context.Context)(error)
}

type BasketService struct {
        u            IBasketUsecase
}

func NewBasketService(u IBasketUsecase) *BasketService <span class="cov8" title="1">{
        return &amp;BasketService{
                u:            u,
        }
}</span>

// GetBasket godoc
//
//        @Summary                Получить содержимое корзины
//        @Description        Возвращает все товары в корзине пользователя
//        @Tags                        basket
//        @Security                ApiKeyAuth
//        @Produce                json
//        @Success                200        {object}        dto.BasketResponse        "Содержимое корзины"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не авторизован"
//        @Failure                404        {object}        dto.ErrorResponse        "Корзина не найдена"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /api/v1/basket [get]
func (h *BasketService) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Get"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        items, err := h.u.Get(r.Context())
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get basket items")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">responseBasket := dto.ConvertToBasketResponse(items)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, responseBasket)</span>
}

// AddToBasket godoc
//
//        @Summary                Добавить товар в корзину
//        @Description        Добавляет товар в корзину пользователя или увеличивает количество, если товар уже есть
//        @Tags                        basket
//        @Security                ApiKeyAuth
//        @Produce                json
//        @Param                        id        path                string                                true        "ID товара"
//        @Success                201        {object}        models.BasketItem        "Добавленный товар"
//        @Failure                400        {object}        dto.ErrorResponse        "Некорректный ID"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не авторизован"
//        @Failure                404        {object}        dto.ErrorResponse        "Товар не найден"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /api/v1/basket/{id} [post]
func (h *BasketService) Add(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Add"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">item, err := h.u.Add(r.Context(), productID)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithField("product_id", productID).WithError(err).Error("add product to basket")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusCreated, item)</span>
}

// RemoveFromBasket godoc
//
//        @Summary                Удалить товар из корзины
//        @Description        Удаляет товар из корзины пользователя
//        @Tags                        basket
//        @Security                ApiKeyAuth
//        @Param                        id        path        string        true        "ID товара"
//        @Success                204        "Товар успешно удалён"
//        @Failure                400        {object}        dto.ErrorResponse        "Некорректный ID"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не авторизован"
//        @Failure                404        {object}        dto.ErrorResponse        "Товар не найден в корзине"
//        @Failure                500        {object}        dto.ErrorResponse        "Внутренняя ошибка сервера"
//        @Router                        /api/v1/basket/{id} [delete]
func (h *BasketService) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Delete"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>


        <span class="cov8" title="1">if err := h.u.Delete(r.Context(), productID); err != nil </span><span class="cov8" title="1">{
        logger.WithField("product_id", productID).WithError(err).Error("delete product from basket")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusNoContent, nil)</span>
}

// UpdateBasketItem godoc
//
//        @Summary                Обновить количество товара
//        @Description        Изменяет количество указанного товара в корзине
//        @Tags                        basket
//        @Security                ApiKeyAuth
//        @Accept                        json
//        @Produce                json
//        @Param                        id                        path                string                                                true        "ID товара"
//        @Param                        quantity        body                dto.UpdateQuantityRequest        true        "Новое количество"
//        @Success                200                        {object}        models.BasketItem                        "Обновленный товар"
//        @Failure                400                        {object}        dto.ErrorResponse                        "Некорректные данные"
//        @Failure                401                        {object}        dto.ErrorResponse                        "Пользователь не авторизован"
//        @Failure                404                        {object}        dto.ErrorResponse                        "Товар не найден"
//        @Failure                500                        {object}        dto.ErrorResponse                        "Ошибка сервера"
//        @Router                        /api/v1/basket/{id} [patch]
func (h *BasketService) UpdateQuantity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.UpdateQuantity"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var req dto.UpdateQuantityRequest
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">logger = logger.WithFields(logrus.Fields{
        "product_id": productID,
        "quantity":   req.Quantity,
    })

        item, rem, err := h.u.UpdateQuantity(r.Context(), productID, req.Quantity)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("update product quantity")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">resp := dto.ConvertToQuantityResponse(item, rem)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, resp)</span>
}

// ClearBasket godoc
//
//        @Summary                Очистить корзину
//        @Description        Полностью удаляет все товары из корзины пользователя
//        @Tags                        basket
//        @Security                ApiKeyAuth
//        @Success                204        "Корзина успешно очищена"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не авторизован"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /basket [delete]
func (h *BasketService) Clear(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Clear"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        if err := h.u.Clear(r.Context()); err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("clear basket")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusNoContent, nil)</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package category

import (
        "context"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
)

//go:generate mockgen -source=category.go -destination=../../usecase/mocks/category_usecase_mock.go -package=mocks ICategoryUsecase
type ICategoryUsecase interface {
        GetAllCategories(ctx context.Context) ([]*models.Category, error)
}

type CategoryService struct {
        u            ICategoryUsecase
}

func NewCategoryService(u ICategoryUsecase) *CategoryService <span class="cov8" title="1">{
        return &amp;CategoryService{
                u:            u,
        }
}</span>

// GetAllCategories godoc
//
//        @Summary                Получить все категории
//        @Description        Возвращает список всех доступных категорий товаров
//        @Tags                        categories
//        @Produce                json
//        @Success                200        {object}        []models.Category        "Список категорий"
//        @Failure                500        {object}        dto.ErrorResponse        "Внутренняя ошибка сервера"
//        @Router                        /categories [get]
func (h *CategoryService) GetAllCategories(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "CategoryService.GetAllCategories"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)
        
        categories, err := h.u.GetAllCategories(r.Context())
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get all categories")
        response.HandleDomainError(r.Context(), w, err, "get categories")
        return
    }</span>

        <span class="cov8" title="1">categoryResponse := dto.ConvertToCategoriesResponse(categories)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, categoryResponse)</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package dto

import "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"

type UpdateQuantityRequest struct {
        Quantity  int       `json:"quantity"`
}

type UpdateQuantityResponse struct {
        QuantityRemain                 int                                 `json:"remain_quantity"`
        Item                                 *models.BasketItem  `json:"item"`
}

func ConvertToQuantityResponse(item *models.BasketItem, quantity int) UpdateQuantityResponse <span class="cov8" title="1">{
        return UpdateQuantityResponse{
                QuantityRemain: quantity,
                Item: item,
        }
}</span>

type BasketResponse struct {
    Total              int                          `json:"total"`
    TotalPrice         float64                      `json:"total_price"`
    TotalPriceDiscount float64                      `json:"total_price_discount"`
        Products           []models.BasketItem  `json:"products"`
}

func ConvertToBasketResponse(items []*models.BasketItem) BasketResponse<span class="cov8" title="1">{
        var totalPrice, totalPriceDiscount float64 
        productsList := make([]models.BasketItem, 0, len(items))
        for _, product := range items</span><span class="cov8" title="1">{
                productsList = append(productsList, *product)
                totalPrice = totalPrice + product.Price * float64(product.Quantity)
        price := product.Price
        if product.PriceDiscount &gt; 0 </span><span class="cov8" title="1">{
            price = product.PriceDiscount
        }</span>
        <span class="cov8" title="1">totalPriceDiscount += price * float64(product.Quantity)</span>
        }

        <span class="cov8" title="1">return BasketResponse{
                Total: len(productsList),
                TotalPrice: totalPrice,
                TotalPriceDiscount : totalPriceDiscount,
                Products: productsList,
        }</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package dto

import "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"

type CategoryResponse struct {
        Total            int             `json:"total"`
        Categorys         []models.Category                 `json:"categories"`
}

func ConvertToCategoriesResponse(categories []*models.Category) CategoryResponse<span class="cov8" title="1">{
        categoryList := make([]models.Category, 0, len(categories))
    for _, cat := range categories </span><span class="cov8" title="1">{
        if cat != nil </span><span class="cov8" title="1">{
            categoryList = append(categoryList, *cat)
        }</span>
    }

        <span class="cov8" title="1">return CategoryResponse{
                Total: len(categories),
                Categorys: categoryList,
        }</span>
} </pre>
		
		<pre class="file" id="file19" style="display: none">package dto

import (
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/google/uuid"
        "github.com/guregu/null"
)

type UserDB struct {
        ID           uuid.UUID
        Email        string
        Name         string
        Surname      null.String
        ImageURL     null.String
        PhoneNumber  null.String
        PasswordHash []byte
        UserVersion  models.UserVersionDB
}

func (u *UserDB) ConvertToUser() *models.User <span class="cov8" title="1">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">return &amp;models.User{
                ID:          u.ID,
                Email:       u.Email,
                Name:        u.Name,
                Surname:     u.Surname,
                ImageURL:    u.ImageURL,
                PhoneNumber: u.PhoneNumber,
        }</span>
}

type UserLoginRequestDTO struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

type UserRegisterRequestDTO struct {
        Email    string      `json:"email"`
        Password string      `json:"password"`
        Name     string      `json:"name"`
        Surname  null.String `json:"surname,omitempty" swaggertype:"primitive,string"`
}

type UserResponseDTO struct {
        Token string `json:"token"`
}

type ErrorResponse struct {
        Message string `json:"message"`
}

func (u *UserDB) IsVersionValid(version int) bool <span class="cov0" title="0">{
        return u.UserVersion.Version == version
}</span>

func NewFromRequest(user UserRegisterRequestDTO, passwordHash []byte) UserDB<span class="cov8" title="1">{
        userID := uuid.New()
        userDB := UserDB{
                ID:           userID,
                Email:        user.Email,
                Name:         user.Name,
                Surname:      user.Surname,
                PasswordHash: passwordHash,
                UserVersion: models.UserVersionDB{
                        ID:        uuid.New(),
                        UserID:    userID,
                        Version:   1,
                        UpdatedAt: time.Now(),
                },
        }
        return userDB
}</pre>
		
		<pre class="file" id="file20" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/google/uuid"
)

type BriefProduct struct {
        ID           uuid.UUID `json:"id"`
        Name         string    `json:"name"`
        ImageURL     string    `json:"image"`
        Price        float64   `json:"price"`
        ReviewsCount uint      `json:"reviews_count"`
        Rating       uint      `json:"rating,omitempty"`
}

func ConvertToBriefProduct(product *models.Product) BriefProduct <span class="cov8" title="1">{
        return BriefProduct{
                ID:           product.ID,
                Name:         product.Name,
                ImageURL:     product.PreviewImageURL,
                Price:        product.Price,
                ReviewsCount: product.ReviewsCount,
                Rating:       product.Rating,
        }
}</span>

type ProductsResponse struct {
        Total    int            `json:"total"`
        Products []BriefProduct `json:"products"`
}

func ConvertToProductsResponse(products []*models.Product) ProductsResponse <span class="cov8" title="1">{
        briefProducts := make([]BriefProduct, 0, len(products))
        for _, product := range products </span><span class="cov8" title="1">{
                briefProducts = append(briefProducts, ConvertToBriefProduct(product))
        }</span>

        <span class="cov8" title="1">return ProductsResponse{
                Total:    len(briefProducts),
                Products: briefProducts,
        }</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package jwt

import (
        "context"
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/golang-jwt/jwt/v4"
)

type VersionChecker interface {
        CheckVersion(ctx context.Context, userID string, version int) bool
}

// JWTClaims структура для данных токена
type JWTClaims struct {
        UserID    string
        Version   int
        ExpiresAt int64
        jwt.StandardClaims
}

// Tokenator структура для создания и парсинга токенов
type Tokenator struct {
        sign          string
        tokenLifeSpan time.Duration
        VC            VersionChecker
}

// NewTokenator создает новый экземпляр Tokenator
func NewTokenator(vc VersionChecker, conf *config.JWTConfig) *Tokenator <span class="cov0" title="0">{
        return &amp;Tokenator{
                sign:          conf.Signature,
                tokenLifeSpan: conf.TokenLifeSpan,
                VC:            vc,
        }
}</span>

// CreateJWT генерирует JWT токен для заданного userID и version
func (t *Tokenator) CreateJWT(userID string, version int) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiration := now.Add(t.tokenLifeSpan)

        claims := JWTClaims{
                UserID:    userID,
                Version:   version,
                ExpiresAt: expiration.Unix(),
                StandardClaims: jwt.StandardClaims{
                        IssuedAt:  now.Unix(),
                        ExpiresAt: expiration.Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(t.sign))
}</span>

// ParseJWT парсит и валидирует JWT-токен
func (t *Tokenator) ParseJWT(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{

        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Проверяем, что метод подписи соответствует HMAC
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("unexpected signing method")
                }</span>

                <span class="cov0" title="0">return []byte(t.sign), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse jwt: %w", err)
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errs.ErrInvalidToken</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "net/http"
)

func CORSMiddleware(next http.Handler, conf *config.ServerConfig) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                origin := r.Header.Get("Origin")

                if origin == "" </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">allowedOrigin := conf.AllowOrigin

                if allowedOrigin != "*" &amp;&amp; allowedOrigin != origin </span><span class="cov8" title="1">{
                        http.Error(w, "CORS Origin not allowed", http.StatusForbidden)
                        return
                }</span>

                <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Methods", conf.AllowMethods)
                w.Header().Set("Access-Control-Allow-Headers", conf.AllowHeaders)
                w.Header().Set("Access-Control-Allow-Credentials", conf.AllowCredentials)
                w.Header().Set("Access-Control-Allow-Origin", conf.AllowOrigin)

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/sirupsen/logrus"
        "net/http"
        "time"
)

// JWTMiddleware проверяет наличие и валидность JWT-токена в куках
func JWTMiddleware(tokenator *jwt.Tokenator, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Получаем request_id из контекста
                reqID := ctx.Value(domains.ReqIDKey)
                if reqID == nil </span><span class="cov0" title="0">{
                        reqID = "unknown"
                }</span>

                // Логирование с request_id и remote_addr
                <span class="cov0" title="0">requestLogger := logrus.WithFields(logrus.Fields{
                        "request_id":  reqID,
                        "remote_addr": r.RemoteAddr,
                        "path":        r.URL.Path,
                })

                cookieValue, err := r.Cookie(string(domains.Token))
                if err != nil </span><span class="cov0" title="0">{
                        requestLogger.Warn("Missing or invalid token cookie")
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                // Получаем токен из куки
                <span class="cov0" title="0">tokenString := cookieValue.Value

                // Если токен пустой, возвращаем ошибку
                if tokenString == "" </span><span class="cov0" title="0">{
                        requestLogger.WithFields(logrus.Fields{
                                "method": r.Method,
                                "path":   r.URL.Path,
                                "ip":     r.RemoteAddr,
                        }).Warn("Empty token")
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                // Вызываем ParseJWT через экземпляр Tokenator
                <span class="cov0" title="0">claims, err := tokenator.ParseJWT(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        requestLogger.WithFields(logrus.Fields{
                                "method": r.Method,
                                "path":   r.URL.Path,
                                "ip":     r.RemoteAddr,
                                "error":  err.Error(),
                        }).Error("Invalid token")

                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Invalid token")
                        return
                }</span>

                // Проверяем, не истёк ли токен
                <span class="cov0" title="0">if claims.ExpiresAt &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        requestLogger.Warn("Token expired")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Token expired")
                        return
                }</span>

                <span class="cov0" title="0">if !tokenator.VC.CheckVersion(ctx, claims.UserID, claims.Version) </span><span class="cov0" title="0">{
                        requestLogger.Warn("Token is invalid or expired")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Token is invalid or expired")
                        return
                }</span>

                // Передаем userID в контекст
                <span class="cov0" title="0">ctx = context.WithValue(ctx, domains.UserIDKey, claims.UserID)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package logctx

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"

        "github.com/sirupsen/logrus"
)

func WithLogger(ctx context.Context, logger *logrus.Entry) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, domains.LoggerKey, logger)
}</span>

func GetLogger(ctx context.Context) *logrus.Entry <span class="cov8" title="1">{
        if logger, ok := ctx.Value(domains.LoggerKey).(*logrus.Entry); ok </span><span class="cov8" title="1">{
                return logger
        }</span>

        <span class="cov8" title="1">return logrus.NewEntry(logrus.New())</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package middleware

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "math/rand"
        "net/http"
        "time"

        "github.com/sirupsen/logrus"
)

func LogRequest(logger *logrus.Logger, next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                rand.Seed(time.Now().UnixNano())
                reqID := fmt.Sprintf("%016x", rand.Int())[:10]

                ctx := context.WithValue(r.Context(), domains.ReqIDKey, reqID)

                middlewareLogger := logger.WithFields(logrus.Fields{
                        "request_id":  reqID,
                        "method":      r.Method,
                        "remote_addr": r.RemoteAddr,
                        "path":        r.URL.Path,
                })

                // Логгер для передачи в контекст (только request_id)
                contextLogger := logrus.NewEntry(logger).WithField("request_id", reqID) // Важно: создаём новый Entry
                ctx = logctx.WithLogger(ctx, contextLogger)

                middlewareLogger.Info("request started")

                startTime := time.Now()

                defer func() </span><span class="cov8" title="1">{
                        duration := time.Since(startTime)
                        middlewareLogger.WithField("duration", duration).Info("request completed")
                }</span>()

                <span class="cov8" title="1">next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package order

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/order"
        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        "net/http"
)

type OrderService struct {
        u   order.IOrderUsecase
        log *logrus.Logger
}

func NewOrderService(
        u order.IOrderUsecase,
        log *logrus.Logger,
) *OrderService <span class="cov0" title="0">{
        return &amp;OrderService{
                u:   u,
                log: log,
        }
}</span>

//        @Summary                Create new order
//        @Description        Создает новый заказ для пользователя
//        @Tags                        order
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                models.CreateOrderDTO        true        "Данные для создания заказа"
//        @Success                200                {}                        "Order successfully created"
//        @Failure                400                {object}        dto.ErrorResponse        "Некорректный запрос"
//        @Failure                401                {object}        dto.ErrorResponse        "Пользователь не найден в контексте"
//        @Failure                404                {object}        dto.ErrorResponse        "Ошибка при создании заказа"
//        @Failure                500                {object}        dto.ErrorResponse        "Внутренняя ошибка сервера"
//        @Router                        /order [post]
func (o *OrderService) CreateOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userIDStr, isExist := r.Context().Value(domains.UserIDKey).(string)
        if !isExist </span><span class="cov0" title="0">{
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "user not found in context")
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid user id format")
                return
        }</span>

        <span class="cov0" title="0">var CreateOrderReq models.CreateOrderDTO
        if err := request.ParseData(r, &amp;CreateOrderReq); err != nil </span><span class="cov0" title="0">{
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">CreateOrderReq.UserID = userID
        if err := o.u.CreateOrder(r.Context(), CreateOrderReq); err != nil </span><span class="cov0" title="0">{
                response.HandleDomainError(r.Context(), w, err, "failed to create order")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package product

import (
        "context"
        "fmt"
        "io"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
)

//go:generate mockgen -source=product.go -destination=../../usecase/mocks/product_usecase_mock.go -package=mocks IProductUsecase
type IProductUsecase interface {
        GetAllProducts(ctx context.Context) ([]*models.Product, error)
        GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error)
        GetProductsByCategory(ctx context.Context, id uuid.UUID) ([]*models.Product, error)
}

type ProductService struct {
        u            IProductUsecase
        minioService minio.Provider
}

func NewProductService(u IProductUsecase, ms minio.Provider) *ProductService <span class="cov8" title="1">{
        return &amp;ProductService{
                u:            u,
                minioService: ms,
        }
}</span>

// GetAllProducts godoc
//
//        @Summary                Получить все продукты
//        @Description        Возвращает список всех продуктов
//        @Tags                        products
//        @Produce                json
//        @Success                200        {object}        []models.Product        "Список продуктов"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /products [get]
func (h *ProductService) GetAllProducts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.GetAllProducts"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        products, err := h.u.GetAllProducts(r.Context())
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get all products")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">productResponse := dto.ConvertToProductsResponse(products)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

// GetProductByID godoc
//
//        @Summary                Получить продукт по ID
//        @Description        Возвращает продукт по его ID
//        @Tags                        products
//        @Produce                json
//        @Param                        id        path                string                                true        "ID продукта"
//        @Success                200        {object}        models.Product                "Информация о продукте"
//        @Failure                400        {object}        dto.ErrorResponse        "Некорректный ID"
//        @Failure                404        {object}        dto.ErrorResponse        "Продукт не найден"
//        @Router                        /products/{id} [get]
func (h *ProductService) GetProductByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.GetProductByID"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
        response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
        return
    }</span>

        <span class="cov8" title="1">logger = logger.WithField("product_id", id)
        product, err := h.u.GetProductByID(r.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get product by ID")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, product)</span>
}

// GetProductsByCategory godoc
// 
//        @Summary                Получить товары по категории
//        @Description        Возвращает список всех одобренных товаров, принадлежащих указанной категории. 
// Товары сортируются по дате обновления (сначала новые).
//        @Tags                        products
//        @Produce                json
//        @Param                        id        path                string                                true        "UUID категории в формате строки"
//        @Success                200        {object}        []models.Product        "Успешный запрос. Возвращает массив товаров."
//        @Failure                400        {object}        dto.ErrorResponse        "Неверный формат UUID категории"
//        @Failure                404        {object}        dto.ErrorResponse        "Категория не найдена"
//        @Failure                500        {object}        dto.ErrorResponse        "Внутренняя ошибка сервера"
//        @Router                        /api/v1/products/category/{id} [get]
func (h *ProductService) GetProductsByCategory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.GetProductsByCategory"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).WithField("category_id", idStr).Error("parse category ID")
        response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
        return
    }</span>

        <span class="cov8" title="1">products, err := h.u.GetProductsByCategory(r.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get products by category")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">productResponse := dto.ConvertToProductsResponse(products)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

// FIXME: models.SuccessResponse не найден

// CreateOne godoc
//
//        @Summary                Загрузить файл в MinIO
//        @Description        Загружает один файл в хранилище MinIO
//        @Tags                        products
//        @Accept                        multipart/form-data
//        @Produce                json
//        @Param                        file        formData        file                                true        "Файл для загрузки"
//        @Success                200                {object}        map[string]string        "Информация о загруженном файле"
//        @Failure                400                {object}        dto.ErrorResponse        "Ошибка в запросе"
//        @Failure                500                {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /products/upload [post]
func (h *ProductService) CreateOne(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "ProductService.CreateOne"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Проверяем, что запрос содержит multipart/form-data
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse multipart form")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return 
    }</span>

        // Получаем файл из формы
        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get file from form")
        response.HandleDomainError(r.Context(), w, fmt.Errorf("no file uploaded"), op)
        return
    }</span>
        <span class="cov0" title="0">defer file.Close()

        // Читаем содержимое файла
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("read file content")
        response.HandleDomainError(r.Context(), w, fmt.Errorf("failed to read file"), op)
        return
    }</span>

        // Создаем структуру для MinIO
        <span class="cov0" title="0">fileData := minio.FileData{
                Name: header.Filename,
                Data:     fileBytes,
        }

        // Загружаем файл в MinIO
        productResponse, err := h.minioService.CreateOne(r.Context(), fileData)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("upload file to minio")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        // Возвращаем успешный ответ с URL файла
        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package user

import (
        "context"
        "fmt"
        "io"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/cookie"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator"
)

//go:generate mockgen -source=user.go -destination=../../usecase/mocks/user_usecase_mock.go -package=mocks
type IAuthUsecase interface {
        Register(context.Context, dto.UserRegisterRequestDTO) (string, error)
        Login(context.Context, dto.UserLoginRequestDTO) (string, error)
        Logout(context.Context) error
        GetMe(context.Context) (*models.User, error)
        UploadAvatar(context.Context, minio.FileData) (string, error)
}

type AuthService struct {
        AuthService  IAuthUsecase
        minioService minio.Provider
        config       config.Config
}

func NewAuthService(
        u IAuthUsecase,
        ms minio.Provider,
        cfg *config.Config,
) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                AuthService:  u,
                minioService: ms,
                config:       *cfg,
        }
}</span>

//        @Summary                Login user
//        @Description        Авторизация пользователя
//        @Tags                        auth
//        @Accept                        json
//        @Produce                json
//        @Param                        request        body                models.UserLoginRequestDTO        true        "User credentials"
//        @success                200                {}                        -                                                        "No Content"
//        @Header                        200                {string}        Set-Set                                                "Устанавливает JWT-токен в куки"
//        @Failure                400                {object}        dto.ErrorResponse                        "Ошибка валидации"
//        @Failure                401                {object}        dto.ErrorResponse                        "Неверные email или пароль"
//        @Failure                500                {object}        dto.ErrorResponse                        "Внутренняя ошибка сервера"
//        @Router                        /auth/login [post]

func (h *AuthService) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthService.Login"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var loginReq dto.UserLoginRequestDTO
        if err := request.ParseData(r, &amp;loginReq); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">validator.SanitizeUserLoginRequest(&amp;loginReq)

        if err := validator.ValidateLoginCreds(loginReq); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("email", loginReq.Email).Warn("validation failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">token, err := h.AuthService.Login(r.Context(), loginReq)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("email", loginReq.Email).Error("login failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(&amp;h.config)

        cookieProvider.Set(w, token, string(domains.Token))

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

//        @Summary                Register user
//        @Description        Создает нового пользователя, хеширует пароль и устанавливает JWT-токен в куки
//        @Tags                        auth
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                dto.UserRegisterRequestDTO        true        "Данные для регистрации"
//        @success                200                {}                        -                                                        "No Content"
//        @Header                        200                {string}        Set-Set                                                "Устанавливает JWT-токен в куки"
//        @Failure                400                {object}        dto.ErrorResponse                        "Некорректный запрос"
//        @Failure                409                {object}        dto.ErrorResponse                        "Пользователь уже существует"
//        @Failure                500                {object}        dto.ErrorResponse                        "Внутренняя ошибка сервера"
//        @Router                        /auth/register [post]
func (h *AuthService) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthService.Register"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    var registerReq dto.UserRegisterRequestDTO
    if err := request.ParseData(r, &amp;registerReq); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">validator.SanitizeUserRegistrationRequest(&amp;registerReq)

        if err := validator.ValidateRegistrationCreds(registerReq); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("email", registerReq.Email).Warn("validation failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">token, err := h.AuthService.Register(r.Context(), registerReq)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("email", registerReq.Email).Error("registration failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(&amp;h.config)

        cookieProvider.Set(w, token, string(domains.Token))

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

//        @Summary                Logout user
//        @Description        Выход пользователя
//        @Tags                        auth
//        @Security                TokenAuth
//        @Success                200        {}                        "No Content"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не найден"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /auth/logout [post]
func (h *AuthService) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthService.Logout"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        if err := h.AuthService.Logout(r.Context()); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("logout failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(&amp;h.config)

        cookieProvider.Unset(w, string(domains.Token))

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

//        @Summary                Get user info
//        @Description        Получение информации о текущем пользователе
//        @Tags                        users
//        @Security                TokenAuth
//        @Produce                json
//        @Success                200        {object}        models.User                        "Информация о пользователе"
//        @Failure                400        {object}        dto.ErrorResponse        "Некорректный запрос"
//        @Failure                401        {object}        dto.ErrorResponse        "Пользователь не найден"
//        @Failure                500        {object}        dto.ErrorResponse        "Ошибка сервера"
//        @Router                        /users/me [get]
func (h *AuthService) GetMe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthService.GetMe"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        user, err := h.AuthService.GetMe(r.Context())
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user info failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, user)</span>
}

//        @Summary                Upload avatar
//        @Description        Загружает аватар пользователя
//        @Tags                        users
//        @Accept                        multipart/form-data
//        @Produce                json
//        @Param                        file        formData        file                                true        "Файл изображения"
//        @Success                200                {object}        map[string]string        "URL загруженного аватара"
//        @Failure                400                {object}        dto.ErrorResponse        "Ошибка при обработке формы"
//        @Failure                500                {object}        dto.ErrorResponse        "Ошибка загрузки файла"
//        @Security                TokenAuth
//        @Router                        /users/avatar [post]
func (h *AuthService) UploadAvatar(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthService.UploadAvatar"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

        if err := r.ParseMultipartForm(h.config.ServerConfig.MaxMultipartMemory); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse multipart form")
        response.HandleDomainError(r.Context(), w, fmt.Errorf("parse form data"), op)
        return
    }</span>

    <span class="cov0" title="0">file, header, err := r.FormFile(h.config.ServerConfig.AvatarKey)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get file from form")
        response.HandleDomainError(r.Context(), w, fmt.Errorf("no file uploaded"), op)
        return
    }</span>

        <span class="cov0" title="0">defer file.Close()

        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("read file content")
        response.HandleDomainError(r.Context(), w, fmt.Errorf("read file"), op)
        return
    }</span>

        <span class="cov0" title="0">fileData := minio.FileData{
                Name: header.Filename,
                Data:     fileBytes,
        }

        logger = logger.WithField("filename", header.Filename)
    avatarURL, err := h.AuthService.UploadAvatar(r.Context(), fileData)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("upload avatar failed")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">logger.Debug("avatar uploaded successfully")
    response.SendJSONResponse(r.Context(), w, http.StatusOK, map[string]string{
        "imageURL": avatarURL,
    })</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package cookie

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "log"
        "net/http"
        "time"
)

type CookieProvider struct {
        cfg *config.Config
}

func NewCookieProvider(cfg *config.Config) *CookieProvider <span class="cov0" title="0">{
        if cfg == nil || cfg.JWTConfig == nil </span><span class="cov0" title="0">{
                log.Println("Warning: nil config or JWTConfig provided to CookieProvider")
        }</span>
        <span class="cov0" title="0">return &amp;CookieProvider{cfg: cfg}</span>
}

func (cp *CookieProvider) Set(w http.ResponseWriter, token, name string) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                log.Println("Warning: empty token for cookie", name)
                return
        }</span>

        <span class="cov0" title="0">tokenLifeSpan := 24 * time.Hour
        if cp.cfg != nil &amp;&amp; cp.cfg.JWTConfig != nil </span><span class="cov0" title="0">{
                tokenLifeSpan = cp.cfg.JWTConfig.TokenLifeSpan
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     name,
                Value:    token,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
                HttpOnly: true,
                Expires:  time.Now().UTC().Add(tokenLifeSpan),
        })</span>
}

func (cp *CookieProvider) Unset(w http.ResponseWriter, name string) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     name,
                Value:    "",
                Path:     "/",
                Expires:  time.Now().UTC().AddDate(0, 0, -1),
                HttpOnly: true,
                Secure:   true,
        })
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package request

import (
        "encoding/json"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "io"
        "net/http"
)

func ParseData(r *http.Request, request any) error <span class="cov8" title="1">{
        defer r.Body.Close()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return errs.ErrReadRequestData
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, request); err != nil </span><span class="cov8" title="1">{
                return errs.ErrParseRequestData
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package response

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "net/http"
)

func SendJSONError(ctx context.Context, w http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        resp, err := json.Marshal(dto.ErrorResponse{Message: message})
        if err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to marshal response: ", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if _, err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to write response: ", err.Error())
        }</span>
}

func SendJSONResponse(ctx context.Context, w http.ResponseWriter, statusCode int, body any) <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                w.WriteHeader(statusCode)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        resp, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                logctx.GetLogger(ctx).Error("failed to marshal response", err.Error())
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(statusCode)
        if _, err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to write response", err.Error())
        }</span>
}

func HandleDomainError(ctx context.Context, w http.ResponseWriter, err error, description string) <span class="cov8" title="1">{
        log := logctx.GetLogger(ctx)

        switch </span>{
        case errors.Is(err, errs.ErrInvalidCredentials):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusUnauthorized, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid credentials error: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusNotFound, fmt.Sprintf("%s: %v", description, err))
                log.Debug("user not found: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrAlreadyExists):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusConflict, fmt.Sprintf("%s: %v", description, err))
                log.Debug("user already exists: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrInvalidID):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid user id format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrInvalidToken):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusUnauthorized, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid token: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrAlreadyExists):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusConflict, fmt.Sprintf("%s: %v", description, err))
                log.Debug("resource already exists: ", description, errs.NewAlreadyExistsError(description))</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusNotFound, fmt.Sprintf("%s: %v", description, err))
                log.Debug("resource not found: ", description, errs.NewNotFoundError(description))</span>

        case errors.Is(err, errs.ErrInvalidID):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid id format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrBusinessLogic):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusUnprocessableEntity, fmt.Sprintf("%s: %v", description, err))
                log.Debug("business logic error: ", description, errs.NewBusinessLogicError(description))</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusNotFound, fmt.Sprintf("%s: %v", description, err))
                log.Debug("product not found: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrProductNotApproved):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusForbidden, fmt.Sprintf("%s: %v", description, err))
                log.Debug("product not approved: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrNotEnoughStock):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("not enough stock: ", description, err.Error())</span>

        default:<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusInternalServerError, err.Error())
                log.Error("unexpected error: ", description, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package validator

import (
        "errors"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "regexp"
        "strings"
)

var (
        emailRegexp     = regexp.MustCompile(`^\w+(\.\w*)*@\w+(\.\w{2,})+$`)
        nameRegexp      = regexp.MustCompile(`^[a-zA-Zа-яА-ЯёЁ\s-]+$`)
        digitRegexp     = regexp.MustCompile(`[0-9]`)
        lowercaseRegexp = regexp.MustCompile(`[a-z]`)
        uppercaseRegexp = regexp.MustCompile(`[A-Z]`)
)

func ValidateLoginCreds(req dto.UserLoginRequestDTO) error <span class="cov0" title="0">{
        if err := validateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateRegistrationCreds проверяет корректность данных при регистрации
func ValidateRegistrationCreds(req dto.UserRegisterRequestDTO) error <span class="cov0" title="0">{
        if err := validateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateName(req.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if req.Surname.Valid </span><span class="cov0" title="0">{
                if err := validateName(req.Surname.String); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateEmail Функция валидации почты
func validateEmail(email string) error <span class="cov0" title="0">{
        if !emailRegexp.MatchString(email) </span><span class="cov0" title="0">{
                return errors.New("invalid email")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validatePassword проверяет валидность пароля
func validatePassword(password string) error <span class="cov0" title="0">{
        switch </span>{
        case len(password) &lt; 8:<span class="cov0" title="0">
                return errors.New("password must be at least 8 characters")</span>
        case !digitRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one number")</span>
        case !lowercaseRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one lowercase letter")</span>
        case !uppercaseRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one uppercase letter")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateName проверяет валидность имени пользователя
func validateName(name string) error <span class="cov0" title="0">{
        if len(name) &lt; 2 || len(name) &gt; 24 </span><span class="cov0" title="0">{
                return errors.New("name must be between 2 and 24 characters long")
        }</span>

        <span class="cov0" title="0">if !nameRegexp.MatchString(name) </span><span class="cov0" title="0">{
                return errors.New("name can only contain letters, spaces, and '-'")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sanitizeUserRegistrationRequest удаляет лишние пробелы из полей запроса регистрации пользователя
func SanitizeUserRegistrationRequest(req *dto.UserRegisterRequestDTO) <span class="cov0" title="0">{
        req.Email = strings.TrimSpace(req.Email)
        req.Name = strings.TrimSpace(req.Name)
        req.Password = strings.TrimSpace(req.Password)
        if req.Surname.Valid </span><span class="cov0" title="0">{
                req.Surname.String = strings.TrimSpace(req.Surname.String)
                req.Surname.Valid = req.Surname.String != ""
        }</span>
}

// sanitizeUserLoginRequest удаляет лишние пробелы из полей запроса для логина пользователя
func SanitizeUserLoginRequest(req *dto.UserLoginRequestDTO) <span class="cov0" title="0">{
        req.Email = strings.TrimSpace(req.Email)
        req.Password = strings.TrimSpace(req.Password)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package basket

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
        "github.com/google/uuid"
)

//go:generate mockgen -source=basket.go -destination=../../infrastructure/repository/postgres/mocks/basket_repository_mock.go -package=mocks IBasketRepository
type IBasketRepository interface{
        Get(ctx context.Context, userID uuid.UUID) ([]*models.BasketItem, error)
        Add(ctx context.Context, userID uuid.UUID, productID uuid.UUID) (*models.BasketItem, error)
        Delete(ctx context.Context, userID uuid.UUID, productID uuid.UUID) error
        UpdateQuantity(ctx context.Context, userID uuid.UUID, productID uuid.UUID, quantity int) (*models.BasketItem, int, error)
        Clear(ctx context.Context, userID uuid.UUID) error
}

type BasketUsecase struct {
        repo IBasketRepository
}

func NewBasketUsecase(repo IBasketRepository) *BasketUsecase <span class="cov8" title="1">{
        return &amp;BasketUsecase{
                repo: repo,
        }
}</span>

func (u *BasketUsecase)Get(ctx context.Context)([]*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Get"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
    items, err := u.repo.Get(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket items from repo")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return items, nil</span>
}


func (u *BasketUsecase)Add(ctx context.Context, productID uuid.UUID)(*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Add"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    if productID == uuid.Nil </span><span class="cov8" title="1">{
        logger.Error("invalid product ID")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user ID from context")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        item, err := u.repo.Add(ctx, userID, productID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("add product to basket")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return item, nil</span>
}

func (u *BasketUsecase)Delete(ctx context.Context, productID uuid.UUID)(error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Delete"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        err = u.repo.Delete(ctx, userID, productID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("delete product from basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *BasketUsecase)UpdateQuantity(ctx context.Context, productID uuid.UUID, quantity int)(*models.BasketItem, int, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.UpdateQuantity"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    if quantity &lt;= 0 </span><span class="cov8" title="1">{
        logger.WithField("quantity", quantity).Error("invalid quantity")
        return nil, -1, fmt.Errorf("%s: %w", op, errs.NewBusinessLogicError("invalid quantity"))
    }</span>

        <span class="cov8" title="1">if productID == uuid.Nil </span><span class="cov8" title="1">{
        logger.Error("invalid product ID")
        return nil, -1, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return nil, -1, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        item, rem ,err := u.repo.UpdateQuantity(ctx, userID, productID, quantity)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("update product quantity")
        return nil, -1, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return item, rem, nil</span>
}

func (u *BasketUsecase)Clear(ctx context.Context,)(error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Clear"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
    err = u.repo.Clear(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("clear basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file34" style="display: none">package category

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

//go:generate mockgen -source=category.go -destination=../../infrastructure/repository/postgres/mocks/category_repository_mock.go -package=mocks ICategoryRepository
type ICategoryRepository interface {
        GetAllCategories(ctx context.Context)([]*models.Category, error)
}

type CategoryUsecase struct {
        repo ICategoryRepository
}

func NewCategoryUsecase(repo ICategoryRepository) *CategoryUsecase <span class="cov8" title="1">{
        return &amp;CategoryUsecase{
                repo: repo,
        }
}</span>

func (u *CategoryUsecase) GetAllCategories(ctx context.Context)([]*models.Category, error) <span class="cov8" title="1">{
        const op = "CategoryUsecase.GetAllCategories"
    logger := logctx.GetLogger(ctx).WithField("op", op)
        
        categories, err := u.repo.GetAllCategories(ctx)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get categories from repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return categories, nil</span>
}</pre>
		
		<pre class="file" id="file35" style="display: none">package helpers

import "golang.org/x/crypto/bcrypt"

// GeneratePasswordHash Генерация хэша пароля
func GeneratePasswordHash(password string) ([]byte, error) <span class="cov8" title="1">{
        return bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package helpers

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/google/uuid"
)

func GetUserIDFromContext(ctx context.Context) (uuid.UUID, error) <span class="cov8" title="1">{
    userIDStr, isExist := ctx.Value(domains.UserIDKey).(string)
    if !isExist </span><span class="cov8" title="1">{
        return uuid.Nil, errs.NewNotFoundError("user not found")
    }</span>
    
    <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
    if err != nil </span><span class="cov8" title="1">{
        return uuid.Nil, errs.ErrInvalidID
    }</span>
    
    <span class="cov8" title="1">return userID, nil</span>
}</pre>
		
		<pre class="file" id="file37" style="display: none">package order

import (
        "context"
        "errors"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/order"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        "sync"
        "time"
)

type IOrderUsecase interface {
        CreateOrder(context.Context, models.CreateOrderDTO) error
}

type OrderUsecase struct {
        repo order.IOrderRepository
        log  *logrus.Logger
}

func NewOrderUsecase(
        repo order.IOrderRepository,
        log *logrus.Logger,
) *OrderUsecase <span class="cov0" title="0">{
        return &amp;OrderUsecase{
                repo: repo,
                log:  log,
        }
}</span>

func (u *OrderUsecase) CreateOrder(ctx context.Context, in models.CreateOrderDTO) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        orderItems := make([]models.CreateOrderItemDTO, len(in.Items))
        now := time.Now()

        var totalPrice float64 = 0
        var totalDiscountedPrice float64 = 0

        newQuantities := make(map[uuid.UUID]uint)

        mu := &amp;sync.Mutex{}
        var totalWg sync.WaitGroup
        errCh := make(chan error, 1)

        for i, item := range in.Items </span><span class="cov0" title="0">{
                item.ID = uuid.New()
                orderItems[i] = item

                totalWg.Add(1)
                go func(i int, item models.CreateOrderItemDTO) </span><span class="cov0" title="0">{
                        defer totalWg.Done()

                        var innerWg sync.WaitGroup
                        innerWg.Add(2)

                        var (
                                product     *models.Product
                                productErr  error
                                discounts   []models.ProductDiscount
                                discountErr error
                        )

                        // Получаем статус количество и цену товара
                        go func() </span><span class="cov0" title="0">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">product, productErr = u.repo.ProductPrice(ctx, item.ProductID)
                                if productErr != nil </span><span class="cov0" title="0">{
                                        u.log.WithFields(logrus.Fields{
                                                "product_id": item.ProductID,
                                                "error":      productErr,
                                                "action":     "get_product_price",
                                        }).Error("Failed to fetch product price")
                                        trySendError(productErr, errCh, cancel)
                                        return
                                }</span>
                        }()

                        // Получаем скидку товара, если она есть
                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">discounts, discountErr = u.repo.ProductDiscounts(ctx, item.ProductID)
                                u.log.WithFields(logrus.Fields{
                                        "product_id": item.ProductID,
                                        "error":      discountErr,
                                        "action":     "get_product_discount",
                                }).Error("Failed to fetch product discount")
                                if discountErr != nil &amp;&amp; !errors.Is(discountErr, errs.ErrNotFound) </span><span class="cov0" title="0">{
                                        trySendError(discountErr, errCh, cancel)
                                        return
                                }</span>
                        }()

                        <span class="cov0" title="0">innerWg.Wait()

                        // Проверяем отмену после запросов
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if product.Status != models.ProductApproved </span><span class="cov0" title="0">{
                                u.log.WithFields(logrus.Fields{
                                        "product_id":      item.ProductID,
                                        "status":          product.Status,
                                        "required_status": models.ProductApproved,
                                }).Warn("Product not approved")
                                trySendError(errs.ErrProductNotApproved, errCh, cancel)
                                return
                        }</span>
                        <span class="cov0" title="0">if product.Quantity &lt; item.Quantity </span><span class="cov0" title="0">{
                                trySendError(errs.ErrNotEnoughStock, errCh, cancel)
                                return
                        }</span>

                        <span class="cov0" title="0">discount, _ := findLatestDiscount(discounts)

                        mu.Lock()

                        var priceToSave float64
                        totalPrice += product.Price * float64(item.Quantity)
                        newQuantities[item.ProductID] = product.Quantity - item.Quantity

                        // Если есть скидка и она активна
                        if discount.DiscountedPrice != 0 &amp;&amp; discount.DiscountEndDate.After(now) </span><span class="cov0" title="0">{
                                totalDiscountedPrice += discount.DiscountedPrice * float64(item.Quantity)
                                priceToSave = discount.DiscountedPrice
                        }</span> else<span class="cov0" title="0"> {
                                totalDiscountedPrice += product.Price * float64(item.Quantity)
                                priceToSave = product.Price
                        }</span>
                        <span class="cov0" title="0">orderItems[i].Price = priceToSave
                        mu.Unlock()</span>

                }(i, item)
        }

        // Горутина для закрытия канала после завершения всех операций
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                totalWg.Wait()
                close(errCh)
        }</span>()

        // Возвращаем первую ошибку (если есть)
        <span class="cov0" title="0">if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">order := &amp;models.Order{
                ID:                 uuid.New(),
                UserID:             in.UserID,
                Status:             models.Pending,
                TotalPrice:         totalPrice,
                TotalPriceDiscount: totalDiscountedPrice,
                AddressID:          in.AddressID,
                Items:              orderItems,
        }

        u.log.Infoln(totalPrice, totalDiscountedPrice)

        return u.repo.CreateOrder(ctx, models.CreateOrderRepoReq{
                Order:             order,
                UpdatedQuantities: newQuantities,
        })</span>
}

// trySendError Вспомогательная функция для безопасной отправки ошибки
func trySendError(err error, errCh chan&lt;- error, cancel context.CancelFunc) <span class="cov0" title="0">{
        select </span>{
        case errCh &lt;- err:<span class="cov0" title="0">
                cancel()</span>
        default:<span class="cov0" title="0"></span>
                // Если ошибка уже есть - игнорируем (сохраняем первую)
        }
}

// findLatestDiscount Достаём последнюю созданную скидку
func findLatestDiscount(discounts []models.ProductDiscount) (models.ProductDiscount, bool) <span class="cov0" title="0">{
        if len(discounts) == 0 </span><span class="cov0" title="0">{
                return models.ProductDiscount{}, false
        }</span>

        <span class="cov0" title="0">latest := discounts[0]
        for _, discount := range discounts[1:] </span><span class="cov0" title="0">{
                if discount.DiscountStartDate.After(latest.DiscountStartDate) </span><span class="cov0" title="0">{
                        latest = discount
                }</span>
        }

        <span class="cov0" title="0">return latest, true</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package product

import (
        "context"
        "fmt"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

//go:generate mockgen -source=product.go -destination=../../infrastructure/repository/postgres/mocks/product_repository_mock.go -package=mocks IProductRepository
type IProductRepository interface {
        GetAllProducts(ctx context.Context) ([]*models.Product, error)
        GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error)
        GetProductsByCategory(ctx context.Context, id uuid.UUID)([]*models.Product, error)
}

type ProductUsecase struct {
        repo IProductRepository
}

func NewProductUsecase(repo IProductRepository) *ProductUsecase <span class="cov8" title="1">{
        return &amp;ProductUsecase{
                repo: repo,
        }
}</span>

func (u *ProductUsecase) GetAllProducts(ctx context.Context) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductUsecase.GetAllProducts"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    products, err := u.repo.GetAllProducts(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get products from repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return products, nil</span>
}

func (u *ProductUsecase) GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductUsecase.GetProductByID"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", id)

    product, err := u.repo.GetProductByID(ctx, id)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get product by ID from repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>
        <span class="cov8" title="1">return product, nil</span>
}

func (u *ProductUsecase) GetProductsByCategory(ctx context.Context, id uuid.UUID) ([]*models.Product, error)<span class="cov8" title="1">{
        const op = "ProductUsecase.GetProductsByCategory"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("category_id", id)

    products, err := u.repo.GetProductsByCategory(ctx, id)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get products by category from repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return products, nil</span>
}</pre>
		
		<pre class="file" id="file39" style="display: none">package user

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
)

type ITokenator interface {
        CreateJWT(userID string, version int) (string, error)
        ParseJWT(tokenString string) (*jwt.JWTClaims, error)
}

//go:generate mockgen -source=user.go -destination=../../infrastructure/repository/postgres/mocks/user_repository_mock.go -package=mocks IProductRepository
type IUserRepository interface {
        Create(context.Context, dto.UserDB) error
        GetByEmail(context.Context, string) (*dto.UserDB, error)
        GetByID(context.Context, uuid.UUID) (*dto.UserDB, error)
        IncrementVersion(context.Context, string) error
        GetCurrentVersion(context.Context, string) (int, error)
        CheckVersion(context.Context, string, int) bool
        CheckExistence(context.Context, string) (bool, error)
        UpdateImageURL(context.Context, uuid.UUID, string) error
}

type AuthUsecase struct {
        token        ITokenator
        repo         IUserRepository
        minioService minio.Provider
}

func NewAuthUsecase(repo IUserRepository, token ITokenator, minioService minio.Provider) *AuthUsecase <span class="cov8" title="1">{
        return &amp;AuthUsecase{
                repo:         repo,
                token:        token,
                minioService: minioService,
        }
}</span>

func (u *AuthUsecase) Register(ctx context.Context, user dto.UserRegisterRequestDTO) (string, error) <span class="cov8" title="1">{
        const op = "authUsecaseRegister"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        passwordHash, err := helpers.GeneratePasswordHash(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to generate password hash")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">existed, err := u.repo.CheckExistence(ctx, user.Email)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to check user existence")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if existed </span><span class="cov8" title="1">{
                logger.Warn("user already exists")
                return "", fmt.Errorf("%s: %w", op, errs.ErrAlreadyExists)
        }</span>

        <span class="cov8" title="1">userDB := dto.NewFromRequest(user, passwordHash)

        if err = u.repo.Create(ctx, userDB); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to create user in repository")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">token, err := u.token.CreateJWT(userDB.ID.String(), userDB.UserVersion.Version)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to create JWT token")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (u *AuthUsecase) Login(ctx context.Context, user dto.UserLoginRequestDTO) (string, error) <span class="cov8" title="1">{
        const op = "authUsecaseLogin"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        userDB, err := u.repo.GetByEmail(ctx, user.Email)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get user by email")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword(userDB.PasswordHash, []byte(user.Password)); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Warn("invalid credentials provided")
                return "", fmt.Errorf("%s: %w", op, errs.ErrInvalidCredentials)
        }</span>

        <span class="cov8" title="1">token, err := u.token.CreateJWT(userDB.ID.String(), userDB.UserVersion.Version)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to create JWT token")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (u *AuthUsecase) Logout(ctx context.Context) error <span class="cov8" title="1">{
        const op = "authUsecaseLogout"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        userID, isExist := ctx.Value(domains.UserIDKey).(string)
        if !isExist </span><span class="cov8" title="1">{
                logger.Error("user ID not found in context")
                return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">if err := u.repo.IncrementVersion(ctx, userID); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("increment user version")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *AuthUsecase) GetMe(ctx context.Context) (*models.User, error) <span class="cov8" title="1">{
        const op = "authUsecaseGetMe"
    logger := logctx.GetLogger(ctx).WithField("op", op)
        logger.Info("start")

        userID, err := helpers.GetUserIDFromContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get user ID from context")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">userDB, err := u.repo.GetByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get user by ID")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">user := userDB.ConvertToUser()
        if user == nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("user not found after conversion")
                return nil, fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (u *AuthUsecase) UploadAvatar(ctx context.Context, fileData minio.FileData) (string, error) <span class="cov0" title="0">{
        const op = "authUsecaseUploadAvatar"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        userID, err := helpers.GetUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get user ID from context")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">avatar, err := u.minioService.CreateOne(ctx, fileData)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create avatar in storage")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">if err = u.repo.UpdateImageURL(ctx, userID, avatar.URL); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("update user avatar URL")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return avatar.URL, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
