
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>minio: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio/minio_client.go (0.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/address/address.go (88.1%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/admin/admin.go (90.8%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/auth/auth.go (82.7%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/basket/basket.go (75.4%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/category/category.go (92.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/csat/csat.go (89.7%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/dbconnector.go (0.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/order/order.go (83.2%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/product/product.go (81.9%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/review/review.go (86.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/search/search.go (83.7%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/seller/seller.go (84.7%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/suggestions/suggestions.go (81.8%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/user/user.go (97.8%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis/auth_repository.go (0.0%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis/redis_client.go (0.0%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis/search_repository.go (0.0%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs/errors.go (22.2%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/order.go (71.4%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/product.go (72.7%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/user.go (62.5%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/address/address.go (16.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/admin/admin.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/auth/grpc/auth.go (0.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/auth/http/auth.go (0.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/basket/basket.go (82.4%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/category/category.go (23.3%)</option>
				
				<option value="file28">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/csat/grpc/csat.go (0.0%)</option>
				
				<option value="file29">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/csat/http/csat.go (0.0%)</option>
				
				<option value="file30">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/admin.go (87.5%)</option>
				
				<option value="file31">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/auth.go (0.0%)</option>
				
				<option value="file32">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/basket.go (100.0%)</option>
				
				<option value="file33">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/category.go (100.0%)</option>
				
				<option value="file34">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/csat.go (7.3%)</option>
				
				<option value="file35">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/order.go (0.0%)</option>
				
				<option value="file36">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/product.go (77.8%)</option>
				
				<option value="file37">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/review.go (0.0%)</option>
				
				<option value="file38">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto/user.go (0.0%)</option>
				
				<option value="file39">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt/jwt.go (0.0%)</option>
				
				<option value="file40">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/cors.go (85.7%)</option>
				
				<option value="file41">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/csrf.go (0.0%)</option>
				
				<option value="file42">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/grpc/userID.go (0.0%)</option>
				
				<option value="file43">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/jwt.go (0.0%)</option>
				
				<option value="file44">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx/logctx.go (100.0%)</option>
				
				<option value="file45">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logger.go (100.0%)</option>
				
				<option value="file46">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/metrics.go (0.0%)</option>
				
				<option value="file47">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/role.go (0.0%)</option>
				
				<option value="file48">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/order/order.go (0.0%)</option>
				
				<option value="file49">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/product/product.go (69.8%)</option>
				
				<option value="file50">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/review/grpc/review.go (0.0%)</option>
				
				<option value="file51">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/review/http/review.go (0.0%)</option>
				
				<option value="file52">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/search/search.go (0.0%)</option>
				
				<option value="file53">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/seller/seller.go (0.0%)</option>
				
				<option value="file54">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/suggestions/suggestions.go (0.0%)</option>
				
				<option value="file55">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/user/grpc/user.go (0.0%)</option>
				
				<option value="file56">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/user/http/user.go (0.0%)</option>
				
				<option value="file57">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/cookie/cookie.go (0.0%)</option>
				
				<option value="file58">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/metadata/metadata.go (0.0%)</option>
				
				<option value="file59">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request/request.go (85.7%)</option>
				
				<option value="file60">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response/response.go (37.3%)</option>
				
				<option value="file61">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator/validator.go (0.0%)</option>
				
				<option value="file62">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/address/address.go (81.8%)</option>
				
				<option value="file63">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/admin/admin.go (56.0%)</option>
				
				<option value="file64">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/auth/auth.go (82.4%)</option>
				
				<option value="file65">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/basket/basket.go (97.1%)</option>
				
				<option value="file66">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/category/category.go (36.4%)</option>
				
				<option value="file67">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/csat/csat.go (100.0%)</option>
				
				<option value="file68">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers/finalPrice.go (100.0%)</option>
				
				<option value="file69">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers/passwordHash.go (0.0%)</option>
				
				<option value="file70">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers/userID.go (85.7%)</option>
				
				<option value="file71">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/order/order.go (44.1%)</option>
				
				<option value="file72">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/product/product.go (86.0%)</option>
				
				<option value="file73">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/review/review.go (100.0%)</option>
				
				<option value="file74">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/search/search.go (94.4%)</option>
				
				<option value="file75">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/seller/seller.go (100.0%)</option>
				
				<option value="file76">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/suggestions/suggestions.go (90.0%)</option>
				
				<option value="file77">github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/user/user.go (70.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package minio

import (
        "bytes"
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/google/uuid"
        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
        "github.com/sirupsen/logrus"
)

//go:generate mockgen -source=minio_client.go -destination=./mocks/minio_provider_mock.go -package=mocks Provider
type Provider interface {
        CreateOne(context.Context, FileData) (*dto.UploadResponse, error)
        // CreateMany(context.Context, map[string]FileData) ([]string, error)
        // GetOne(context.Context, string) ([]byte, error)
        // GetMany(context.Context, []string) ([]string, error)
        // DeleteOne(context.Context, string) error
        // DeleteMany(context.Context, []string) error
}

type minioProvider struct {
        mc     *minio.Client
        config *config.MinioConfig
        log    *logrus.Logger
}

func NewMinioProvider(config *config.MinioConfig, log *logrus.Logger) (Provider, error) <span class="cov0" title="0">{
        Provider, err := initMinio(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;minioProvider{
                mc:     Provider,
                config: config,
                log:    log,
        }, nil</span>
}

// InitMinio подключается к Minio и создает бакет, если не существует
// Бакет - это контейнер для хранения объектов в Minio. Он представляет собой пространство имен, в котором можно хранить и организовывать файлы и папки.
func initMinio(config *config.MinioConfig) (*minio.Client, error) <span class="cov0" title="0">{
        // Создание контекста с возможностью отмены операции
        ctx := context.Background()

        // Подключение к Minio с использованием имени пользователя и пароля
        Provider, err := minio.New(config.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(config.RootUser, config.RootPassword, ""),
                Secure: config.UseSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Проверка наличия бакета и его создание, если не существует
        <span class="cov0" title="0">exists, err := Provider.BucketExists(ctx, config.BucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                policy := `{
                        "Version": "2012-10-17",
                        "Statement": [
                                {
                                        "Effect": "Allow",
                                        "Principal": {"AWS": ["*"]},
                                        "Action": ["s3:GetObject"],
                                        "Resource": ["arn:aws:s3:::%s/*"]
                                }
                        ]
                }`
                if err = Provider.SetBucketPolicy(ctx, config.BucketName, fmt.Sprintf(policy, config.BucketName)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set bucket policy: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return Provider, nil</span>
}

// CreateOne создает один объект в бакете Minio.
// Метод принимает структуру FileDataType, которая содержит имя файла и его данные.
// В случае успешной загрузки данных в бакет, метод возвращает nil, иначе возвращает ошибку.
// Все операции выполняются в контексте задачи.
func (m *minioProvider) CreateOne(ctx context.Context, file FileData) (*dto.UploadResponse, error) <span class="cov0" title="0">{
        // Генерация уникального идентификатора для нового объекта.
        objectID := uuid.New().String()
        logFields := logrus.Fields{
                "object_id": objectID,
                "file_name": file.Name,
                "size":      len(file.Data),
        }

        m.log.WithFields(logFields).Debug("attempting to upload file to MinIO")

        // Создание потока данных для загрузки в бакет Minio.
        reader := bytes.NewReader(file.Data)

        // Загрузка данных в бакет Minio с использованием контекста для возможности отмены операции.
        uploadInfo, err := m.mc.PutObject(
                ctx,
                m.config.BucketName,
                objectID,
                reader,
                int64(len(file.Data)),
                minio.PutObjectOptions{ContentType: "image/jpeg"},
        )
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithFields(logFields).WithError(err).Error("failed to upload file to MinIO")
                return nil, fmt.Errorf("failed to create object %s: %v", file.Name, err)
        }</span>

        // Добавляем информацию о загрузке в логи
        <span class="cov0" title="0">logFields["upload_info"] = uploadInfo
        m.log.WithFields(logFields).Debug("file upload details")

        m.log.WithFields(logFields).Info("file successfully uploaded to MinIO")

        url := fmt.Sprintf("%s%s", m.config.PublicURL, objectID)

        return &amp;dto.UploadResponse{
                URL:      url,
                ObjectID: objectID,
        }, nil</span>
}

// CreateMany создает несколько объектов в хранилище MinIO из переданных данных.
// Если происходит ошибка при создании объекта, метод возвращает ошибку,
// указывающую на неудачные объекты.
// func (m *minioProvider) CreateMany(ctx context.Context, data map[string]FileData) ([]string, error) {
//         logFields := logrus.Fields{
//         "total_files": len(data),
//     }

//         ctx, cancel := context.WithCancel(ctx)
//         defer cancel()

//         // Создание канала для передачи URL-адресов с размером, равным количеству переданных данных.
//         urlCh := make(chan string, len(data))
//         errCh := make(chan error, len(data))

//         var wg sync.WaitGroup

//         // Запуск горутин для создания каждого объекта.
//         for objectID, file := range data {
//                 wg.Add(1)
//                 go func(objectID string, file FileData) {
//                         defer wg.Done() // Уменьшение счетчика WaitGroup после завершения горутины.

//                         fileLogFields := logrus.Fields{
//                                 "object_id": objectID,
//                                 "file_name": file.Name,
//                                 "size":      len(file.Data),
//                         }

//                         uploadInfo, err := m.mc.PutObject(
//                                 ctx,
//                                 m.config.BucketName,
//                                 objectID,
//                                 bytes.NewReader(file.Data),
//                                 int64(len(file.Data)),
//                                 minio.PutObjectOptions{
//                                 ContentType: "image/jpeg",
//                         })
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to upload file")
//                                 errCh &lt;- fmt.Errorf("failed to upload object %s: %v", objectID, err)
//                                 cancel()
//                                 return
//                         }

//                         // Логируем информацию о загрузке
//                         fileLogFields["upload_info"] = uploadInfo
//                         m.log.WithFields(fileLogFields).Debug("file upload details")

//                         // Получение URL для загруженного объекта
//                         url, err := m.mc.PresignedGetObject(ctx, m.config.BucketName, objectID, time.Second*24*60*60, nil)
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to generate presigned URL")
//                                 errCh &lt;- fmt.Errorf("failed to generate URL for object %s: %v", objectID, err)
//                                 cancel()
//                                 return
//                         }

//                         m.log.WithFields(fileLogFields).Debug("file successfully uploaded")
//                         urlCh &lt;- url.String()
//                 }(objectID, file)
//         }

//         // Ожидание завершения всех горутин и закрытие канала с URL-адресами.
//         go func() {
//                 wg.Wait()    // Блокировка до тех пор, пока счетчик WaitGroup не станет равным 0.
//                 close(urlCh) // Закрытие канала с URL-адресами после завершения всех горутин.
//                 close(errCh)
//         }()

//         var urls []string
//     for i := 0; i &lt; len(data); i++ {
//         select {
//         case url := &lt;-urlCh:
//             urls = append(urls, url)
//         case err := &lt;-errCh:
//             m.log.WithFields(logFields).WithError(err).Error("upload failed")
//             return urls, err // Частичные результаты + ошибка
//         }
//     }

//     m.log.WithFields(logFields).Info("all files successfully uploaded")
//         return urls, nil
// }

// GetOne получает один объект из бакета Minio по его идентификатору.
// Он принимает строку `objectID` в качестве параметра и возвращает срез байт данных объекта и ошибку, если такая возникает.
// func (m *minioProvider) GetOne(ctx context.Context, objectID string) ([]byte, error) {
//         logFields := logrus.Fields{
//                 "object_id": objectID,
//         }

//         m.log.WithFields(logFields).Debug("attempting to get file URL from MinIO")

//         reader, err := m.mc.GetObject(ctx, m.config.BucketName, objectID, minio.GetObjectOptions{})
//     if err != nil {
//         m.log.WithFields(logFields).WithError(err).Error("failed to get object from MinIO")
//         return nil, fmt.Errorf("failed to get object: %v", err)
//     }
//         defer reader.Close()
//         if err != nil {
//                 m.log.Fatal(err)
//         }

//         data, err := io.ReadAll(reader)
//     if err != nil {
//         m.log.WithFields(logFields).WithError(err).Error("failed to read object data")
//         return nil, fmt.Errorf("failed to read object data: %v", err)
//     }
//         if len(data) == 0 {
//         m.log.WithFields(logFields).Warn("object data is empty")
//         return nil, fmt.Errorf("object data is empty")
//     }

//     m.log.WithFields(logFields).Debug("successfully retrieved file data")
//         return data, nil
// }

// GetMany получает несколько объектов из бакета Minio по их идентификаторам.
// func (m *minioProvider) GetMany(ctx context.Context, objectIDs []string) ([]string, error) {
//         logFields := logrus.Fields{
//                 "total_objects": len(objectIDs),
//         }

//         m.log.WithFields(logFields).Debug("attempting to get multiple file URLs from MinIO")

//         // Создание каналов для передачи URL-адресов объектов и ошибок
//         urlCh := make(chan string, len(objectIDs))
//         errCh := make(chan OperationError, len(objectIDs))

//         var wg sync.WaitGroup                // WaitGroup для ожидания завершения всех горутин
//         ctx, cancel := context.WithCancel(ctx) // Создание контекста с возможностью отмены операции
//         defer cancel()                       // Отложенный вызов функции отмены контекста при завершении функции GetMany

//         // Запуск горутин для получения URL-адресов каждого объекта.
//         for _, objectID := range objectIDs {
//                 wg.Add(1)
//                 go func(objectID string) {
//                         defer wg.Done()
//                         fileLogFields := logrus.Fields{
//                                 "object_id": objectID,
//                         }

//                         url, err := m.GetOne(ctx, objectID)
//                         if err != nil {
//                                 m.log.WithFields(fileLogFields).WithError(err).Error("failed to get file URL")
//                                 errCh &lt;- OperationError{ObjectID: objectID, Error: fmt.Errorf("failed to retrieve object %s: %v", objectID, err)}
//                                 cancel()
//                                 return
//                         }
//                         m.log.WithFields(fileLogFields).Debug("successfully retrieved file URL")
//                         urlCh &lt;- url
//                 }(objectID)
//         }

//         // Закрытие каналов после завершения всех горутин.
//         go func() {
//                 wg.Wait()    // Блокировка до тех пор, пока счетчик WaitGroup не станет равным 0
//                 close(urlCh) // Закрытие канала с URL-адресами после завершения всех горутин
//                 close(errCh) // Закрытие канала с ошибками после завершения всех горутин
//         }()

//         // Сбор URL-адресов объектов и ошибок из каналов.
//         var urls []string
//     for i := 0; i &lt; len(objectIDs); i++ {
//         select {
//         case url := &lt;-urlCh:
//             urls = append(urls, url)
//         case err := &lt;-errCh:
//             m.log.WithFields(logFields).WithError(err.Error).Error("error occurred while getting URLs")
//             return urls, err.Error // Возвращаем то, что успели собрать + ошибку
//         }
//     }

//         m.log.WithFields(logFields).Info("successfully retrieved all file URLs")
//         return urls, nil
// }

// DeleteOne удаляет один объект из бакета Minio по его идентификатору.
// func (m *minioProvider) DeleteOne(ctx context.Context, objectID string) error {
//         logFields := logrus.Fields{
//                 "object_id": objectID,
//         }

//         m.log.WithFields(logFields).Debug("attempting to delete file from MinIO")

//         // Удаление объекта из бакета Minio.
//         if err := m.mc.RemoveObject(ctx, m.config.BucketName, objectID, minio.RemoveObjectOptions{}); err != nil {
//                 err = fmt.Errorf("failed to delete object %s: %w", objectID, err)
//                 m.log.WithFields(logFields).WithError(err).Error("failed to delete file")
//                 return err
//         }

//         m.log.WithFields(logFields).Info("successfully deleted file")
//         return nil
// }

// // DeleteMany удаляет несколько объектов из бакета Minio по их идентификаторам с использованием горутин.
// func (m *minioProvider) DeleteMany(ctx context.Context, objectIDs []string) error {
//     logFields := logrus.Fields{
//         "total_objects": len(objectIDs),
//     }

//     m.log.WithFields(logFields).Debug("attempting to delete multiple objects from MinIO")

//     ctx, cancel := context.WithCancel(ctx)
//     defer cancel()

//     errCh := make(chan error, 1) // Только первая ошибка
//     var wg sync.WaitGroup

//     for _, objectID := range objectIDs {
//         wg.Add(1)
//         go func(id string) {
//             defer wg.Done()

//             select {
//             case &lt;-ctx.Done():
//                 return
//             default:
//             }

//             // Используем DeleteOne вместо прямого вызова RemoveObject
//             if err := m.DeleteOne(ctx, id); err != nil {
//                 select {
//                 case errCh &lt;- fmt.Errorf("failed to delete object %s: %w", id, err):
//                     cancel()
//                 default:
//                 }
//             }
//         }(objectID)
//     }

//     go func() {
//         wg.Wait()
//         close(errCh)
//     }()

//     select {
//     case err := &lt;-errCh:
//         m.log.WithFields(logFields).WithError(err).Error("errors occurred while deleting objects")
//         return err
//     default:
//         m.log.WithFields(logFields).Info("all objects successfully deleted")
//         return nil
//     }
// }

type FileData struct {
        Name string
        Data []byte
}

type OperationError struct {
        ObjectID string
        Error    error
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package address

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryCheckAddressExists = `
        SELECT id FROM bazaar.address
        WHERE address_string = $1 AND coordinate = $2
        LIMIT 1
    `
        queryUpsertAddress = `
        INSERT INTO bazaar.address (id, region, city, address_string, coordinate) 
        VALUES ($1, $2, $3, $4, $5)
    `
        queryUpsertUserAddress = `
        INSERT INTO bazaar.user_address (id, label, user_id, address_id)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (user_id, address_id) DO NOTHING
    `
        queryGetAddressesByUserID = `
                SELECT a.id, ua.label, a.region, a.city, a.address_string, a.coordinate
                FROM bazaar.address AS a
                JOIN bazaar.user_address AS ua ON a.id = ua.address_id
                WHERE ua.user_id = $1
        `
        queryGetAllPickupPoints = `
                SELECT a.id, a.region, a.city, a.address_string, a.coordinate
                FROM bazaar.pickup_point AS pp
                JOIN bazaar.address AS a ON pp.address_id = a.id
        `
)

//go:generate mockgen -source=address.go -destination=../mocks/address_repository_mock.go -package=mocks IAddressRepository
type IAddressRepository interface {
        CheckAddressExists(context.Context, models.AddressDB) (uuid.UUID, error)
        CreateAddress(context.Context, models.AddressDB) error
        CreateUserAddress(context.Context, models.UserAddress) error
        GetUserAddress(context.Context, uuid.UUID) (*[]dto.AddressDTO, error)
        GetAllPickupPoints(ctx context.Context) (*[]models.AddressDB, error)
}

type AddressRepository struct {
        db  *sql.DB
}

func NewAddressRepository(db *sql.DB) *AddressRepository <span class="cov8" title="1">{
        return &amp;AddressRepository{
                db:  db,
        }
}</span>

func (r *AddressRepository) CheckAddressExists(ctx context.Context, address models.AddressDB) (uuid.UUID, error) <span class="cov8" title="1">{
        const op = "AddressRepository.CheckAddressExists"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("address", address)
        
        var id uuid.UUID
        err := r.db.QueryRowContext(ctx, queryCheckAddressExists,
                address.AddressString, address.Coordinate,
        ).Scan(&amp;id)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Debug("address not found")
                        return uuid.Nil, nil
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("check address exists")
                return uuid.Nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return id, nil</span>
}

func (r *AddressRepository) CreateAddress(ctx context.Context, in models.AddressDB) error <span class="cov8" title="1">{
        const op = "AddressRepository.CreateAddress"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("address", in)

        _, err := r.db.QueryContext(ctx, queryUpsertAddress,
                in.ID.String(),
                in.Region,
                in.City,
                in.AddressString,
                in.Coordinate,
        )

        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("create address")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *AddressRepository) CreateUserAddress(ctx context.Context, in models.UserAddress) error <span class="cov8" title="1">{
        const op = "AddressRepository.CreateUserAddress"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_address", in)

        if _, err := r.db.ExecContext(ctx, queryUpsertUserAddress,
                in.ID.String(),
                in.Label,
                in.UserID.String(),
                in.AddressID.String(),
        ); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("create user address")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *AddressRepository) GetUserAddress(ctx context.Context, userID uuid.UUID) (*[]dto.AddressDTO, error) <span class="cov8" title="1">{
        const op = "AddressRepository.GetUserAddress"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        rows, err := r.db.QueryContext(ctx, queryGetAddressesByUserID, userID.String())
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Warn("no addresses found for user")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("query user addresses")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov8" title="1">defer rows.Close()

        var addresses []dto.AddressDTO

        for rows.Next() </span><span class="cov8" title="1">{
                var address dto.AddressDTO
                if err := rows.Scan(
                        &amp;address.ID,
                        &amp;address.Label,
                        &amp;address.Region,
                        &amp;address.City,
                        &amp;address.AddressString,
                        &amp;address.Coordinate,
                ); err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan address row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">addresses = append(addresses, address)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;addresses, nil</span>
}

func (r *AddressRepository) GetAllPickupPoints(ctx context.Context) (*[]models.AddressDB, error) <span class="cov8" title="1">{
        const op = "AddressRepository.GetAllPickupPoints"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetAllPickupPoints)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Warn("no pickup points found")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("query pickup points")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov8" title="1">defer rows.Close()

        var points []models.AddressDB

        for rows.Next() </span><span class="cov8" title="1">{
                var addr models.AddressDB
                if err := rows.Scan(
                        &amp;addr.ID,
                        &amp;addr.Region,
                        &amp;addr.City,
                        &amp;addr.AddressString,
                        &amp;addr.Coordinate,
                ); err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan pickup point row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">points = append(points, addr)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return &amp;points, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryGetPendingProducts = `
                SELECT 
                        p.id, 
                        p.seller_id, 
                        p.name, 
                        p.preview_image_url, 
                        p.description, 
                        p.status, 
                        p.price, 
                        p.quantity, 
                        p.updated_at, 
                        p.rating, 
                        p.reviews_count,
                        d.discounted_price,
                        s.id,
                        s.title,
                        s.description
                FROM 
                        bazaar.product p
                LEFT JOIN 
                        bazaar.discount d ON p.id = d.product_id
                LEFT JOIN
                        bazaar.seller s ON s.user_id = p.seller_id
                WHERE 
                        p.status = 'pending'
                LIMIT 20 OFFSET $1`

        queryUpdateStatusProduct = `
                UPDATE bazaar.product
                SET 
                        status = $1,
                        updated_at = now()
                WHERE 
                        id = $2`

        queryGetPendingUsers = `
        SELECT 
                u.id,
                u.email,
                u.name,
                u.surname,
                u.image_url,
                u.phone_number,
                u.role,
                s.id,
                s.title,
                s.description
        FROM 
                bazaar."user" u
        LEFT JOIN 
                bazaar.seller s ON u.id = s.user_id
        WHERE 
                u.role = 'pending'
        LIMIT 20 OFFSET $1`

        queryUpdateRoleUser = `
                UPDATE bazaar."user"
                SET 
                        role = $1
                WHERE 
                        id = $2`
)

type AdminRepository struct {
        db *sql.DB
}

func NewAdminRepository(db *sql.DB) *AdminRepository <span class="cov8" title="1">{
        return &amp;AdminRepository{db: db}
}</span>

// GetPendingProducts возвращает список товаров со статусом "pending" с пагинацией
func (r *AdminRepository) GetPendingProducts(ctx context.Context, offset int) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "AdminRepository.GetPendingProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        products := make([]*models.Product, 0)

        rows, err := r.db.QueryContext(ctx, queryGetPendingProducts, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to query pending products")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var product models.Product
                var seller models.Seller
                var sellerID uuid.NullUUID
                var priceDiscount sql.NullFloat64
                err := rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                        &amp;priceDiscount,
                        &amp;sellerID,
                        &amp;seller.Title,
                        &amp;seller.Description,
                )
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">if sellerID.Valid </span><span class="cov8" title="1">{
                        seller.ID = sellerID.UUID
                        product.Seller = &amp;seller
                }</span>
                <span class="cov8" title="1">product.PriceDiscount = priceDiscount.Float64
                products = append(products, &amp;product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}

// UpdateProductStatus обновляет статус товара и возвращает обновленный товар
func (r *AdminRepository) UpdateProductStatus(ctx context.Context, productID uuid.UUID, status models.ProductStatus) error <span class="cov8" title="1">{
        const op = "AdminRepository.UpdateProductStatus"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", productID)

        _, err := r.db.ExecContext(ctx, queryUpdateStatusProduct, status.String(), productID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update product status")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetPendingUsers возвращает список пользователей с ролью "pending" с пагинацией
func (r *AdminRepository) GetPendingUsers(ctx context.Context, offset int) ([]*models.User, error) <span class="cov8" title="1">{
        const op = "AdminRepository.GetPendingUsers"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        users := make([]*models.User, 0)

        rows, err := r.db.QueryContext(ctx, queryGetPendingUsers, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to query pending users")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var user models.User
                var seller models.Seller
                var sellerID uuid.NullUUID

                err := rows.Scan(
                        &amp;user.ID,
                        &amp;user.Email,
                        &amp;user.Name,
                        &amp;user.Surname,
                        &amp;user.ImageURL,
                        &amp;user.PhoneNumber,
                        &amp;user.Role,
                        &amp;sellerID,
                        &amp;seller.Title,
                        &amp;seller.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to scan user row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">if sellerID.Valid </span><span class="cov8" title="1">{
                        seller.ID = sellerID.UUID
                        user.Seller = &amp;seller
                }</span>

                <span class="cov8" title="1">users = append(users, &amp;user)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}

// UpdateUserRole обновляет роль пользователя и возвращает обновленного пользователя
func (r *AdminRepository) UpdateUserRole(ctx context.Context, userID uuid.UUID, role models.UserRole) error <span class="cov8" title="1">{
        const op = "AdminRepository.UpdateUserRole"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        _, err := r.db.ExecContext(ctx, queryUpdateRoleUser, role, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update user role")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryCreateUser = `
                INSERT INTO bazaar.user (id, email, name, surname, password_hash, image_url, role) 
                VALUES($1, $2, $3, $4, $5, $6, $7);
        `

        queryGetUserByEmail = `
                SELECT id, email, name, surname, password_hash, image_url, role
                FROM bazaar.user 
                WHERE email = $1;
        `

        queryGetUserByID = `
                SELECT id, email, name, surname, password_hash, image_url, phone_number, role
                FROM bazaar.user 
                WHERE id = $1;
        `

        queryCheckUserExists = `
                SELECT EXISTS(SELECT 1 FROM bazaar.user WHERE email = $1);
        `

        queryCreateBasket = `
                INSERT INTO bazaar.basket (id, user_id, total_price, total_price_discount)
                SELECT $1, $2, 0, 0;
        `
)

type AuthRepository struct {
        db *sql.DB
}

func NewAuthRepository(db *sql.DB) *AuthRepository <span class="cov8" title="1">{
        return &amp;AuthRepository{db: db}
}</span>

func (r *AuthRepository) CreateUser(ctx context.Context, user models.UserDB) error <span class="cov8" title="1">{
        const op = "AuthRepository.CreateUser"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("begin transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">user.Role = models.RoleBuyer
        _, err = tx.ExecContext(ctx, queryCreateUser,
                user.ID, user.Email, user.Name, user.Surname, user.PasswordHash, user.ImageURL, user.Role,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("create user")
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">basketID := uuid.New()
        _, err = tx.ExecContext(ctx, queryCreateBasket, basketID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create basket")
                tx.Rollback()
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("commit transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *AuthRepository) GetUserByEmail(ctx context.Context, email string) (*models.UserDB, error) <span class="cov8" title="1">{
        const op = "AuthRepository.GetUserByEmail"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var user models.UserDB

        err := r.db.QueryRowContext(ctx, queryGetUserByEmail, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.Role,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Warn("user not found by email")
                        return nil, errs.ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">logger.WithError(err).Error("get user by email")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *AuthRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*models.UserDB, error) <span class="cov8" title="1">{
        const op = "AuthRepository.GetUserByID"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var user models.UserDB

        err := r.db.QueryRowContext(ctx, queryGetUserByID, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.PhoneNumber,
                &amp;user.Role,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.Warn("user not found by ID")
                        return nil, errs.ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">logger.WithError(err).Error("get user by ID")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *AuthRepository) CheckUserExists(ctx context.Context, email string) (bool, error) <span class="cov8" title="1">{
        const op = "AuthRepository.CheckUserExists"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var exists bool

        if err := r.db.QueryRowContext(ctx, queryCheckUserExists, email).Scan(&amp;exists); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to check user existence")
                return false, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package basket

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const(
        queryGetBasketByUserID = `SELECT id FROM bazaar.basket WHERE user_id = $1 LIMIT 1`

        queryGetInfoBasket = `
                SELECT id, user_id, total_price, total_price_discount 
                        FROM bazaar.basket WHERE id = $1
        `

        queryAddProductInBasket = `
                INSERT INTO bazaar.basket_item (id, basket_id, product_id, quantity)
                        VALUES ($1, $2, $3, 1)
                        ON CONFLICT (basket_id, product_id) 
                        DO UPDATE SET 
                                quantity = basket_item.quantity + 1
                        RETURNING id, basket_id, product_id, quantity, updated_at
        `

        queryGetProductsInBasket = `
                SELECT 
                        bi.id, 
                        bi.basket_id, 
                        bi.product_id, 
                        bi.quantity AS basket_quantity, 
                        bi.updated_at,
                        p.name,
                        p.price,
                        p.preview_image_url,
                        d.discounted_price,
                        p.quantity AS available_quantity
                FROM 
                        bazaar.basket_item bi
                JOIN 
                        bazaar.product p ON bi.product_id = p.id
                LEFT JOIN LATERAL (
                        SELECT 
                                discounted_price
                        FROM 
                                bazaar.discount
                        WHERE 
                                product_id = bi.product_id
                                AND now() BETWEEN start_date AND end_date
                        ORDER BY 
                                start_date DESC
                        LIMIT 1
                ) d ON true
                WHERE 
                        bi.basket_id = $1
                        AND p.status = 'approved'
    `

        queryDelProductFromBasket = `
                DELETE FROM bazaar.basket_item
                WHERE basket_id = $1 AND product_id = $2
                RETURNING id
        `

        queryUpdateProductQuantity = `
                UPDATE bazaar.basket_item
                SET quantity = $1
                WHERE basket_id = $2 AND product_id = $3
                RETURNING id, basket_id, product_id, quantity, updated_at
        `

        queryGetQuantityProduct = `SELECT quantity FROM bazaar.product WHERE id = $1`

        queryClearBasket = `
                DELETE FROM bazaar.basket_item
                WHERE basket_id = $1
        `
)

type BasketRepository struct{
        DB  *sql.DB
}

func NewBasketRepository(db *sql.DB) *BasketRepository <span class="cov8" title="1">{
        return &amp;BasketRepository{
                DB:  db,
        }
}</span>

func (r *BasketRepository) getBasket(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) <span class="cov8" title="1">{
        const op = "BasketRepository.getBasket"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)
        
        var basketID uuid.UUID

        err := r.DB.QueryRowContext(ctx, queryGetBasketByUserID, userID).Scan(&amp;basketID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("basket not found")
            return uuid.Nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("get basket")
        return uuid.Nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return basketID, nil</span>
}

func (r*BasketRepository) getQuantityProduct(ctx context.Context, productID uuid.UUID) (uint, error) <span class="cov8" title="1">{
        const op = "BasketRepository.getQuantityProduct"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", productID)

        var quantity uint

        err := r.DB.QueryRowContext(ctx, queryGetQuantityProduct, productID).Scan(&amp;quantity)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("basket not found")
            return 0, errs.NewNotFoundError(op)
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("get basket")
        return 0, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return quantity, nil</span>
}

func (r *BasketRepository) Get(ctx context.Context, userID uuid.UUID) ([]*models.BasketItem, error) <span class="cov8" title="1">{
        const op = "BasketRepository.Get"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">productsList := []*models.BasketItem{}

        rows, err := r.DB.QueryContext(ctx, queryGetProductsInBasket, basketID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
            logger.Warn("no products in basket")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("query basket products")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                item := &amp;models.BasketItem{}
                var priceDiscount sql.NullFloat64
                var quantity int
                err = rows.Scan(
                        &amp;item.ID,
                        &amp;item.BasketID,
                        &amp;item.ProductID,
                        &amp;item.Quantity,
                        &amp;item.UpdatedAt,
                        &amp;item.ProductName,
                        &amp;item.Price,
                        &amp;item.ProductImage,
                        &amp;priceDiscount,
                        &amp;quantity,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan basket item")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov0" title="0">item.PriceDiscount = priceDiscount.Float64
                item.QuantityRemain = quantity - item.Quantity
                productsList = append(productsList, item)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov0" title="0">return productsList, nil</span>
}

func (r *BasketRepository) Add(ctx context.Context, userID uuid.UUID, productID uuid.UUID) (*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketRepository.Add"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID)

        basketID, err := r.getBasket(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">item := &amp;models.BasketItem{}
        newItemID := uuid.New()

        err = r.DB.QueryRowContext(ctx, queryAddProductInBasket, newItemID, basketID, productID).Scan(
                &amp;item.ID,
                &amp;item.BasketID,
                &amp;item.ProductID,
                &amp;item.Quantity,
                &amp;item.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("add product to basket - not found")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("add product to basket")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return item, nil</span>
}

func (r *BasketRepository) Delete(ctx context.Context, userID uuid.UUID, productID uuid.UUID) error <span class="cov8" title="1">{
        const op = "BasketRepository.Delete"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">var deletedID uuid.UUID
        err = r.DB.QueryRowContext(ctx, queryDelProductFromBasket, basketID, productID).Scan(&amp;deletedID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("product not found in basket")
            return fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("delete product from basket")
        return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *BasketRepository) UpdateQuantity(ctx context.Context, userID uuid.UUID, productID uuid.UUID, quantity int) (*models.BasketItem, error) <span class="cov8" title="1">{
        const op = "BasketRepository.UpdateQuantity"
    logger := logctx.GetLogger(ctx).WithField("op", op).
        WithField("user_id", userID).
        WithField("product_id", productID).
        WithField("quantity", quantity)

        quantityProduct, err := r.getQuantityProduct(ctx, productID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if uint(quantity) &gt; quantityProduct </span><span class="cov8" title="1">{
        logger.Warn("requested quantity exceeds available")
        return nil, errs.NewBusinessLogicError("requested quantity exceeds available stock")
    }</span>

        <span class="cov8" title="1">basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("failed to get basket ID")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">item := &amp;models.BasketItem{}
        err = r.DB.QueryRowContext(ctx, queryUpdateProductQuantity, quantity, basketID, productID).Scan(
                &amp;item.ID,
                &amp;item.BasketID,
                &amp;item.ProductID,
                &amp;item.Quantity,
                &amp;item.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
            logger.Warn("product not found in basket")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov0" title="0">logger.WithError(err).Error("update product quantity")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">item.QuantityRemain = int(quantityProduct)-quantity

        return item, nil</span>
}

func (r *BasketRepository) Clear(ctx context.Context, userID uuid.UUID) error <span class="cov8" title="1">{
        const op = "BasketRepository.Clear"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        basketID, err := r.getBasket(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket ID")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">_, err = r.DB.ExecContext(ctx, queryClearBasket, basketID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("clear basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package category

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryGetAllCategories = `
                        SELECT id, name FROM bazaar.category
        `

        queryGetAllSubcategories = `
                SELECT id, name 
                FROM bazaar.subcategory
                WHERE category_id = $1
        `

        queryGetNameSybcategory = `
                SELECT name
                FROM bazaar.subcategory
                WHERE id = $1
        `
)

type CategoryRepository struct {
        DB  *sql.DB
}

func NewCategoryRepository(db *sql.DB) *CategoryRepository <span class="cov8" title="1">{
        return &amp;CategoryRepository{
                DB:  db,
        }
}</span>

func (p *CategoryRepository) GetAllCategories(ctx context.Context) ([]*models.Category, error) <span class="cov8" title="1">{
        const op = "CategoryRepository.GetAllCategories"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        categoriesList := []*models.Category{}

        rows, err := p.DB.QueryContext(ctx, queryGetAllCategories)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all categories")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                category := &amp;models.Category{}
                err = rows.Scan(
                        &amp;category.ID,
                        &amp;category.Name,
                )
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan category row")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">categoriesList = append(categoriesList, category)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return categoriesList, nil</span>
}

func (p *CategoryRepository) GetAllSubcategories(ctx context.Context, category_id uuid.UUID) ([]*models.Category, error) <span class="cov8" title="1">{
        const op = "CategoryRepository.GetAllSubcategories"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        subcategoriesList := []*models.Category{}

        rows, err := p.DB.QueryContext(ctx, queryGetAllSubcategories, category_id)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query subcategories")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                category := &amp;models.Category{}
                err = rows.Scan(
                        &amp;category.ID,
                        &amp;category.Name,
                )
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan subcategory row")
            return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">subcategoriesList = append(subcategoriesList, category)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return subcategoriesList, nil</span>
}

func (p *CategoryRepository) GetNameSubcategory(ctx context.Context, id uuid.UUID) (string, error) <span class="cov8" title="1">{
        const op = "CategoryRepository.GetNameSubcategory"
    logger := logctx.GetLogger(ctx).WithField("op", op)
        
        var name string
        err := p.DB.QueryRowContext(ctx, queryGetNameSybcategory, id).Scan(&amp;name)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("product not found by ID")
            return "", fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("failed to get product by ID")
        return "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return name, nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package csat

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryGetSurvey = `SELECT
                s.id AS survey_id,
                s.title AS survey_title,
                s.description AS survey_description,
                q.id AS question_id,
                q.position AS question_position,
                q.text AS question_text
                FROM bazaar.topic t
                JOIN bazaar.survey s ON s.topic_id = t.id
                JOIN bazaar.question q ON q.survey_id = s.id
                WHERE t.name = $1
                ORDER BY q.position;`
        insertAnswerQuery = `
                INSERT INTO bazaar.answer (id, submission_id, question_id, value)
                VALUES ($1, $2, $3, $4);`
        insertSubmissionQuery = `
                INSERT INTO bazaar.submission (id, user_id, survey_id)
                VALUES ($1, $2, $3);`
        queryGetStatistics = `
                SELECT
                        s.description AS survey_description,
                        q.id AS question_id,
                        q.text AS question_text,
                        a.value AS answer_value
                FROM bazaar.question q
                JOIN bazaar.survey s ON q.survey_id = s.id
                LEFT JOIN bazaar.answer a ON a.question_id = q.id
                WHERE q.survey_id = $1
                ORDER BY q.position;`

        queryGetAllSurvey = `
                SELECT s.id, s.title FROM bazaar.survey s
        `
)

type SurveyRepository struct {
        db *sql.DB
}

func NewSurveyRepository(db *sql.DB) *SurveyRepository <span class="cov8" title="1">{
        return &amp;SurveyRepository{
                db: db,
        }
}</span>

func (r *SurveyRepository) GetSurvey(ctx context.Context, topicName string) (*models.SurveyWithQuestions, error) <span class="cov8" title="1">{
        const op = "SurveyRepository.GetSurvey"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetSurvey, topicName)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to query survey")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        survey := &amp;models.SurveyWithQuestions{}
        survey.Questions = make([]models.Question, 0)

        first := true

        for rows.Next() </span><span class="cov8" title="1">{
                surveyData := &amp;models.SurveyQuestionData{}

                if err = rows.Scan(
                        &amp;surveyData.SurveyID,
                        &amp;surveyData.SurveyTitle,
                        &amp;surveyData.SurveyDescription,
                        &amp;surveyData.QuestionID,
                        &amp;surveyData.QuestionPosition,
                        &amp;surveyData.QuestionText,
                ); err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to scan survey data")
                        return nil, fmt.Errorf("scan survey: %w", err)
                }</span>

                <span class="cov8" title="1">if first </span><span class="cov8" title="1">{
                        survey.ID = surveyData.SurveyID
                        survey.Title = surveyData.SurveyTitle
                        survey.Description = surveyData.SurveyDescription
                        first = false
                }</span>

                <span class="cov8" title="1">survey.Questions = append(survey.Questions, models.Question{
                        ID:       surveyData.QuestionID,
                        Position: surveyData.QuestionPosition,
                        Text:     surveyData.QuestionText,
                })</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("rows error: %w", err)
        }</span>

        <span class="cov8" title="1">if len(survey.Questions) == 0 </span><span class="cov8" title="1">{
                logger.Warn("no questions found for survey")
                return nil, errs.NewNotFoundError("survey not found for topic")
        }</span>

        <span class="cov8" title="1">return survey, nil</span>
}

func (r *SurveyRepository) AddSurveySubmission(ctx context.Context, surveyID uuid.UUID, answers []models.Answer, userID uuid.UUID) error <span class="cov8" title="1">{
        const op = "SurveyRepository.AddSurveySubmission"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to begin transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        fmt.Errorf("failed rollback")
                }</span>
        }()

        <span class="cov8" title="1">submissionID := uuid.New()

        _, err = tx.ExecContext(ctx, insertSubmissionQuery, submissionID, userID, surveyID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to insert submission")
                tx.Rollback()
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">stmt, err := tx.PrepareContext(ctx, insertAnswerQuery)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to prepare insert answer statement")
                tx.Rollback()
                return fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()

        for _, ans := range answers </span><span class="cov8" title="1">{
                answerID := uuid.New()
                _, err = stmt.ExecContext(ctx, answerID, submissionID, ans.QuestionID, ans.Value)
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to insert answer")
                        tx.Rollback()
                        return fmt.Errorf("%s: %w", op, err)
                }</span>
        }

        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to commit transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *SurveyRepository) GetStatistics(ctx context.Context, surveyID uuid.UUID) (*models.GetStatisticsResponse, error) <span class="cov8" title="1">{
        const op = "SurveyRepository.GetStatistics"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetStatistics, surveyID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to query statistics")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        questionMap := make(map[uuid.UUID]*models.QuestionStatistics)
        var surveyDescription string
        surveyDescriptionSet := false

        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        description  string
                        questionID   uuid.UUID
                        questionText string
                        answerValue  sql.NullInt64
                )

                if err := rows.Scan(&amp;description, &amp;questionID, &amp;questionText, &amp;answerValue); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to scan statistics data")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov8" title="1">if !surveyDescriptionSet </span><span class="cov8" title="1">{
                        surveyDescription = description
                        surveyDescriptionSet = true
                }</span>

                <span class="cov8" title="1">question, ok := questionMap[questionID]
                if !ok </span><span class="cov8" title="1">{
                        question = &amp;models.QuestionStatistics{
                                ID:      questionID,
                                Text:    questionText,
                                Answers: make([]uint32, 0),
                        }
                        questionMap[questionID] = question
                }</span>

                <span class="cov8" title="1">if answerValue.Valid </span><span class="cov8" title="1">{
                        question.Answers = append(question.Answers, uint32(answerValue.Int64))
                }</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">var response models.GetStatisticsResponse
        response.Description = surveyDescription
        response.Questions = make([]models.QuestionStatistics, 0, len(questionMap))
        for _, question := range questionMap </span><span class="cov8" title="1">{
                response.Questions = append(response.Questions, *question)
        }</span>

        <span class="cov8" title="1">return &amp;response, nil</span>
  }

func (r *SurveyRepository) GetAllSurvey(ctx context.Context) ([]models.Survey, error) <span class="cov8" title="1">{
        const op = "SurveyRepository.GetAllSurvey"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetAllSurvey)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("failed to query surveys")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()

        surveys := make([]models.Survey, 0)

        for rows.Next() </span><span class="cov8" title="1">{
        var survey models.Survey
        if err := rows.Scan(
            &amp;survey.ID,
            &amp;survey.Title,
        ); err != nil </span><span class="cov8" title="1">{
            logger.WithError(err).Error("failed to scan survey data")
            return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">surveys = append(surveys, survey)</span>
    }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">if len(surveys) == 0 </span><span class="cov8" title="1">{
        logger.Info("no surveys found")
        return []models.Survey{}, nil
    }</span>

    <span class="cov8" title="1">return surveys, nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package postgres

import (
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
)

func GetConnectionString(conf *config.DBConfig) (string, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable",
                conf.User, conf.Password, conf.Host, conf.Port, conf.DB,
        )

        return connStr, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package order

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/google/uuid"
)

const (
        queryCreateOrder           = `INSERT INTO bazaar.order (id, user_id, status, total_price, total_price_discount, address_id) VALUES ($1, $2, $3, $4, $5, $6)`
        queryAddOrderItem          = `INSERT INTO bazaar.order_item (id, order_id, product_id, price, quantity) VALUES ($1, $2, $3, $4, $5)`
        queryGetProductPrice       = `SELECT price, status, quantity FROM bazaar.product WHERE id = $1 LIMIT 1`
        queryGetProductDiscount    = `SELECT discounted_price, start_date, end_date FROM bazaar.discount WHERE product_id = $1`
        queryUpdateProductQuantity = `UPDATE bazaar.product SET quantity = $1 WHERE id = $2`
        queryGetOrdersByUserID     = `SELECT id, status, total_price, total_price_discount, address_id, expected_delivery_at, actual_delivery_at, created_at FROM bazaar.order WHERE user_id = $1`
        queryGetOrderProducts      = `SELECT product_id, quantity FROM bazaar.order_item WHERE order_id = $1`
        queryGetProductImg         = `SELECT preview_image_url FROM bazaar.product WHERE id = $1 LIMIT 1`
        queryGetOrderAddress       = `
        SELECT 
            a.region, 
            a.city, 
            a.address_string, 
            a.coordinate,
            ua.label
        FROM 
            bazaar.address a
        LEFT JOIN 
            bazaar.user_address ua ON a.id = ua.address_id
        WHERE 
            a.id = $1 
        LIMIT 1`
)

//go:generate mockgen -source=order.go -destination=../mocks/order_repository_mock.go -package=mocks IOrderRepository
type IOrderRepository interface {
        CreateOrder(context.Context, dto.CreateOrderRepoReq) error
        ProductPrice(context.Context, uuid.UUID) (*models.Product, error)
        ProductDiscounts(context.Context, uuid.UUID) ([]models.ProductDiscount, error)
        UpdateProductQuantity(context.Context, uuid.UUID, uint) error
        GetOrdersByUserID(context.Context, uuid.UUID) (*[]dto.GetOrderByUserIDResDTO, error)
        GetOrderProducts(context.Context, uuid.UUID) (*[]dto.GetOrderProductResDTO, error)
        GetProductImage(context.Context, uuid.UUID) (string, error)
        GetOrderAddress(context.Context, uuid.UUID) (*models.AddressDB, error)
}

type OrderRepository struct {
        db *sql.DB
}

func NewOrderRepository(db *sql.DB) *OrderRepository <span class="cov8" title="1">{
        return &amp;OrderRepository{
                db: db,
        }
}</span>

func (r *OrderRepository) CreateOrder(ctx context.Context, in dto.CreateOrderRepoReq) error <span class="cov8" title="1">{
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s", err)
        }</span>

        <span class="cov8" title="1">if _, err = tx.ExecContext(ctx, queryCreateOrder,
                in.Order.ID,
                in.Order.UserID,
                in.Order.Status.String(),
                in.Order.TotalPrice,
                in.Order.TotalPriceDiscount,
                in.Order.AddressID,
        ); err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return fmt.Errorf("%s", err)
        }</span>

        <span class="cov8" title="1">for productID, updatedQuantity := range in.UpdatedQuantities </span><span class="cov8" title="1">{
                if err = r.UpdateProductQuantity(ctx, productID, updatedQuantity); err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                        return fmt.Errorf("%s", err)
                }</span>
        }

        <span class="cov8" title="1">for _, item := range in.Order.Items </span><span class="cov8" title="1">{
                if _, err = tx.ExecContext(ctx, queryAddOrderItem,
                        item.ID, in.Order.ID, item.ProductID, item.Price, item.Quantity,
                ); err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                        return fmt.Errorf("%s", err)
                }</span>
        }

        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *OrderRepository) ProductPrice(ctx context.Context, ProductID uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "OrderRepository.ProductPrice"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var product models.Product
        var productStatusString string

        if err := r.db.QueryRowContext(ctx, queryGetProductPrice, ProductID).Scan(
                &amp;product.Price,
                &amp;productStatusString,
                &amp;product.Quantity,
        ); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errs.NewNotFoundError("product not found")
                }</span>
                <span class="cov8" title="1">logger.WithError(err).WithField("product_id", ProductID).Error("get product price")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">productStatus, err := models.ParseProductStatus(productStatusString)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).WithField("status", productStatusString).Error("parse product status")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">product.Status = productStatus

        return &amp;product, nil</span>
}

func (r *OrderRepository) ProductDiscounts(ctx context.Context, productID uuid.UUID) ([]models.ProductDiscount, error) <span class="cov8" title="1">{
        const op = "OrderRepository.ProductDiscounts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetProductDiscount, productID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("product_id", productID).Error("query product discounts")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var discounts []models.ProductDiscount
        for rows.Next() </span><span class="cov8" title="1">{
                var discount models.ProductDiscount
                if err = rows.Scan(
                        &amp;discount.DiscountedPrice,
                        &amp;discount.DiscountStartDate,
                        &amp;discount.DiscountEndDate,
                ); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan discount row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">discounts = append(discounts, discount)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if len(discounts) == 0 </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("product discounts not found")
        }</span>

        <span class="cov8" title="1">return discounts, nil</span>
}

func (r *OrderRepository) UpdateProductQuantity(ctx context.Context, productID uuid.UUID, quantity uint) error <span class="cov8" title="1">{
        const op = "OrderRepository.UpdateProductQuantity"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        res, err := r.db.ExecContext(ctx, queryUpdateProductQuantity, quantity, productID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).WithField("product_id", productID).Error("update product quantity")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get rows affected")
                return fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return errs.NewNotFoundError("product not found for quantity update")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *OrderRepository) GetOrdersByUserID(ctx context.Context, userID uuid.UUID) (*[]dto.GetOrderByUserIDResDTO, error) <span class="cov8" title="1">{
        rows, err := r.db.QueryContext(ctx, queryGetOrdersByUserID, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var orders []dto.GetOrderByUserIDResDTO
        for rows.Next() </span><span class="cov8" title="1">{
                var order dto.GetOrderByUserIDResDTO
                var status string
                if err = rows.Scan(
                        &amp;order.ID,
                        &amp;status,
                        &amp;order.TotalPrice,
                        &amp;order.TotalPriceDiscount,
                        &amp;order.AddressID,
                        &amp;order.ExpectedDeliveryAt,
                        &amp;order.ActualDeliveryAt,
                        &amp;order.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">orderStatus, err := models.ParseOrderStatus(status)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">order.Status = orderStatus
                orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(orders) == 0 </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("orders not found for user")
        }</span>

        <span class="cov0" title="0">return &amp;orders, nil</span>
}

func (r *OrderRepository) GetOrderProducts(ctx context.Context, productID uuid.UUID) (*[]dto.GetOrderProductResDTO, error) <span class="cov8" title="1">{
        rows, err := r.db.QueryContext(ctx, queryGetOrderProducts, productID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var result []dto.GetOrderProductResDTO
        for rows.Next() </span><span class="cov8" title="1">{
                var response dto.GetOrderProductResDTO
                if err = rows.Scan(
                        &amp;response.ProductID,
                        &amp;response.Quantity,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, response)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("order products not found")
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (r *OrderRepository) GetProductImage(ctx context.Context, productID uuid.UUID) (string, error) <span class="cov8" title="1">{
        var imageURL string

        if err := r.db.QueryRowContext(ctx, queryGetProductImg, productID).Scan(
                &amp;imageURL,
        ); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return "", errs.NewNotFoundError("product image not found")
                }</span>
                <span class="cov8" title="1">return "", err</span>
        }

        <span class="cov8" title="1">return imageURL, nil</span>
}

func (r *OrderRepository) GetOrderAddress(ctx context.Context, addressID uuid.UUID) (*models.AddressDB, error) <span class="cov8" title="1">{
        var address models.AddressDB

        if err := r.db.QueryRowContext(ctx, queryGetOrderAddress, addressID).Scan(
                &amp;address.Region,
                &amp;address.City,
                &amp;address.AddressString,
                &amp;address.Coordinate,
                &amp;address.Label,
        ); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errs.NewNotFoundError("order address not found")
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;address, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package product

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

const (
        queryGetAllProducts = `
                SELECT p.id, p.seller_id, p.name, p.preview_image_url, p.description, 
                                p.status, p.price, p.quantity, p.updated_at, p.rating, p.reviews_count,
                                d.discounted_price
                FROM bazaar.product p 
                LEFT JOIN bazaar.discount d ON p.id = d.product_id
                WHERE p.status = 'approved'
        ORDER BY p.id
                LIMIT 20 OFFSET $1
        `
        queryGetProductByID = `
                SELECT p.id, p.seller_id, p.name, p.preview_image_url, p.description, 
                                p.status, p.price, p.quantity, p.updated_at, p.rating, p.reviews_count,
                                d.discounted_price, s.id, s.title, s.description
                FROM bazaar.product p
                LEFT JOIN bazaar.discount d ON p.id = d.product_id
        LEFT JOIN bazaar.seller s ON s.user_id = p.seller_id
                WHERE p.id = $1
        `

        queryGetProductsByCategoryWithFilterAndSort = `
        SELECT 
            p.id, 
            p.seller_id, 
            p.name, 
            p.preview_image_url, 
            p.description, 
            p.status, 
            p.price, 
            p.quantity, 
            p.updated_at, 
            p.rating, 
            p.reviews_count
        FROM 
            bazaar.product p
        JOIN 
            bazaar.product_subcategory pc ON p.id = pc.product_id
        WHERE 
            pc.subcategory_id = $1 
            AND p.status = 'approved'
            AND ($3 = 0 OR p.price &gt; $3)
            AND ($4 = 0 OR p.price &lt; $4)
            AND ($5 = 0::FLOAT OR p.rating &gt; $5::FLOAT)
        ORDER BY %s
        LIMIT 20 OFFSET $2
    `

        queryAddProduct = `
                INSERT INTO bazaar.product (
                        id, seller_id, name, preview_image_url, 
                        description, status, price, quantity, rating, reviews_count
                ) VALUES ($1, $2, $3, $4, $5, $10, $6, $7, $8, $9)
                RETURNING id
        `

    queryAddDiscount = `
        INSERT INTO bazaar.discount (
            id, product_id, discounted_price, start_date, end_date
        ) VALUES ($1, $2, $3, now(), now() + interval '30 days')
    `

    queryAddProductCategory = `
        INSERT INTO bazaar.product_subcategory (id, product_id, subcategory_id)
        VALUES ($1, $2, $3)
    `
)

type ProductRepository struct {
        DB  *sql.DB
}

func NewProductRepository(db *sql.DB) *ProductRepository <span class="cov8" title="1">{
        return &amp;ProductRepository{
                DB:  db,
        }
}</span>

// получение основной информации всех товаров
func (p *ProductRepository) GetAllProducts(ctx context.Context, offset int) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetAllProducts"
    logger := logctx.GetLogger(ctx).WithField("op", op)

        productsList := []*models.Product{}

        rows, err := p.DB.QueryContext(ctx, queryGetAllProducts, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all products")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var priceDiscount sql.NullFloat64
                product := &amp;models.Product{}
                err = rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                        &amp;priceDiscount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">product.PriceDiscount = priceDiscount.Float64
                productsList = append(productsList, product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}

// получение товара по id
func (p *ProductRepository) GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetProductByID"
    logger := logctx.GetLogger(ctx).WithField("op", op)
        
        product := &amp;models.Product{}
    var seller models.Seller
    var sellerID uuid.NullUUID
        var priceDiscount sql.NullFloat64
        err := p.DB.QueryRowContext(ctx, queryGetProductByID, id).
                Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                        &amp;priceDiscount,
            &amp;sellerID,
            &amp;seller.Title,
            &amp;seller.Description,
                )

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
            logger.Warn("product not found by ID")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("failed to get product by ID")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
    <span class="cov8" title="1">if sellerID.Valid </span><span class="cov8" title="1">{
        seller.ID = sellerID.UUID
        product.Seller = &amp;seller
    }</span>
        <span class="cov8" title="1">product.PriceDiscount = priceDiscount.Float64

        return product, nil</span>
}

func (p *ProductRepository) GetProductsByCategory(
    ctx context.Context, 
    id uuid.UUID, 
    offset int,
    minPrice, maxPrice float64,
    minRating float32,
    sortOption models.SortOption,
) ([]*models.Product, error) <span class="cov8" title="1">{
    const op = "ProductRepository.GetProductsByCategoryWithFilterAndSort"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    var orderByClause string
    switch sortOption </span>{
    case models.SortByPriceAsc:<span class="cov8" title="1">
        orderByClause = "p.price ASC"</span>
    case models.SortByPriceDesc:<span class="cov0" title="0">
        orderByClause = "p.price DESC"</span>
    case models.SortByRatingAsc:<span class="cov0" title="0">
        orderByClause = "p.rating ASC"</span>
    case models.SortByRatingDesc:<span class="cov0" title="0">
        orderByClause = "p.rating DESC"</span>
    default:<span class="cov8" title="1">
        orderByClause = "p.updated_at DESC"</span> // дефолтная сортировка
    }

    <span class="cov8" title="1">query := fmt.Sprintf(queryGetProductsByCategoryWithFilterAndSort, orderByClause)

    productsList := []*models.Product{}

    rows, err := p.DB.QueryContext(
        ctx,
        query,
        id,
        offset,
        minPrice,
        maxPrice,
        minRating,
    )
    
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("query products by category with filter and sort")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>
    <span class="cov8" title="1">defer rows.Close()

    for rows.Next() </span><span class="cov8" title="1">{
        product := &amp;models.Product{}
        err = rows.Scan(
            &amp;product.ID,
            &amp;product.SellerID,
            &amp;product.Name,
            &amp;product.PreviewImageURL,
            &amp;product.Description,
            &amp;product.Status,
            &amp;product.Price,
            &amp;product.Quantity,
            &amp;product.UpdatedAt,
            &amp;product.Rating,
            &amp;product.ReviewsCount,
        )
        if err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).Error("scan product row")
            return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">productsList = append(productsList, product)</span>
    }

    <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">return productsList, nil</span>
}

func (p *ProductRepository) AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
    const op = "ProductRepository.AddProduct"
    logger := logctx.GetLogger(ctx).WithField("op", op)
    
    tx, err := p.DB.BeginTx(ctx, nil)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("begin transaction")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>
    <span class="cov8" title="1">defer tx.Rollback()

    // Генерируем UUID для продукта
    product.ID = uuid.New()
    
    // Вставляем продукт
        product.Status = models.ProductApproved
    _, err = tx.ExecContext(ctx, queryAddProduct,
        product.ID,
        product.SellerID,
        product.Name,
        product.PreviewImageURL,
        product.Description,
        product.Price,
        product.Quantity,
        product.Rating,
        product.ReviewsCount,
                product.Status,
    )
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("insert product")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    // Генерируем UUID для скидки и добавляем скидку
    <span class="cov8" title="1">discountID := uuid.New()
    _, err = tx.ExecContext(ctx, queryAddDiscount,
        discountID,
        product.ID,
        product.PriceDiscount,
    )
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("insert discount")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>
        <span class="cov8" title="1">productCategoryID := uuid.New()
    // Добавляем категорию продукта
    _, err = tx.ExecContext(ctx, queryAddProductCategory,
                productCategoryID,
        product.ID,
        categoryID,
    )
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("insert product category")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("commit transaction")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">return product, nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package review

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

const (
        queryAddReview = `
                INSERT INTO bazaar.review (id, user_id, product_id, rating, comment)
                        VALUES ($1, $2, $3, $4, $5)
        `

        queryUpdateCount = `
                UPDATE bazaar.product
                SET reviews_count = reviews_count + 1 
                WHERE id = $1
        `

        queryGetReview = `
                SELECT 
                        r.id, u.name, u.surname, u.image_url, r.rating, r.comment
                FROM bazaar.review r
                JOIN bazaar.user u ON r.user_id = u.id
                WHERE r.product_id = $1
                ORDER BY r.created_at DESC
        LIMIT 7 OFFSET $2
        `
)

type ReviewRepository struct {
        DB *sql.DB
}

func NewReviewRepository(db *sql.DB) *ReviewRepository <span class="cov8" title="1">{
        return &amp;ReviewRepository{
                DB:  db,
        }
}</span>

func (r *ReviewRepository) AddReview(ctx context.Context, review models.ReviewDB) error <span class="cov8" title="1">{
        const op = "AddReview.AddReview"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.DB.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("begin transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryUpdateCount, review.ProductID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("increment count")
                tx.Rollback()
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryAddReview,
                review.ID,
                review.UserID,
                review.ProductID,
                review.Rating,
                review.Comment,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("add review")
                tx.Rollback()
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("commit transaction")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ReviewRepository) GetReview(ctx context.Context, productID uuid.UUID, offset int) ([]*models.Review, error) <span class="cov8" title="1">{
        const op = "ReviewRepository.GetReview"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("productID", productID)

        reviewList := []*models.Review{}

        rows, err := r.DB.QueryContext(ctx, queryGetReview, productID, offset)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
            logger.Warn("no reviews on this product")
            return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
        }</span>
        <span class="cov8" title="1">logger.WithError(err).Error("query reviews")
        return nil, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                review := &amp;models.Review{}
                err = rows.Scan(
                        &amp;review.ID,
                        &amp;review.Name,
                        &amp;review.Surname,
                        &amp;review.ImageURL,
                        &amp;review.Rating,
                        &amp;review.Comment,
                )
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan review")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">reviewList = append(reviewList, review)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("rows iteration error")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return reviewList, nil</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package search

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/guregu/null"
)

const (
        queryGetCategoryByName = `
        SELECT id, name FROM bazaar.subcategory
        WHERE LOWER(name) = LOWER($1)`
        querySearchProductsByNameWithFilterAndSort = `
SELECT p.id, p.seller_id, p.name, p.preview_image_url, p.description, 
       p.status, p.price, p.quantity, p.updated_at, p.rating, p.reviews_count,
       d.discounted_price
FROM bazaar.product p
JOIN bazaar.product_subcategory ps ON p.id = ps.product_id
LEFT JOIN bazaar.discount d ON p.id = d.product_id
WHERE p.status = 'approved'
  AND LOWER(p.name) LIKE LOWER($1)
  AND ($2 = '' OR ps.subcategory_id = $2::uuid)
  AND ($3 = 0 OR p.price &gt;= $3)
  AND ($4 = 0 OR p.price &lt;= $4)
  AND ($5 = 0::FLOAT OR p.rating &gt;= $5::FLOAT)
ORDER BY %s
LIMIT 20 OFFSET $6`
)

type SearchRepository struct {
        db *sql.DB
}

func NewSearchRepository(db *sql.DB) *SearchRepository <span class="cov8" title="1">{
        return &amp;SearchRepository{
                db: db,
        }
}</span>

func (s *SearchRepository) GetCategoryByName(ctx context.Context, name string) (*models.Category, error) <span class="cov8" title="1">{
        const op = "SearchRepository.GetCategoryByName"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var category models.Category

        if err := s.db.QueryRowContext(ctx, queryGetCategoryByName, name).Scan(&amp;category.ID, &amp;category.Name); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("query get category by name")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return &amp;category, nil</span>
}

func (s *SearchRepository) GetProductsByNameWithFilterAndSort(
        ctx context.Context,
        name string,
        categoryID null.String,
        offset int,
        minPrice, maxPrice float64,
        minRating float32,
        sortOption models.SortOption,
) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "SearchRepository.GetProductsByNameWithFilterAndSort"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var orderBy string
        switch sortOption </span>{
        case models.SortByPriceAsc:<span class="cov8" title="1">
                orderBy = "p.price ASC"</span>
        case models.SortByPriceDesc:<span class="cov0" title="0">
                orderBy = "p.price DESC"</span>
        case models.SortByRatingAsc:<span class="cov0" title="0">
                orderBy = "p.rating ASC"</span>
        case models.SortByRatingDesc:<span class="cov0" title="0">
                orderBy = "p.rating DESC"</span>
        default:<span class="cov8" title="1">
                orderBy = "p.updated_at DESC"</span>
        }

        // Формируем запрос
        <span class="cov8" title="1">query := fmt.Sprintf(querySearchProductsByNameWithFilterAndSort, orderBy)

        // Готовим параметры запроса
        args := []interface{}{
                fmt.Sprintf("%%%s%%", name), // $1
        }

        // Добавляем параметры фильтрации по категории, цене и рейтингу
        if categoryID.Valid </span><span class="cov8" title="1">{
                args = append(args, categoryID.String) // $2
        }</span> else<span class="cov8" title="1"> {
                args = append(args, "") // Пустая строка, если категория не задана
        }</span>
        <span class="cov8" title="1">args = append(args, minPrice, maxPrice, minRating, offset)

        // Выполняем запрос
        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query search products with filter and sort")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        // Чтение данных
        productsList := []*models.Product{}
        for rows.Next() </span><span class="cov8" title="1">{
                var priceDiscount sql.NullFloat64
                product := &amp;models.Product{}
                if err := rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.UpdatedAt,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                        &amp;priceDiscount,
                ); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">product.PriceDiscount = priceDiscount.Float64
                productsList = append(productsList, product)</span>
        }

        // Проверка ошибок
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package seller

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

const (
        queryAddProduct = `
                INSERT INTO bazaar.product (
                        id, seller_id, name, 
                        description, status, price, quantity, rating, reviews_count
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, 0, 0)
                RETURNING id
        `

        queryAddProductCategory = `
                INSERT INTO bazaar.product_subcategory (id, product_id, subcategory_id)
                VALUES ($1, $2, $3)
        `

        queryGetSellerProducts = `
                SELECT id, seller_id, name, preview_image_url, 
                        description, status, price, quantity, rating, reviews_count
                FROM bazaar.product
                WHERE seller_id = $1
                LIMIT 20 OFFSET $2
        `

        queryCheckProductBelongs = `
                SELECT EXISTS(
                        SELECT 1 FROM bazaar.product 
                        WHERE id = $1 AND seller_id = $2
                )
        `

        queryUpdateProductImage = `
                UPDATE bazaar.product
                SET preview_image_url = $1
                WHERE id = $2
                RETURNING preview_image_url
        `
)

type SellerRepository struct {
        db *sql.DB
}

func NewSellerRepository(db *sql.DB) *SellerRepository <span class="cov8" title="1">{
        return &amp;SellerRepository{db: db}
}</span>

func (r *SellerRepository) AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "SellerRepository.AddProduct"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("begin transaction")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Генерируем UUID для продукта
        product.ID = uuid.New()

        // Вставляем продукт
        product.Status = models.ProductPending
        _, err = tx.ExecContext(ctx, queryAddProduct,
                product.ID,
                product.SellerID,
                product.Name,
                product.Description,
                product.Status,
                product.Price,
                product.Quantity,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("insert product")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        // Добавляем категорию продукта
        <span class="cov8" title="1">productCategoryID := uuid.New()
        _, err = tx.ExecContext(ctx, queryAddProductCategory,
                productCategoryID,
                product.ID,
                categoryID,
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("insert product category")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("commit transaction")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return product, nil</span>
}

func (r *SellerRepository) UploadProductImage(ctx context.Context, productID uuid.UUID, imageURL string) error <span class="cov8" title="1">{
        const op = "SellerRepository.UploadProductImage"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        // Обновляем URL изображения в БД
        _, err := r.db.ExecContext(ctx, queryUpdateProductImage, imageURL, productID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update product image URL")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *SellerRepository) GetSellerProducts(ctx context.Context, sellerID uuid.UUID, offset int) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "SellerRepository.GetSellerProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        rows, err := r.db.QueryContext(ctx, queryGetSellerProducts, sellerID, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query seller products")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var products []*models.Product
        for rows.Next() </span><span class="cov8" title="1">{
                var product models.Product
                err := rows.Scan(
                        &amp;product.ID,
                        &amp;product.SellerID,
                        &amp;product.Name,
                        &amp;product.PreviewImageURL,
                        &amp;product.Description,
                        &amp;product.Status,
                        &amp;product.Price,
                        &amp;product.Quantity,
                        &amp;product.Rating,
                        &amp;product.ReviewsCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">products = append(products, &amp;product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}

func (r *SellerRepository) CheckProductBelongs(ctx context.Context, productID, sellerID uuid.UUID) (bool, error) <span class="cov8" title="1">{
        const op = "SellerRepository.CheckProductBelongs"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var belongs bool
        err := r.db.QueryRowContext(ctx, queryCheckProductBelongs, productID, sellerID).Scan(&amp;belongs)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("check product belongs")
                return false, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return belongs, nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package suggestions

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

const (
        queryGetAllCategoriesName      = `SELECT name FROM bazaar.subcategory`
        queryGetAllProductsName        = `SELECT name FROM bazaar.product WHERE status = 'approved'`
        queryGetProductsNameByCategory = `
                SELECT DISTINCT p.name
                FROM bazaar.product p
                JOIN bazaar.product_subcategory ps ON p.id = ps.product_id
                JOIN bazaar.subcategory s ON s.id = ps.subcategory_id
                WHERE s.id = $1 AND p.status = 'approved'`
        queryCountAllProducts = `
        SELECT COUNT(*) 
        FROM bazaar.product 
        WHERE status = 'approved'`
        queryCountProductsByCategory = `
        SELECT COUNT(DISTINCT p.id)
        FROM bazaar.product p
        JOIN bazaar.product_subcategory ps ON p.id = ps.product_id
        WHERE ps.subcategory_id = $1 AND p.status = 'approved'`
)

type SuggestionsRepository struct {
        db *sql.DB
}

func NewSuggestionsRepository(db *sql.DB) *SuggestionsRepository <span class="cov8" title="1">{
        return &amp;SuggestionsRepository{
                db: db,
        }
}</span>

func (p *SuggestionsRepository) GetAllCategoriesName(ctx context.Context) ([]*models.CategorySuggestion, error) <span class="cov8" title="1">{
        const op = "CategoryRepository.GetAllCategories"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        categoriesList := []*models.CategorySuggestion{}

        rows, err := p.db.QueryContext(ctx, queryGetAllCategoriesName)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all categories")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                category := &amp;models.CategorySuggestion{}
                if err = rows.Scan(
                        &amp;category.Name,
                ); err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("scan category row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">categoriesList = append(categoriesList, category)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return categoriesList, nil</span>
}

func (p *SuggestionsRepository) GetAllProductsName(ctx context.Context) ([]*models.ProductSuggestion, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetAllProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        productsList := []*models.ProductSuggestion{}

        rows, err := p.db.QueryContext(ctx, queryGetAllProductsName)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query all products")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                product := &amp;models.ProductSuggestion{}
                if err = rows.Scan(
                        &amp;product.Name,
                ); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">productsList = append(productsList, product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}

func (p *SuggestionsRepository) GetProductsNameByCategory(ctx context.Context, categoryID string) ([]*models.ProductSuggestion, error) <span class="cov8" title="1">{
        const op = "ProductRepository.GetProductsNameByCategory"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        productsList := []*models.ProductSuggestion{}

        rows, err := p.db.QueryContext(ctx, queryGetProductsNameByCategory, categoryID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("query products by category")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                product := &amp;models.ProductSuggestion{}
                if err = rows.Scan(&amp;product.Name); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("scan product row")
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">productsList = append(productsList, product)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("rows iteration error")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return productsList, nil</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/google/uuid"
)

const (
        queryGetUserByEmail = `
        SELECT
                u.id,
                u.email,
                u.name,
                u.surname,
                u.password_hash,
                u.image_url,
                u.role
        FROM bazaar.user u
        WHERE u.email = $1;
        `
        queryGetUserByID = `
        SELECT 
                u.id, 
                u.email, 
                u.name, 
                u.surname, 
                u.password_hash, 
                u.image_url, 
                u.phone_number,
                u.role
        FROM bazaar.user u
        WHERE u.id = $1;
        `
        queryUpdateUserImageURL = `UPDATE bazaar.user SET image_url = $1 WHERE id = $2`
        queryUpdateUser         = `UPDATE bazaar.user SET name = $1, surname = $2, phone_number = $3 WHERE id = $4;`
        queryUpdateUserPassword = `UPDATE bazaar.user SET password_hash = $1 WHERE id = $2;`
        queryUpdateUserEmail    = `UPDATE bazaar.user SET email = $1 WHERE id = $2;`

        queryCreateSeller = `
        INSERT INTO bazaar.seller (id, title, description, user_id)
        VALUES ($1, $2, $3, $4)`

    queryUpdateUserRole = `
        UPDATE bazaar.user
        SET role = $1
        WHERE id = $2`
)

type UserRepository struct {
        db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov8" title="1">{
        return &amp;UserRepository{
                db: db,
        }
}</span>

func (r *UserRepository) UpdateUserImageURL(ctx context.Context, userID uuid.UUID, imageURL string) error <span class="cov8" title="1">{
        res, err := r.db.ExecContext(ctx, queryUpdateUserImageURL, imageURL, userID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return errs.NewNotFoundError("user not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *UserRepository) UpdateUserProfile(ctx context.Context, userID uuid.UUID, in models.UpdateUserDB) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, queryUpdateUser,
                in.Name,
                in.Surname,
                in.PhoneNumber,
                userID,
        )
        return err
}</span>

func (r *UserRepository) UpdateUserEmail(ctx context.Context, userID uuid.UUID, email string) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, queryUpdateUserEmail,
                email,
                userID,
        )
        return err
}</span>

func (r *UserRepository) UpdateUserPassword(ctx context.Context, userID uuid.UUID, passwordHash []byte) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, queryUpdateUserPassword,
                passwordHash,
                userID,
        )
        return err
}</span>

func (r *UserRepository) GetUserByEmail(ctx context.Context, email string) (*models.UserDB, error) <span class="cov8" title="1">{
        var user models.UserDB

        if err := r.db.QueryRowContext(ctx, queryGetUserByEmail, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.Role,
        ); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errs.ErrInvalidCredentials
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*models.UserDB, error) <span class="cov8" title="1">{
        var user models.UserDB

        err := r.db.QueryRowContext(ctx, queryGetUserByID, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Surname,
                &amp;user.PasswordHash,
                &amp;user.ImageURL,
                &amp;user.PhoneNumber,
                &amp;user.Role,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errs.ErrInvalidCredentials
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) CreateSellerAndUpdateRole(ctx context.Context, userID uuid.UUID, title, description string)  error <span class="cov8" title="1">{
    const op = "UserRepository.CreateSellerAndUpdateRole"
    
    // Начинаем транзакцию
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("%s: failed to begin transaction: %w", op, err)
    }</span>
    
    // Отложенный rollback в случае ошибки
    <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
            tx.Rollback()
        }</span>
    }()
    
    <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryCreateSeller, 
        uuid.New(), 
        title, 
        description, 
        userID,
    )
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("%s: failed to create seller: %w", op, err)
    }</span>
    
    // 2. Обновляем роль пользователя
    <span class="cov8" title="1">_, err = tx.ExecContext(ctx, queryUpdateUserRole, models.RolePending.String(), userID)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("%s: failed to update user role: %w", op, err)
    }</span>
    
    // Фиксируем транзакцию
    <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("%s: failed to commit transaction: %w", op, err)
    }</span>
    
    <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
)

const (
        userTokensPrefix = "user_id:"
)

type AuthRepository struct {
        client *Client
        cfg    *config.JWTConfig
}

func NewAuthRepository(client *Client, jwtCfg *config.JWTConfig) *AuthRepository <span class="cov0" title="0">{
        return &amp;AuthRepository{
                client: client,
                cfg:    jwtCfg,
        }
}</span>

// AddToBlacklist добавляет токен в список недействительных токенов пользователя
func (r *AuthRepository) AddToBlacklist(ctx context.Context, userID, token string) error <span class="cov0" title="0">{
        expiration := time.Until(time.Now().Add(r.cfg.TokenLifeSpan))
        userKey := fmt.Sprintf("%s%s", userTokensPrefix, userID)

        // Добавляем токен в множество пользователя
        if err := r.client.SAdd(ctx, userKey, token).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add token to user's blacklist: %w", err)
        }</span>

        // Обновляем TTL для множества, чтобы после жизни самого старшего токена ключ очистился
        <span class="cov0" title="0">if err := r.client.Expire(ctx, userKey, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set expiration for user's blacklist: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsInBlacklist проверяет, находится ли токен в черном списке
func (r *AuthRepository) IsInBlacklist(ctx context.Context, userID, token string) (bool, error) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("redis client is not initialized")
        }</span>
        
        <span class="cov0" title="0">userKey := fmt.Sprintf("%s%s", userTokensPrefix, userID)
        isMember, err := r.client.SIsMember(ctx, userKey, token).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check token in blacklist: %w", err)
        }</span>
        <span class="cov0" title="0">return isMember, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package redis

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/redis/go-redis/v9"
        "time"
)

type Client struct {
        *redis.Client
}

func NewClient(cfg *config.RedisConfig) (*Client, error) <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%s", cfg.Host, cfg.Port),
                Password: cfg.Password,
                DB:       cfg.DB,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if _, err := rdb.Ping(ctx).Result(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to redis: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{rdb}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package redis

import (
        "context"
        "fmt"
)

const (
        CategoryNamesKey = "suggestions:categories"
        ProductNamesKey  = "suggestions:products"
)

func categoryKey(categoryID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("suggestions:products:category:%s", categoryID)
}</span>

type SuggestionsRepository struct {
        client *Client
}

func NewSuggestionsRepository(client *Client) *SuggestionsRepository <span class="cov0" title="0">{
        return &amp;SuggestionsRepository{client: client}
}</span>

// AddSuggestionsByKey добавляет список строк в Redis по указанному ключу, сохраняя существующие записи
func (r *SuggestionsRepository) AddSuggestionsByKey(ctx context.Context, key string, names []string) error <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis client is not initialized")
        }</span>

        <span class="cov0" title="0">if err := r.client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis connection error: %w", err)
        }</span>

        // Получаем текущие значения
        <span class="cov0" title="0">current, err := r.client.SMembers(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current suggestions: %w", err)
        }</span>

        // Создаем мапу для быстрой проверки существующих значений
        <span class="cov0" title="0">existing := make(map[string]struct{})
        for _, v := range current </span><span class="cov0" title="0">{
                existing[v] = struct{}{}
        }</span>

        // Добавляем только новые значения
        <span class="cov0" title="0">var newValues []interface{}
        for _, name := range names </span><span class="cov0" title="0">{
                if _, found := existing[name]; !found </span><span class="cov0" title="0">{
                        newValues = append(newValues, name)
                }</span>
        }

        <span class="cov0" title="0">if len(newValues) &gt; 0 </span><span class="cov0" title="0">{
                if err := r.client.SAdd(ctx, key, newValues...).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add new suggestions to Redis: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetSuggestionsByKey получает список строк из Redis по указанному ключу.
func (r *SuggestionsRepository) GetSuggestionsByKey(ctx context.Context, key string) ([]string, error) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis client is not initialized")
        }</span>

        <span class="cov0" title="0">names, err := r.client.SMembers(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get suggestions from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return names, nil</span>
}

// AddProductSuggestionsByCategory сохраняет продукты для конкретной категории.
func (r *SuggestionsRepository) AddProductSuggestionsByCategory(ctx context.Context, categoryID string, names []string) error <span class="cov0" title="0">{
        return r.AddSuggestionsByKey(ctx, categoryKey(categoryID), names)
}</span>

// GetProductSuggestionsByCategory получает продукты для конкретной категории.
func (r *SuggestionsRepository) GetProductSuggestionsByCategory(ctx context.Context, categoryID string) ([]string, error) <span class="cov0" title="0">{
        return r.GetSuggestionsByKey(ctx, categoryKey(categoryID))
}</span>

// RemoveSuggestion удаляет конкретное значение из набора
func (r *SuggestionsRepository) RemoveSuggestion(ctx context.Context, key string, value string) error <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis client is not initialized")
        }</span>

        <span class="cov0" title="0">if err := r.client.SRem(ctx, key, value).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove suggestion: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSuggestionsByKeyPaginated получает список строк из Redis с пагинацией
// pageNum - номер страницы (начиная с 0)
// limit - количество элементов на странице
func (r *SuggestionsRepository) GetSuggestionsByKeyPaginated(ctx context.Context, key string, pageNum, limit int) ([]string, int64, error) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("redis client is not initialized")
        }</span>

        // Получаем общее количество элементов
        <span class="cov0" title="0">total, err := r.client.SCard(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get suggestions count from Redis: %w", err)
        }</span>

        // Если номер страницы некорректный или limit &lt;= 0
        <span class="cov0" title="0">if pageNum &lt; 0 || limit &lt;= 0 </span><span class="cov0" title="0">{
                return []string{}, total, nil
        }</span>

        // Вычисляем абсолютное смещение
        <span class="cov0" title="0">offset := pageNum * limit

        // Получаем все элементы
        allNames, err := r.client.SMembers(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get suggestions from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">maxPage := int((total + int64(limit) - 1) / int64(limit)) // Округление вверх: (total + limit - 1) / limit

        // Если номер страницы превышает максимально возможный
        if pageNum &gt;= maxPage </span><span class="cov0" title="0">{
                return []string{}, total, nil
        }</span>

        // Применяем пагинацию для обычного случая
        <span class="cov0" title="0">end := offset + limit
        if end &gt; len(allNames) </span><span class="cov0" title="0">{
                end = len(allNames)
        }</span>

        <span class="cov0" title="0">return allNames[offset:end], total, nil</span>
}

// GetProductSuggestionsByCategoryPaginated получает продукты для категории с пагинацией
// pageNum - номер страницы (начиная с 0)
// limit - количество элементов на странице
func (r *SuggestionsRepository) GetProductSuggestionsByCategoryPaginated(ctx context.Context, categoryID string, pageNum, limit int) ([]string, int64, error) <span class="cov0" title="0">{
        return r.GetSuggestionsByKeyPaginated(ctx, categoryKey(categoryID), pageNum, limit)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package errs

import (
        "errors"
        "fmt"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var (
        ErrReadRequestData    = errors.New("failed to read request body")
        ErrParseRequestData   = errors.New("failed to parse request body")
        ErrNotFound           = errors.New("not found")
        ErrInvalidToken       = errors.New("invalid token")
        ErrAlreadyExists      = errors.New("already exists")
        ErrInvalidID          = errors.New("invalid id format")
        ErrInvalidCredentials = errors.New("invalid credentials")
        ErrBusinessLogic      = errors.New("business logic error")
        ErrProductNotApproved = errors.New("product not approved")
        ErrNotEnoughStock     = errors.New("not enough stock")

        ErrMissingToken      = errors.New("missing jwt token")
        ErrTokenRevoked      = errors.New("token revoked")
        ErrNoMetadata        = errors.New("metadata is not provided")
        ErrNoAuthHeader      = errors.New("authorization header is missing")
        ErrInvalidAuthFormat = errors.New("invalid authorization header format")
        ErrInternal          = errors.New("internal server error")
        ErrInvalidProductPrice= errors.New("invalid product price")
        ErrEmptyProductName   = errors.New("invalid product name")
        ErrInvalidProductQuantity = errors.New("invalid product quantity")
)

func NewBusinessLogicError(msg string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", ErrBusinessLogic, msg)
}</span>

func NewNotFoundError(msg string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", ErrNotFound, msg)
}</span>

func NewAlreadyExistsError(msg string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s", ErrAlreadyExists, msg)
}</span>

func MapErrorToGRPC(err error) error <span class="cov0" title="0">{
        switch </span>{
        case errors.Is(err, ErrInvalidCredentials):<span class="cov0" title="0">
                return status.Error(codes.Unauthenticated, err.Error())</span>
        case errors.Is(err, ErrAlreadyExists):<span class="cov0" title="0">
                return status.Error(codes.AlreadyExists, err.Error())</span>
        case errors.Is(err, ErrNotFound):<span class="cov0" title="0">
                return status.Error(codes.NotFound, err.Error())</span>
        case errors.Is(err, ErrInvalidToken), errors.Is(err, ErrTokenRevoked):<span class="cov0" title="0">
                return status.Error(codes.Unauthenticated, err.Error())</span>
        default:<span class="cov0" title="0">
                return status.Error(codes.Internal, "internal server error")</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "github.com/guregu/null"
)

type OrderStatus int

const (
        Placed                    OrderStatus = iota // Оформлен
        AwaitingConfirmation                         // Ожидает подтверждения
        BeingPrepared                                // Готовится
        Shipped                                      // Отправлен
        InTransit                                    // В пути
        DeliveredToPickupPoint                       // Доставлен в пункт самовывоза
        Delivered                                    // Доставлен
        Canceled                                     // Отменен
        AwaitingPayment                              // Ожидает оплаты
        Paid                                         // Оплачено (опечатка в оригинале: должно быть Paid)
        PaymentFailed                                // Платеж не удался
        ReturnRequested                              // Возврат запрашивается
        ReturnProcessed                              // Возврат обработан
        ReturnInitiated                              // Возврат инициирован
        ReturnCompleted                              // Возврат завершен
        CanceledByUser                               // Отменен пользователем
        CanceledBySeller                             // Отменен продавцом
        CanceledDueToPaymentError                    // Отменен из-за ошибки платежа
)

func (s OrderStatus) String() string <span class="cov8" title="1">{
        return [...]string{
                "placed",
                "awaiting_confirmation",
                "being_prepared",
                "shipped",
                "in_transit",
                "delivered_to_pickup_point",
                "delivered",
                "canceled",
                "awaiting_payment",
                "paid",
                "payment_failed",
                "return_requested",
                "return_processed",
                "return_initiated",
                "return_completed",
                "canceled_by_user",
                "canceled_by_seller",
                "canceled_due_to_payment_error",
        }[s]
}</span>

func ParseOrderStatus(s string) (OrderStatus, error) <span class="cov8" title="1">{
        statuses := [...]string{
                "pending",
                "placed",
                "awaiting_confirmation",
                "being_prepared",
                "shipped",
                "in_transit",
                "delivered_to_pickup_point",
                "delivered",
                "canceled",
                "awaiting_payment",
                "paid",
                "payment_failed",
                "return_requested",
                "return_processed",
                "return_initiated",
                "return_completed",
                "canceled_by_user",
                "canceled_by_seller",
                "canceled_due_to_payment_error",
        }

        for i, val := range statuses </span><span class="cov8" title="1">{
                if s == val </span><span class="cov0" title="0">{
                        return OrderStatus(i), nil
                }</span>
        }

        <span class="cov8" title="1">return 0, fmt.Errorf("unknown order status: %s", s)</span>
}

func (s OrderStatus) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(s.String())
}</span>

type OrderPreviewProductDTO struct {
        ProductImageURL null.String `json:"ProductImageURL" swaggertype:"primitive,string"`
        ProductQuantity uint
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

const (
        MediaFolder          = "./media"
        CoverName            = "cover.jpeg"
        DefaultPathCoverName = "product-default"
)

// Константы статусов товара
const (
        ProductPending  ProductStatus = iota // Ожидает
        ProductRejected                      // Отказано
        ProductApproved                      // Одобрено
)

type SortOption string

const (
    SortByPriceAsc   SortOption = "price_asc"
    SortByPriceDesc  SortOption = "price_desc"
    SortByRatingAsc  SortOption = "rating_asc"
    SortByRatingDesc SortOption = "rating_desc"
    SortByDefault    SortOption = ""
)

// ProductStatus представляет статус товара
type ProductStatus int

type Product struct {
        ID              uuid.UUID     `json:"id" db:"id"`
        SellerID        uuid.UUID     `json:"seller_id" db:"seller_id"`
        Name            string        `json:"name" db:"name"`
        PreviewImageURL string        `json:"preview_image_url,omitempty" db:"preview_image_url"`
        Description     string        `json:"description" db:"description"`
        Status          ProductStatus `json:"status" db:"status"`
        Price           float64       `json:"price" db:"price"`
        PriceDiscount   float64            `json:"price_discount"`
        Quantity        uint          `json:"quantity" db:"quantity"`
        UpdatedAt       time.Time     `json:"updated_at" db:"updated_at"`
        Rating          float32       `json:"rating" db:"rating"`
        ReviewsCount    uint          `json:"reviews_count" db:"reviews_count"`
        Seller          *Seller       `json:"seller,omitempty"`
}

type ProductDiscount struct {
        DiscountedPrice   float64   `db:"discounted_price"`
        DiscountEndDate   time.Time `db:"end_date"`
        DiscountStartDate time.Time `db:"start_date"`
}

// String возвращает строковое представление статуса
func (s ProductStatus) String() string <span class="cov8" title="1">{
        return [...]string{
                "pending",
                "rejected",
                "approved",
        }[s]
}</span>

// ParseProductStatus преобразует строку в ProductStatus
func ParseProductStatus(status string) (ProductStatus, error) <span class="cov8" title="1">{
        switch status </span>{
        case "pending":<span class="cov8" title="1">
                return ProductPending, nil</span>
        case "rejected":<span class="cov0" title="0">
                return ProductRejected, nil</span>
        case "approved":<span class="cov8" title="1">
                return ProductApproved, nil</span>
        default:<span class="cov8" title="1">
                return ProductPending, fmt.Errorf("unknown product status: %s", status)</span>
        }
}

// Scan реализует интерфейс sql.Scanner для чтения из БД
func (s *ProductStatus) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                *s = ProductPending
                return nil
        }</span>

        <span class="cov8" title="1">var statusStr string

        // Обрабатываем разные типы, которые могут прийти из БД
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                statusStr = v</span>
        case []byte:<span class="cov0" title="0">
                statusStr = string(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to scan ProductStatus: unsupported type %T", value)</span>
        }

        <span class="cov8" title="1">status, err := ParseProductStatus(statusStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*s = status
        return nil</span>
}

// Value реализует интерфейс driver.Valuer для записи в БД
func (s ProductStatus) Value() (driver.Value, error) <span class="cov8" title="1">{
        return s.String(), nil
}</span>

func (p Product) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias Product
        return json.Marshal(&amp;struct {
                Status string `json:"status"`
                *Alias
        }{
                Status: p.Status.String(),
                Alias:  (*Alias)(&amp;p),
        })
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import (
        "database/sql/driver"
        "fmt"

        "github.com/google/uuid"
        "github.com/guregu/null"
)

const (
        RoleAdmin   UserRole = "admin"   // админ
        RoleBuyer   UserRole = "buyer"   // покупатель
        RoleSeller  UserRole = "seller"  // продавец
        RolePending UserRole = "pending" // в ожидании
)

// UserRole представляет роль пользователя в системе
type UserRole string

// String возвращает строковое представление роли
func (r UserRole) String() string <span class="cov8" title="1">{
        return string(r)
}</span>

// ParseUserRole преобразует строку в UserRole
func ParseUserRole(role string) (UserRole, error) <span class="cov8" title="1">{
        switch role </span>{
        case "admin":<span class="cov0" title="0">
                return RoleAdmin, nil</span>
        case "buyer":<span class="cov8" title="1">
                return RoleBuyer, nil</span>
        case "seller":<span class="cov0" title="0">
                return RoleSeller, nil</span>
        case "pending":<span class="cov8" title="1">
                return RolePending, nil</span>
        default:<span class="cov0" title="0">
                return RolePending, fmt.Errorf("unknown user role: %s", role)</span>
        }
}

// Scan реализует интерфейс sql.Scanner для чтения из БД
func (r *UserRole) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                *r = RolePending
                return nil
        }</span>

        <span class="cov8" title="1">var roleStr string

        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                roleStr = v</span>
        case []byte:<span class="cov0" title="0">
                roleStr = string(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to scan UserRole: unsupported type %T", value)</span>
        }

        <span class="cov8" title="1">role, err := ParseUserRole(roleStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = role
        return nil</span>
}

// Value реализует интерфейс driver.Valuer для записи в БД
func (r UserRole) Value() (driver.Value, error) <span class="cov8" title="1">{
        return r.String(), nil
}</span>

type User struct {
        ID          uuid.UUID   `json:"id"`
        Email       string      `json:"email"`
        Name        string      `json:"name"`
        Surname     null.String `json:"surname" swaggertype:"primitive,string"`
        ImageURL    null.String `json:"imageURL" swaggertype:"primitive,string"`
        PhoneNumber null.String `json:"phoneNumber,omitempty" swaggertype:"primitive,string"`
        Role        UserRole    `json:"role"`
        Seller      *Seller     `json:"seller,omitempty"`
}

type Seller struct {
    ID          uuid.UUID `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
}

type UpdateUserDB struct {
        Name        string
        Surname     null.String
        PhoneNumber null.String
}

type UserDB struct {
        ID           uuid.UUID
        Email        string
        Name         string
        Surname      null.String
        ImageURL     null.String
        PhoneNumber  null.String
        PasswordHash []byte
        Role         UserRole
}

func (u *UserDB) ConvertToUser() *User <span class="cov8" title="1">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;User{
                ID:          u.ID,
                Email:       u.Email,
                Name:        u.Name,
                Surname:     u.Surname,
                ImageURL:    u.ImageURL,
                PhoneNumber: u.PhoneNumber,
                Role:                 u.Role,
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package address

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator"
        "net/http"
        "net/url"
        "strings"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/address"
        "github.com/google/uuid"
)

type GeoapifyResponse struct {
        Features []GeoapifyFeature `json:"features"`
}

type GeoapifyFeature struct {
        Properties struct {
                ResultType string  `json:"result_type"`
                Lon        float64 `json:"lon"`
                Lat        float64 `json:"lat"`
                Rank       struct {
                        Importance float64 `json:"importance"`
                } `json:"rank"`
        } `json:"properties"`
}

type AddressHandler struct {
        addressService address.IAddressUsecase
        geoapifyAPIKey string
        httpClient     *http.Client
}

func NewAddressHandler(
        u address.IAddressUsecase,
        geoapifyAPIKey string,
) *AddressHandler <span class="cov8" title="1">{
        return &amp;AddressHandler{
                addressService: u,
                geoapifyAPIKey: geoapifyAPIKey,
                httpClient:     &amp;http.Client{},
        }
}</span>

// CreateAddress godoc
//
//        @Summary                Создание нового адреса
//        @Description        Создает новый адрес для текущего пользователя
//        @Tags                        address
//        @Accept                        json
//        @Produce                json
//        @Param                        address                        body        dto.AddressReqDTO        true        "Данные адреса"
//        @Param                        X-Csrf-Token        header        string                                true        "CSRF-токен для защиты от подделки запросов"
//        @Success                201                                "Адрес успешно создан"
//        @Failure                400                                {object}        object        "Неверный формат данных или ID пользователя"
//        @Failure                401                                {object}        object        "Пользователь не авторизован"
//        @Failure                500                                {object}        object        "Ошибка сервера при создании адреса"
//        @Security                TokenAuth
//        @Router                        /addresses [post]
func (h *AddressHandler) CreateAddress(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AddressHandler.CreateAddress"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var createAddressReq dto.AddressDTO
        if err := request.ParseData(r, &amp;createAddressReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if createAddressReq.Label.Valid &amp;&amp; strings.TrimSpace(createAddressReq.Label.String) != "" </span><span class="cov0" title="0">{
                if err := validator.ValidateLabel(createAddressReq.Label.String); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("invalid address label")
                        response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                        return
                }</span>
        }

        <span class="cov0" title="0">if !createAddressReq.AddressString.Valid || createAddressReq.AddressString.String == "" </span><span class="cov0" title="0">{
                logger.Error("address string is required")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "address string is required")
                return
        }</span>

        <span class="cov0" title="0">userIDStr, ok := r.Context().Value(domains.UserIDKey{}).(string)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("auth not found in context")
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "auth not found in context")
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse user ID")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid auth id format")
                return
        }</span>

        <span class="cov0" title="0">logger = logger.WithField("user_id", userID)

        geoData, err := h.geocodeAddress(r.Context(), createAddressReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("geoapify API error")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to validate address")
                return
        }</span>

        <span class="cov0" title="0">var bestMatch *GeoapifyFeature
        for _, feature := range geoData.Features </span><span class="cov0" title="0">{
                if feature.Properties.ResultType == "building" &amp;&amp; feature.Properties.Rank.Importance &gt; 0.2 </span><span class="cov0" title="0">{
                        if bestMatch == nil || feature.Properties.Rank.Importance &gt; bestMatch.Properties.Rank.Importance </span><span class="cov0" title="0">{
                                bestMatch = &amp;feature
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if bestMatch == nil </span><span class="cov0" title="0">{
                logger.Warn("no valid building address found")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "no valid building address found")
                return
        }</span>

        <span class="cov0" title="0">if err := h.addressService.CreateAddress(r.Context(), userID, createAddressReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create address")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusCreated, nil)</span>
}

func (h *AddressHandler) geocodeAddress(ctx context.Context, address dto.AddressDTO) (*GeoapifyResponse, error) <span class="cov0" title="0">{
        const op = "AddressHandler.geocodeAddress"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        if !address.AddressString.Valid || address.AddressString.String == "" </span><span class="cov0" title="0">{
                logger.Error("address string is empty")
                return nil, fmt.Errorf("%s: address string is empty", op)
        }</span>

        <span class="cov0" title="0">encodedAddress := url.QueryEscape(address.AddressString.String)

        apiURL := fmt.Sprintf("https://api.geoapify.com/v1/geocode/search?text=%s&amp;apiKey=%s",
                encodedAddress,
                h.geoapifyAPIKey)

        req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create request")
                return nil, fmt.Errorf("%s: failed to create request: %w", op, err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")

        resp, err := h.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("call Geoapify API")
                return nil, fmt.Errorf("%s: failed to call Geoapify API: %w", op, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Geoapify API returned status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var geoResponse GeoapifyResponse
        if err = json.NewDecoder(resp.Body).Decode(&amp;geoResponse); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("decode Geoapify response")
                return nil, fmt.Errorf("%s: failed to decode Geoapify response: %w", op, err)
        }</span>

        <span class="cov0" title="0">return &amp;geoResponse, nil</span>
}

// GetAddress godoc
//
//        @Summary                Получение списка адресов пользователя
//        @Description        Возвращает все адреса текущего пользователя
//        @Tags                        address
//        @Produce                json
//        @Success                200        {object}        map[string]string        "Успешный запрос"
//        @Failure                400        {object}        object                                "Неверный формат ID пользователя"
//        @Failure                401        {object}        object                                "Пользователь не авторизован"
//        @Failure                500        {object}        object                                "Ошибка сервера при получении адресов"
//        @Security                TokenAuth
//        @Router                        /addresses [get]
func (h *AddressHandler) GetAddress(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "AddressHandler.GetAddress"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        userIDStr, isExist := r.Context().Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov0" title="0">{
                logger.Error("auth not found in context")
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "auth not found in context")
                return
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse user ID")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid auth id format")
                return
        }</span>

        <span class="cov8" title="1">addresses, err := h.addressService.GetAddresses(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get addresses")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">if addresses == nil </span><span class="cov0" title="0">{
                addresses = []dto.GetAddressResDTO{}
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, map[string][]dto.GetAddressResDTO{
                "addresses": addresses,
        })</span>
}

// GetPickupPoints godoc
//
//        @Summary                Получение списка пунктов выдачи
//        @Description        Возвращает все доступные пункты выдачи
//        @Tags                        address
//        @Produce                json
//        @Success                200        {object}        map[string]string        "Успешный запрос"
//        @Failure                500        {object}        object                                "Ошибка сервера при получении пунктов выдачи"
//        @Router                        /addresses/pickup-points [get]
func (h *AddressHandler) GetPickupPoints(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "AddressHandler.GetPickupPoints"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        points, err := h.addressService.GetPickupPoints(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get pickup points")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, map[string][]dto.GetPointAddressResDTO{
                "pickupPoints": points,
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package admin

import (
    "context"
    "net/http"
    "strconv"

    "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
    "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
    "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
    "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
    "github.com/gorilla/mux"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
)

//go:generate mockgen -source=admin.go -destination=../../usecase/mocks/admin_usecase_mock.go -package=mocks IAdminUsecase
type IAdminUsecase interface {
    GetPendingProducts(ctx context.Context, offset int) (dto.ProductsResponse, error)
    UpdateProductStatus(ctx context.Context, req dto.UpdateProductStatusRequest) error
    GetPendingUsers(ctx context.Context, offset int) (dto.UsersResponse, error)
    UpdateUserRole(ctx context.Context, req dto.UpdateUserRoleRequest) error
}

type AdminService struct {
    uc IAdminUsecase
}

func NewAdminService(uc IAdminUsecase) *AdminService <span class="cov0" title="0">{
    return &amp;AdminService{uc: uc}
}</span>

func (h *AdminService) GetPendingProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    const op = "AdminService.GetPendingProducts"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    vars := mux.Vars(r)
    offsetStr := vars["offset"]
    offset, err := strconv.Atoi(offsetStr)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return
    }</span>

    <span class="cov0" title="0">products, err := h.uc.GetPendingProducts(r.Context(), offset)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get pending products")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, products)</span>
}

func (h *AdminService) UpdateProductStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    const op = "AdminService.UpdateProductStatus"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    var req dto.UpdateProductStatusRequest
    if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return
    }</span>

    <span class="cov0" title="0">if err := h.uc.UpdateProductStatus(r.Context(), req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("update product status")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

func (h *AdminService) GetPendingUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    const op = "AdminService.GetPendingUsers"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    vars := mux.Vars(r)
    offsetStr := vars["offset"]
    offset, err := strconv.Atoi(offsetStr)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return
    }</span>

    <span class="cov0" title="0">users, err := h.uc.GetPendingUsers(r.Context(), offset)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get pending users")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, users)</span>
}

func (h *AdminService) UpdateUserRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    const op = "AdminService.UpdateUserRole"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    var req dto.UpdateUserRoleRequest
    if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return
    }</span>

    <span class="cov0" title="0">if err := h.uc.UpdateUserRole(r.Context(), req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("update user role")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package auth

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/auth"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/auth"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/metadata"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator"
        "github.com/guregu/null"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
)

type AuthGRPCHandler struct {
        gen.UnimplementedAuthServiceServer

        authProvider auth.IAuthUsecase
        redisRepo    *redis.AuthRepository
        tokenator    *jwt.Tokenator
}

func NewAuthGRPCHandler(u auth.IAuthUsecase, redisRepo *redis.AuthRepository, tokenator *jwt.Tokenator) *AuthGRPCHandler <span class="cov0" title="0">{
        return &amp;AuthGRPCHandler{
                authProvider: u,
                redisRepo:    redisRepo,
                tokenator:    tokenator,
        }
}</span>

func (h *AuthGRPCHandler) Register(ctx context.Context, in *gen.RegisterReq) (*gen.RegisterRes, error) <span class="cov0" title="0">{
        const op = "AuthGRPCHandler.Register"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var surname null.String
        if in.Surname != nil </span><span class="cov0" title="0">{
                surname = null.StringFrom(in.Surname.Value)
        }</span>

        <span class="cov0" title="0">request := dto.UserRegisterRequestDTO{
                Email:    in.Email,
                Password: in.Password,
                Name:     in.Name,
                Surname:  surname,
        }

        validator.SanitizeUserRegistrationRequest(&amp;request)
        if err := validator.ValidateRegistrationCreds(request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("validate registration credentials")
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">token, err := h.authProvider.Register(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("registration failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;gen.RegisterRes{Token: token}, nil</span>
}

func (h *AuthGRPCHandler) Login(ctx context.Context, in *gen.LoginReq) (*gen.LoginRes, error) <span class="cov0" title="0">{
        const op = "AuthGRPCHandler.Login"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        request := dto.UserLoginRequestDTO{
                Email:    in.Email,
                Password: in.Password,
        }

        validator.SanitizeUserLoginRequest(&amp;request)
        if err := validator.ValidateLoginCreds(request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("validate login credentials")
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">token, err := h.authProvider.Login(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("login failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;gen.LoginRes{Token: token}, nil</span>
}

func (h *AuthGRPCHandler) Logout(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        const op = "AuthGRPCHandler.Logout"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        token, err := metadata.ExtractJWTFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to extract token")
                return nil, errs.MapErrorToGRPC(errs.ErrInvalidToken)
        }</span>

        <span class="cov0" title="0">if err := h.authProvider.Logout(ctx, token); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("logout failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (h *AuthGRPCHandler) CheckToken(ctx context.Context, req *gen.CheckTokenReq) (*gen.CheckTokenRes, error) <span class="cov0" title="0">{
        const op = "AuthGRPCHandler.CheckToken"
        tokenString := req.Token
        if tokenString == "" </span><span class="cov0" title="0">{
                return nil, errs.MapErrorToGRPC(errs.ErrInvalidToken)
        }</span>

        <span class="cov0" title="0">claims, err := h.tokenator.ParseJWT(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.MapErrorToGRPC(errs.ErrInvalidToken)
        }</span>

        <span class="cov0" title="0">isInBlackList, err := h.redisRepo.IsInBlacklist(ctx, claims.UserID, tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.MapErrorToGRPC(errs.ErrInternal)
        }</span>

        <span class="cov0" title="0">if isInBlackList </span><span class="cov0" title="0">{
                return nil, errs.MapErrorToGRPC(errs.ErrTokenRevoked)
        }</span>

        <span class="cov0" title="0">return &amp;gen.CheckTokenRes{Valid: true}, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package http

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/auth"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/metadata"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/cookie"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "google.golang.org/protobuf/types/known/emptypb"
)

type AuthHandler struct {
        authClient gen.AuthServiceClient
        config     *config.Config
}

func NewAuthHandler(
        authClient gen.AuthServiceClient,
        cfg *config.Config,
) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authClient: authClient,
                config:     cfg,
        }
}</span>

// Login godoc
//
//        @Summary                Авторизация пользователя
//        @Description        Авторизует пользователя и устанавливает JWT-токен в cookies
//        @Tags                        auth
//        @Accept                        json
//        @Produce                json
//        @Param                        request        body                dto.UserLoginRequestDTO        true        "Данные для входа"
//        @Success                200                {}                        -                                                "Успешная авторизация"
//        @Header                        200                {string}        Set-Cookie                                "JWT-токен авторизации"
//        @Failure                400                {object}        object                                        "Ошибка валидации данных"
//        @Failure                401                {object}        object                                        "Неверные email или пароль"
//        @Failure                500                {object}        object                                        "Внутренняя ошибка сервера"
//        @Router                        /auth/login [post]
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthHandler.Login"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var loginReq dto.UserLoginRequestDTO
        if err := request.ParseData(r, &amp;loginReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse login request")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">res, err := h.authClient.Login(r.Context(), &amp;gen.LoginReq{
                Email:    loginReq.Email,
                Password: loginReq.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">csrfToken, err := middleware.GenerateCSRFToken(
                res.Token,
                h.config.CSRFConfig.SecretKey,
                h.config.CSRFConfig.TokenExpiry,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("generate CSRF token")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to generate CSRF token")
                return
        }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(h.config)
        cookieProvider.Set(w, res.Token, domains.TokenCookieName)
        w.Header().Set("X-CSRF-Token", csrfToken)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

// Register godoc
//
//        @Summary                Регистрация пользователя
//        @Description        Создает нового пользователя и устанавливает JWT-токен в cookies
//        @Tags                        auth
//        @Accept                        json
//        @Produce                json
//        @Param                        userData        body                dto.UserRegisterRequestDTO        true        "Данные для регистрации"
//        @Success                200                        {}                        -                                                        "Успешная регистрация"
//        @Header                        200                        {string}        Set-Cookie                                        "JWT-токен авторизации"
//        @Failure                400                        {object}        object                                                "Некорректные данные"
//        @Failure                409                        {object}        object                                                "Пользователь уже существует"
//        @Failure                500                        {object}        object                                                "Внутренняя ошибка сервера"
//        @Router                        /auth/register [post]
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthHandler.Register"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var registerReq dto.UserRegisterRequestDTO
        if err := request.ParseData(r, &amp;registerReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse register request")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">res, err := h.authClient.Register(r.Context(), registerReq.ConvertToGrpcRegisterReq())
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">csrfToken, err := middleware.GenerateCSRFToken(
                res.Token,
                h.config.CSRFConfig.SecretKey,
                h.config.CSRFConfig.TokenExpiry,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("generate CSRF token")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to generate CSRF token")
                return
        }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(h.config)
        cookieProvider.Set(w, res.Token, domains.TokenCookieName)
        w.Header().Set("X-CSRF-Token", csrfToken)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

// Logout godoc
//
//        @Summary                Выход из системы
//        @Description        Завершает сеанс пользователя и удаляет JWT-токен из cookies
//        @Tags                        auth
//        @Produce                json
//        @Param                        X-Csrf-Token        header                string                true        "CSRF-токен для защиты от подделки запросов"
//        @Success                200                                {}                        -                        "Успешный выход из системы"
//        @Header                        200                                {string}        Set-Cookie        "Очищает JWT-токен (устанавливает пустое значение с истекшим сроком)"
//        @Failure                401                                {object}        object                "Пользователь не авторизован"
//        @Failure                500                                {object}        object                "Внутренняя ошибка сервера"
//        @Security                TokenAuth
//        @Router                        /auth/logout [post]
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "AuthHandler.Logout"

        jwtCookie, err := r.Cookie(string(domains.TokenCookieName))
        if err != nil </span><span class="cov0" title="0">{
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "JWT token required")
                return
        }</span>

        <span class="cov0" title="0">ctxWithToken := metadata.InjectJWTIntoContext(r.Context(), jwtCookie.Value)
        _, err = h.authClient.Logout(ctxWithToken, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">cookieProvider := cookie.NewCookieProvider(h.config)
        cookieProvider.Unset(w, domains.TokenCookieName)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package basket

import (
        "context"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "github.com/sirupsen/logrus"
)

//go:generate mockgen -source=basket.go -destination=../../usecase/mocks/basket_usecase_mock.go -package=mocks IBasketUsecase
type IBasketUsecase interface {
        Get(ctx context.Context) ([]*models.BasketItem, error)
        Add(ctx context.Context, productID uuid.UUID) (*models.BasketItem, error)
        Delete(ctx context.Context, productID uuid.UUID) error
        UpdateQuantity(ctx context.Context, productID uuid.UUID, quantity int) (*models.BasketItem, error)
        Clear(ctx context.Context) error
}

type BasketService struct {
        u IBasketUsecase
}

func NewBasketService(u IBasketUsecase) *BasketService <span class="cov8" title="1">{
        return &amp;BasketService{
                u: u,
        }
}</span>

// GetBasket godoc
//
//        @Summary                Получить содержимое корзины
//        @Description        Возвращает все товары в корзине пользователя
//        @Tags                        basket
//        @Produce                json
//        @Success                200        {object}        dto.BasketResponse
//        @Failure                401        {object}        object
//        @Failure                404        {object}        object
//        @Failure                500        {object}        object
//        @Security                TokenAuth
//        @Router                        /basket [get]
func (h *BasketService) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Get"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        items, err := h.u.Get(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get basket items")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">responseBasket := dto.ConvertToBasketResponse(items)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, responseBasket)</span>
}

// AddToBasket godoc
//
//        @Summary                Добавить товар в корзину
//        @Description        Добавляет товар в корзину пользователя
//        @Tags                        basket
//        @Accept                        json
//        @Produce                json
//        @Param                        id                                path                string        true        "ID товара в формате UUID"
//        @Param                        X-Csrf-Token        header                string        true        "CSRF-токен для защиты от подделки запросов"
//        @Success                201                                {object}        models.BasketItem
//        @Failure                400                                {object}        object
//        @Failure                401                                {object}        object
//        @Failure                404                                {object}        object
//        @Failure                500                                {object}        object
//        @Security                TokenAuth
//        @Router                        /basket/{id} [post]
func (h *BasketService) Add(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Add"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">item, err := h.u.Add(r.Context(), productID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("product_id", productID).WithError(err).Error("add product to basket")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusCreated, item)</span>
}

// RemoveFromBasket godoc
//
//        @Summary                Удалить товар из корзины
//        @Description        Удаляет товар из корзины пользователя
//        @Tags                        basket
//        @Param                        id                                path        string        true        "ID товара в формате UUID"
//        @Param                        X-Csrf-Token        header        string        true        "CSRF-токен для защиты от подделки запросов"
//        @Success                204
//        @Failure                400        {object}        object
//        @Failure                401        {object}        object
//        @Failure                404        {object}        object
//        @Failure                500        {object}        object
//        @Security                TokenAuth
//        @Router                        /basket/{id} [delete]
func (h *BasketService) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Delete"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">if err := h.u.Delete(r.Context(), productID); err != nil </span><span class="cov8" title="1">{
                logger.WithField("product_id", productID).WithError(err).Error("delete product from basket")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusNoContent, nil)</span>
}

// UpdateQuantity godoc
//
//        @Summary                Обновить количество товара
//        @Description        Изменяет количество указанного товара в корзине
//        @Tags                        basket
//        @Accept                        json
//        @Produce                json
//        @Param                        id                                path                string                                                true        "ID товара в формате UUID"
//        @Param                        request                        body                dto.UpdateQuantityRequest        true        "Новое количество"
//        @Param                        X-Csrf-Token        header                string                                                true        "CSRF-токен для защиты от подделки запросов"
//        @Success                200                                {object}        dto.UpdateQuantityResponse
//        @Failure                400                                {object}        object
//        @Failure                401                                {object}        object
//        @Failure                404                                {object}        object
//        @Failure                500                                {object}        object
//        @Security                TokenAuth
//        @Router                        /basket/{id} [patch]
func (h *BasketService) UpdateQuantity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.UpdateQuantity"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var req dto.UpdateQuantityRequest
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("parse request data")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        idStr := vars["id"]
        productID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">logger = logger.WithFields(logrus.Fields{
                "product_id": productID,
                "quantity":   req.Quantity,
        })

        item, err := h.u.UpdateQuantity(r.Context(), productID, req.Quantity)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update product quantity")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">resp := dto.ConvertToQuantityResponse(item)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, resp)</span>
}

// ClearBasket godoc
//
//        @Summary                Очистить корзину
//        @Description        Полностью удаляет все товары из корзины пользователя
//        @Tags                        basket
//        @Param                        X-Csrf-Token        header        string        true        "CSRF-токен для защиты от подделки запросов"
//        @Success                204
//        @Failure                401        {object}        object
//        @Failure                500        {object}        object
//        @Security                TokenAuth
//        @Router                        /basket [delete]
func (h *BasketService) Clear(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "BasketService.Clear"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        if err := h.u.Clear(r.Context()); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("clear basket")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package category

import (
        "context"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
)

//go:generate mockgen -source=category.go -destination=../../usecase/mocks/category_usecase_mock.go -package=mocks ICategoryUsecase
type ICategoryUsecase interface {
        GetAllCategories(ctx context.Context) ([]*models.Category, error)
        GetAllSubategories(ctx context.Context, category_id uuid.UUID) ([]*models.Category, error)
        GetNameSubcategory(ctx context.Context, id uuid.UUID) (string, error)
}

type CategoryService struct {
        u ICategoryUsecase
}

func NewCategoryService(u ICategoryUsecase) *CategoryService <span class="cov8" title="1">{
        return &amp;CategoryService{
                u: u,
        }
}</span>

// GetAllCategories godoc
//
//        @Summary                Получить все категории
//        @Description        Возвращает список всех доступных категорий товаров
//        @Tags                        categories
//        @Produce                json
//        @Success                200        {array}                dto.CategoryResponse
//        @Failure                500        {object}        object
//        @Router                        /categories [get]
func (h *CategoryService) GetAllCategories(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "CategoryService.GetAllCategories"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        categories, err := h.u.GetAllCategories(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get all categories")
                response.HandleDomainError(r.Context(), w, err, "get categories")
                return
        }</span>

        <span class="cov8" title="1">categoryResponse := dto.ConvertToCategoriesResponse(categories)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, categoryResponse)</span>
}

func (h *CategoryService) GetAllSubcategories(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CategoryService.GetAllSubcategories"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("category_id", idStr).Error("parse category ID")
                response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
                return
        }</span>

        <span class="cov0" title="0">categories, err := h.u.GetAllSubategories(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get all subcategories")
                response.HandleDomainError(r.Context(), w, err, "get subcategories")
                return
        }</span>

        <span class="cov0" title="0">categoryResponse := dto.ConvertToCategoriesResponse(categories)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, categoryResponse)</span>
}

func (h *CategoryService) GetNameSubcategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CategoryService.GetNameSubcategories"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("subcategory_id", idStr).Error("parse subcategory ID")
                response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
                return
        }</span>

        <span class="cov0" title="0">name, err := h.u.GetNameSubcategory(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get name subcategory")
                response.HandleDomainError(r.Context(), w, err, "get name subcategory")
                return
        }</span>

        <span class="cov0" title="0">var resp dto.NameSubcategory;
        resp.Name = name

        response.SendJSONResponse(r.Context(), w, http.StatusOK, resp)</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package csat

import (
        "context"
        "github.com/google/uuid"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/csat"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/csat"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "google.golang.org/protobuf/types/known/emptypb"
)

type CsatGRPCHandler struct {
        gen.UnimplementedSurveyServiceServer
        csatUseCase csat.ICsatUsecase
}

func NewCsatGRPCHandler(u csat.ICsatUsecase) *CsatGRPCHandler <span class="cov0" title="0">{
        return &amp;CsatGRPCHandler{
                csatUseCase: u,
        }
}</span>

func (h *CsatGRPCHandler) GetSurveyWithQuestions(ctx context.Context, req *gen.GetSurveyRequest) (*gen.SurveyWithQuestionsResponse, error) <span class="cov0" title="0">{
        const op = "CsatGRPCHandler.GetSurveyWithQuestions"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        survey, err := h.csatUseCase.GetSurveyWithQuestions(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get survey")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return dto.ConvertSurveyToGrpc(survey), nil</span>
}

func (h *CsatGRPCHandler) SubmitAnswer(ctx context.Context, req *gen.SubmitAnswerRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        const op = "CsatGRPCHandler.SubmitAnswer"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        answReq, err := dto.ConvertGrpcToSubmitRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed sumbit answers")
                return &amp;emptypb.Empty{}, nil
        }</span>

        <span class="cov0" title="0">err = h.csatUseCase.SubmitAnswer(ctx, answReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to submit answer")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (h *CsatGRPCHandler) GetSurveyStatistics(ctx context.Context, req *gen.GetStatisticsRequest) (*gen.SurveyStatisticsResponse, error) <span class="cov0" title="0">{
        const op = "CsatGRPCHandler.GetSurveyStatistics"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        surveyID, err := uuid.Parse(req.SurveyId)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("invalid survey ID format")
                return nil, status.Error(codes.InvalidArgument, "invalid survey ID")
        }</span>

        <span class="cov0" title="0">stats, err := h.csatUseCase.GetSurveyStatistics(ctx, surveyID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get survey statistics")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return dto.ConvertModelsToGrpcStatisticsResponse(stats), nil</span>
}


func (h *CsatGRPCHandler) GetAllSurveys(ctx context.Context, _ *emptypb.Empty) (*gen.SurveysList, error) <span class="cov0" title="0">{
        const op = "CsatGRPCHandler.GetAllSurveys"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        surveys, err := h.csatUseCase.GetAllSurveys(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get surveys")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return dto.ConvertSurveysListToGrpc(surveys), nil</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package csat

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/csat"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/gorilla/mux"
        "google.golang.org/protobuf/types/known/emptypb"
)

type CsatHandler struct {
        csatClient gen.SurveyServiceClient
}

func NewCsatHandler(csatClient gen.SurveyServiceClient) *CsatHandler <span class="cov0" title="0">{
        return &amp;CsatHandler{
                csatClient: csatClient,
        }
}</span>

func (h *CsatHandler) GetSurvey(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CsatHandler.Get"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        name := vars["name"]

        logger = logger.WithField("topic_name", name)

        res, err := h.csatClient.GetSurveyWithQuestions(r.Context(), &amp;gen.GetSurveyRequest{Name: name})
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed get survey")
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">survey, err := dto.ConvertGrpcToSurvey(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to convert survey")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to process survey data")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, survey)</span>
}

func (h *CsatHandler) SubmitAnswer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CsatHandler.SubmitAnswer"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var answerReq dto.SubmitAnswersRequest
        if err := request.ParseData(r, &amp;answerReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">_, err := h.csatClient.SubmitAnswer(r.Context(), dto.ConvertToGrpcSubmitRequest(&amp;answerReq))
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

func (h *CsatHandler) GetAllSurveys(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CsatHandler.GetAllSurveys"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        res, err := h.csatClient.GetAllSurveys(r.Context(), &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">surveys, err := dto.ConvertGrpcToSurveyList(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to convert surveys")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to process surveys data")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, surveys)</span>
}

func (h *CsatHandler) GetSurveyStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "CsatHandler.GetSurveyStatistics"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        surveyID := vars["surveyId"]

        res, err := h.csatClient.GetSurveyStatistics(r.Context(), &amp;gen.GetStatisticsRequest{
                SurveyId: surveyID,
        })
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">stats, err := dto.ConvertGrpcToStatisticsResponse(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to convert statistics")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to process statistics data")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, stats)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/google/uuid"
)

type UpdateUserRoleRequest struct{
        UserID uuid.UUID           `json:"userID"`
        Update int                           `json:"update"`
}

type UpdateProductStatusRequest struct{
        ProductID uuid.UUID   `json:"productID"`
        Update int                           `json:"update"`
}

type BriefUser struct {
    ID         uuid.UUID `json:"id"`
    Email      string    `json:"email"`
    Name       string    `json:"name"`
    Surname    string    `json:"surname,omitempty"`
    ImageURL   string    `json:"image,omitempty"`
    Phone      string    `json:"phone,omitempty"`
    Role       string    `json:"role"`
    SellerInfo *SellerInfo `json:"seller_info,omitempty"`
}

type SellerInfo struct {
    Title       string `json:"title"`
    Description string `json:"description,omitempty"`
}

func ConvertToBriefUser(user *models.User) BriefUser <span class="cov8" title="1">{
    briefUser := BriefUser{
        ID:       user.ID,
        Email:    user.Email,
        Name:     user.Name,
        Surname:  user.Surname.String,
        ImageURL: user.ImageURL.String,
        Phone:    user.PhoneNumber.String,
        Role:     user.Role.String(),
    }

    if user.Seller != nil </span><span class="cov0" title="0">{
        briefUser.SellerInfo = &amp;SellerInfo{
            Title:       user.Seller.Title,
            Description: user.Seller.Description,
        }
    }</span>

    <span class="cov8" title="1">return briefUser</span>
}

type UsersResponse struct {
    Total int         `json:"total"`
    Users []BriefUser `json:"users"`
}

func ConvertToUsersResponse(users []*models.User) UsersResponse <span class="cov8" title="1">{
    briefUsers := make([]BriefUser, 0, len(users))
    for _, user := range users </span><span class="cov8" title="1">{
        briefUsers = append(briefUsers, ConvertToBriefUser(user))
    }</span>

    <span class="cov8" title="1">return UsersResponse{
        Total: len(briefUsers),
        Users: briefUsers,
    }</span>
}</pre>
		
		<pre class="file" id="file31" style="display: none">package dto

import (
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/auth"
        "github.com/guregu/null"
        "google.golang.org/protobuf/types/known/wrapperspb"
)

type UserLoginRequestDTO struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

type UserRegisterRequestDTO struct {
        Email    string      `json:"email"`
        Password string      `json:"password"`
        Name     string      `json:"name"`
        Surname  null.String `json:"surname,omitempty" swaggertype:"primitive,string"`
}

func (u *UserRegisterRequestDTO) ConvertToGrpcRegisterReq() *gen.RegisterReq <span class="cov0" title="0">{
        var surname *wrapperspb.StringValue
        if u.Surname.Valid </span><span class="cov0" title="0">{
                surname = wrapperspb.String(u.Surname.String)
        }</span>

        <span class="cov0" title="0">return &amp;gen.RegisterReq{
                Email:    u.Email,
                Password: u.Password,
                Name:     u.Name,
                Surname:  surname,
        }</span>
}

type UserResponseDTO struct {
        Token string `json:"token"`
}

type ErrorResponseDTO struct {
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package dto

import "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"

type UpdateQuantityRequest struct {
        Quantity  int       `json:"quantity"`
}

type UpdateQuantityResponse struct {
        Item                                 *models.BasketItem  `json:"item"`
}

func ConvertToQuantityResponse(item *models.BasketItem) UpdateQuantityResponse <span class="cov8" title="1">{
        return UpdateQuantityResponse{
                Item: item,
        }
}</span>

type BasketResponse struct {
    Total              int                          `json:"total"`
    TotalPrice         float64                      `json:"total_price"`
    TotalPriceDiscount float64                      `json:"total_price_discount"`
        Products           []models.BasketItem  `json:"products"`
}

func ConvertToBasketResponse(items []*models.BasketItem) BasketResponse<span class="cov8" title="1">{
        var totalPrice, totalPriceDiscount float64 
        productsList := make([]models.BasketItem, 0, len(items))
        for _, product := range items</span><span class="cov8" title="1">{
                productsList = append(productsList, *product)
                totalPrice = totalPrice + product.Price * float64(product.Quantity)
        price := product.Price
        if product.PriceDiscount &gt; 0 </span><span class="cov8" title="1">{
            price = product.PriceDiscount
        }</span>
        <span class="cov8" title="1">totalPriceDiscount += price * float64(product.Quantity)</span>
        }

        <span class="cov8" title="1">return BasketResponse{
                Total: len(productsList),
                TotalPrice: totalPrice,
                TotalPriceDiscount : totalPriceDiscount,
                Products: productsList,
        }</span>
}</pre>
		
		<pre class="file" id="file33" style="display: none">package dto

import "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"

type CategoryResponse struct {
        Total     int               `json:"total"`
        Categorys []models.Category `json:"categories"`
}

// ConvertToCategoriesResponse - преобразует список категорий в структуру CategoryResponse.
func ConvertToCategoriesResponse(categories []*models.Category) CategoryResponse <span class="cov8" title="1">{
        categoryList := make([]models.Category, 0, len(categories))
        for _, cat := range categories </span><span class="cov8" title="1">{
                if cat != nil </span><span class="cov8" title="1">{
                        categoryList = append(categoryList, *cat)
                }</span>
        }

        <span class="cov8" title="1">return CategoryResponse{
                Total:     len(categories),
                Categorys: categoryList,
        }</span>
}

type NameSubcategory struct {
        Name string `json:"name"`
}</pre>
		
		<pre class="file" id="file34" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/csat"
        "github.com/google/uuid"
)

type SurveyWithQuestionsResponse struct {
        ID          uuid.UUID             `json:"surveyId"`
        Title       string                `json:"title"`
        Description string                `json:"description"`
        Questions   []QuestionResponseDTO `json:"questions"`
}

func ConvertGrpcToSurvey(s *gen.SurveyWithQuestionsResponse) (*SurveyWithQuestionsResponse, error) <span class="cov0" title="0">{
        surveyID, err := uuid.Parse(s.SurveyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">questions := make([]QuestionResponseDTO, 0, len(s.Questions))
        for _, q := range s.Questions </span><span class="cov0" title="0">{
                questionID, err := uuid.Parse(q.QuestionId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">questions = append(questions, QuestionResponseDTO{
                        ID:   questionID,
                        Text: q.Text,
                })</span>
        }
        <span class="cov0" title="0">return &amp;SurveyWithQuestionsResponse{
                ID:          surveyID,
                Title:       s.Title,
                Description: s.Description,
                Questions:   questions,
        }, nil</span>
}

func ConvertSurveyToGrpc(s *SurveyWithQuestionsResponse) *gen.SurveyWithQuestionsResponse <span class="cov0" title="0">{
        questions := make([]*gen.QuestionResponseDTO, 0, len(s.Questions))
        for _, q := range s.Questions </span><span class="cov0" title="0">{
                questions = append(questions, &amp;gen.QuestionResponseDTO{
                        QuestionId: q.ID.String(),
                        Text:       q.Text,
                })
        }</span>

        <span class="cov0" title="0">return &amp;gen.SurveyWithQuestionsResponse{
                SurveyId:    s.ID.String(),
                Title:       s.Title,
                Description: s.Description,
                Questions:   questions,
        }</span>
}

type QuestionResponseDTO struct {
        ID   uuid.UUID `json:"questionId"`
        Text string    `json:"text"`
}

// Запрос на отправку ответов
type SubmitAnswersRequest struct {
        SurveyID uuid.UUID          `json:"surveyId"`
        Answers  []AnswerRequestDTO `json:"answers"`
}

func ConvertToGrpcSubmitRequest(s *SubmitAnswersRequest) *gen.SubmitAnswerRequest <span class="cov0" title="0">{
        answers := make([]*gen.AnswerRequestDTO, 0, len(s.Answers))
        for _, a := range s.Answers </span><span class="cov0" title="0">{
                answers = append(answers, &amp;gen.AnswerRequestDTO{
                        QuestionId: a.QuestionID.String(),
                        Value:      uint32(a.Value),
                })
        }</span>

        <span class="cov0" title="0">return &amp;gen.SubmitAnswerRequest{
                SurveyId: s.SurveyID.String(),
                Answers:  answers,
        }</span>
}

// ConvertGrpcToSubmitRequest конвертирует gRPC SubmitAnswerRequest в DTO SubmitAnswersRequest
func ConvertGrpcToSubmitRequest(grpcReq *gen.SubmitAnswerRequest) (*SubmitAnswersRequest, error) <span class="cov0" title="0">{
        surveyID, err := uuid.Parse(grpcReq.SurveyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">answers := make([]AnswerRequestDTO, 0, len(grpcReq.Answers))
        for _, grpcAnswer := range grpcReq.Answers </span><span class="cov0" title="0">{
                questionID, err := uuid.Parse(grpcAnswer.QuestionId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">answers = append(answers, AnswerRequestDTO{
                        QuestionID: questionID,
                        Value:      uint(grpcAnswer.Value),
                })</span>
        }

        <span class="cov0" title="0">return &amp;SubmitAnswersRequest{
                SurveyID: surveyID,
                Answers:  answers,
        }, nil</span>
}

// DTO для ответа в запросе
type AnswerRequestDTO struct {
        QuestionID uuid.UUID `json:"questionId"`
        Value      uint      `json:"value"`
}

type SurveyStatisticsResponse struct {
        Description string                  `json:"description"`
        Questions   []QuestionStatisticsDTO `json:"questions"`
}

type QuestionStatisticsDTO struct {
        ID    uuid.UUID `json:"id"`
        Text  string    `json:"text"`
        Stats []uint32  `json:"stats"`
}

type BriefSurveyDTO struct {
        ID    uuid.UUID `json:"id"`
        Title string    `json:"title"`
}

type SurveysListDTO struct {
        Surveys []BriefSurveyDTO `json:"surveys"`
}

func ConvertModelsToSurveysListDTO(surveys []models.Survey) *SurveysListDTO <span class="cov8" title="1">{
        result := &amp;SurveysListDTO{
                Surveys: make([]BriefSurveyDTO, 0, len(surveys)),
        }

        for _, s := range surveys </span><span class="cov8" title="1">{
                result.Surveys = append(result.Surveys, BriefSurveyDTO{
                        ID:    s.ID,
                        Title: s.Title,
                })
        }</span>

        <span class="cov8" title="1">return result</span>
}

func ConvertSurveysListToGrpc(s *SurveysListDTO) *gen.SurveysList <span class="cov0" title="0">{
        surveys := make([]*gen.BriefSurvey, 0, len(s.Surveys))
        for _, survey := range s.Surveys </span><span class="cov0" title="0">{
                surveys = append(surveys, &amp;gen.BriefSurvey{
                        Id:    survey.ID.String(),
                        Title: survey.Title,
                })
        }</span>

        <span class="cov0" title="0">return &amp;gen.SurveysList{
                Surveys: surveys,
        }</span>
}

func ConvertGrpcToSurveyList(grpcList *gen.SurveysList) (*SurveysListDTO, error) <span class="cov0" title="0">{
        surveys := make([]BriefSurveyDTO, 0, len(grpcList.Surveys))
        
        for _, grpcSurvey := range grpcList.Surveys </span><span class="cov0" title="0">{
                id, err := uuid.Parse(grpcSurvey.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">surveys = append(surveys, BriefSurveyDTO{
                        ID:    id,
                        Title: grpcSurvey.Title,
                })</span>
        }

        <span class="cov0" title="0">return &amp;SurveysListDTO{
                Surveys: surveys,
        }, nil</span>
}
func ConvertGrpcToStatisticsRequest(grpcReq *gen.GetStatisticsRequest) (uuid.UUID, error) <span class="cov0" title="0">{
        return uuid.Parse(grpcReq.SurveyId)
}</span>

func ConvertModelsToGrpcStatisticsResponse(stats *SurveyStatisticsResponse) *gen.SurveyStatisticsResponse <span class="cov0" title="0">{
        questions := make([]*gen.QuestionStatisticsDTO, 0, len(stats.Questions))

        for _, q := range stats.Questions </span><span class="cov0" title="0">{
                questions = append(questions, &amp;gen.QuestionStatisticsDTO{
                        QuestionId: q.ID.String(),
                        Text:       q.Text,
                        Stats:      q.Stats,
                })
        }</span>

        <span class="cov0" title="0">return &amp;gen.SurveyStatisticsResponse{
                Description: stats.Description,
                Questions:   questions,
        }</span>
}

func ConvertGrpcToStatisticsResponse(grpcResp *gen.SurveyStatisticsResponse) (*SurveyStatisticsResponse, error) <span class="cov0" title="0">{
        questions := make([]QuestionStatisticsDTO, 0, len(grpcResp.Questions))

        for _, grpcQ := range grpcResp.Questions </span><span class="cov0" title="0">{
                id, err := uuid.Parse(grpcQ.QuestionId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">questions = append(questions, QuestionStatisticsDTO{
                        ID:    id,
                        Text:  grpcQ.Text,
                        Stats: grpcQ.Stats,
                })</span>
        }

        <span class="cov0" title="0">return &amp;SurveyStatisticsResponse{
                Description: grpcResp.Description,
                Questions:   questions,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/google/uuid"
        "time"
)

type Order struct {
        ID                 uuid.UUID
        UserID             uuid.UUID
        Status             models.OrderStatus
        TotalPrice         float64
        TotalPriceDiscount float64
        AddressID          uuid.UUID
        Items              []CreateOrderItemDTO
}

type CreateOrderDTO struct {
        UserID    uuid.UUID
        Items     []CreateOrderItemDTO `json:"items"`
        AddressID uuid.UUID            `json:"addressID"`
}

type CreateOrderItemDTO struct {
        ID        uuid.UUID
        ProductID uuid.UUID `json:"productID"`
        Price     float64   `json:"productPrice"`
        Quantity  uint      `json:"quantity"`
}

type CreateOrderRepoReq struct {
        Order             *Order
        UpdatedQuantities map[uuid.UUID]uint
}

type GetOrderByUserIDResDTO struct {
        ID                 uuid.UUID          `json:"id"`
        Status             models.OrderStatus `json:"status"`
        TotalPrice         float64            `json:"totalPrice"`
        TotalPriceDiscount float64            `json:"totalPriceDiscount"`
        AddressID          uuid.UUID          `json:"addressID"`
        ExpectedDeliveryAt *time.Time         `json:"expectedDeliveryAt"`
        ActualDeliveryAt   *time.Time         `json:"actualDeliveryAt"`
        CreatedAt          *time.Time         `json:"createdAt,omitempty"`
}

type OrderPreviewDTO struct {
        ID                 uuid.UUID                       `json:"id"`
        Status             models.OrderStatus              `json:"status"`
        TotalPrice         float64                         `json:"totalPrice"`
        TotalDiscountPrice float64                         `json:"totalDiscountPrice"`
        Products           []models.OrderPreviewProductDTO `json:"products"`
        Address            models.AddressDB                `json:"address"`
        ExpectedDeliveryAt *time.Time                      `json:"expectedDeliveryAt"`
        ActualDeliveryAt   *time.Time                      `json:"actualDeliveryAt"`
        CreatedAt          *time.Time                      `json:"createdAt,omitempty"`
}

func (orderItem *GetOrderByUserIDResDTO) ConvertToGetOrderByUserIDResDTO(
        address *models.AddressDB,
        products []models.OrderPreviewProductDTO,
) OrderPreviewDTO <span class="cov0" title="0">{
        return OrderPreviewDTO{
                ID:                 orderItem.ID,
                Status:             orderItem.Status,
                TotalPrice:         orderItem.TotalPrice,
                TotalDiscountPrice: orderItem.TotalPriceDiscount,
                Products:           products,
                Address:            *address,
        }
}</span>

type GetOrderProductResDTO struct {
        ProductID uuid.UUID `json:"productID"`
        Quantity  uint      `json:"quantity"`
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/google/uuid"
)

type BriefProduct struct {
        ID            uuid.UUID `json:"id"`
        Name          string    `json:"name"`
        ImageURL      string    `json:"image"`
        Price         float64   `json:"price"`
        PriceDiscount float64   `json:"discount_price"`
        Quantity      uint      `json:"quantity"`
        ReviewsCount  uint      `json:"reviews_count"`
        Rating        float32   `json:"rating"`
        SellerInfo           *SellerInfo `json:"seller_info,omitempty"`
}

func ConvertToBriefProduct(product *models.Product) BriefProduct <span class="cov8" title="1">{
        briefProduct := BriefProduct{
                ID:            product.ID,
                Name:          product.Name,
                ImageURL:      product.PreviewImageURL,
                Price:         product.Price,
                PriceDiscount: product.PriceDiscount,
                Quantity:      product.Quantity,
                ReviewsCount:  product.ReviewsCount,
                Rating:        product.Rating,
        }

        if product.Seller != nil </span><span class="cov0" title="0">{
        briefProduct.SellerInfo = &amp;SellerInfo{
            Title:       product.Seller.Title,
            Description: product.Seller.Description,
        }
    }</span>

        <span class="cov8" title="1">return briefProduct</span>
}

type ProductsResponse struct {
        Total    int            `json:"total"`
        Products []BriefProduct `json:"products"`
}

func ConvertToProductsResponse(products []*models.Product) ProductsResponse <span class="cov8" title="1">{
        briefProducts := make([]BriefProduct, 0, len(products))
        for _, product := range products </span><span class="cov8" title="1">{
                briefProducts = append(briefProducts, ConvertToBriefProduct(product))
        }</span>

        <span class="cov8" title="1">return ProductsResponse{
                Total:    len(briefProducts),
                Products: briefProducts,
        }</span>
}

type GetProductsByIDRequest struct {
        ProductIDs []uuid.UUID `json:"productIDs" validate:"required,min=1"`
}

type AddProductRequest struct {
    Name            string  `json:"name" validate:"required"`
    SellerID       string  `json:"seller_id" validate:"required,uuid4"`
    PreviewImageURL string `json:"preview_image_url,omitempty"`
    Description     string `json:"description,omitempty"`
    Price          float64 `json:"price" validate:"required,gt=0"`
    PriceDiscount  float64 `json:"price_discount" validate:"gte=0"`
    Quantity       uint    `json:"quantity" validate:"gte=0"`
    Rating         float32 `json:"rating,omitempty" validate:"gte=0,lte=5"`
    ReviewsCount   uint    `json:"reviews_count,omitempty" validate:"gte=0"`
    Category       string  `json:"category" validate:"required,uuid4"`
}

type ProductsSellerResponse struct {
        Total int                                                 `json:"total"`
        Products []*models.Product      `json:"products"`
}

func ConvertToSellerProductsResponse(products []*models.Product) ProductsSellerResponse <span class="cov0" title="0">{
        return ProductsSellerResponse{
                Total:    len(products),
                Products: products,
        }
}</pre>
		
		<pre class="file" id="file37" style="display: none">package dto

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/review"
        "github.com/google/uuid"
        "github.com/guregu/null"
)

type AddReviewRequest struct {
        ProductID uuid.UUID `json:"productID" db:"product_id"`
        Rating    int       `json:"rating" db:"rating"`
        Comment   string    `json:"comment" db:"comment"`
}

// ConvertAddReviewRequestToGRPC преобразует dto.AddReviewRequest в gen.AddReviewRequest
func ConvertAddReviewRequestToGRPC(dtoReq AddReviewRequest) *review.AddReviewRequest <span class="cov0" title="0">{
        return &amp;review.AddReviewRequest{
                ProductId: dtoReq.ProductID.String(),
                Rating:    int32(dtoReq.Rating),
                Comment:   dtoReq.Comment,
        }
}</span>

type GetReviewRequest struct {
        ProductID uuid.UUID `json:"productID" db:"review_id"`
        Offset    int       `json:"offset"`
}

// ConvertGetReviewRequestToGRPC преобразует dto.GetReviewRequest в gen.GetReviewsRequest
func ConvertGetReviewRequestToGRPC(dtoReq GetReviewRequest) *review.GetReviewsRequest <span class="cov0" title="0">{
        return &amp;review.GetReviewsRequest{
                ProductId: dtoReq.ProductID.String(),
                Offset:    int32(dtoReq.Offset),
        }
}</span>

type ReviewDTO struct {
        ID       uuid.UUID `json:"id"`
        Name     string    `json:"name"`
        Surname  null.String    `json:"surname"`
        ImageURL null.String    `json:"imageURL"`
        Rating   int       `json:"rating"`
        Comment  string    `json:"comment"`
}

type ReviewsResponse struct {
        Reviews []ReviewDTO `json:"reviews"`
}

func ConvertToReviewDTO(review *models.Review) ReviewDTO <span class="cov0" title="0">{
        return ReviewDTO{
                ID:            review.ID,
                Name:          review.Name,
                Surname:       review.Surname,
                ImageURL:      review.ImageURL,
                Rating:        review.Rating,
                Comment:       review.Comment,
        }
}</span>

func ConvertToReviewsResponse(reviews []*models.Review) ReviewsResponse <span class="cov0" title="0">{
        briefreviews := make([]ReviewDTO, 0, len(reviews))
        for _, review := range reviews </span><span class="cov0" title="0">{
                briefreviews = append(briefreviews, ConvertToReviewDTO(review))
        }</span>

        <span class="cov0" title="0">return ReviewsResponse{
                Reviews: briefreviews,
        }</span>
}

// ConvertReviewsResponseToProto преобразует dto.ReviewsResponse в gen.GetReviewsResponse
func ModelsToGRPC(dtoResp []*models.Review) *review.GetReviewsResponse <span class="cov0" title="0">{
        protoResp := &amp;review.GetReviewsResponse{
                Reviews: make([]*review.Review, 0, len(dtoResp)),
        }

        for _, dtoReview := range dtoResp </span><span class="cov0" title="0">{
                var surname string
                if dtoReview.Surname.Valid </span><span class="cov0" title="0">{
                        surname = dtoReview.Surname.String
                }</span>

                <span class="cov0" title="0">var imageURL string
                if dtoReview.ImageURL.Valid </span><span class="cov0" title="0">{
                        imageURL = dtoReview.ImageURL.String
                }</span>

                <span class="cov0" title="0">protoReview := &amp;review.Review{
                        Id:       dtoReview.ID.String(),
                        Name:     dtoReview.Name,
                        Surname:  surname,
                        ImageUrl: imageURL,
                        Rating:   int32(dtoReview.Rating),
                        Comment:  dtoReview.Comment,
                }
                protoResp.Reviews = append(protoResp.Reviews, protoReview)</span>
        }

        <span class="cov0" title="0">return protoResp</span>
}

// ConvertProtoToReviewsResponse преобразует gen.GetReviewsResponse в dto.ReviewsResponse
func ConvertGRPCToReviewsResponse(protoResp *review.GetReviewsResponse) ReviewsResponse <span class="cov0" title="0">{
        dtoResp := ReviewsResponse{
                Reviews: make([]ReviewDTO, 0, len(protoResp.GetReviews())),
        }

        for _, protoReview := range protoResp.GetReviews() </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(protoReview.GetId())

                var surname null.String
                if protoReview.Surname != "" </span><span class="cov0" title="0">{
                        surname = null.StringFrom(protoReview.Surname)
                }</span>

                <span class="cov0" title="0">var imageURL null.String
                if protoReview.ImageUrl != "" </span><span class="cov0" title="0">{
                        imageURL = null.StringFrom(protoReview.ImageUrl)
                }</span>
                
                <span class="cov0" title="0">dtoReview := ReviewDTO{
                        ID:       id,
                        Name:     protoReview.GetName(),
                        Surname:  surname,
                        ImageURL: imageURL,
                        Rating:   int(protoReview.GetRating()),
                        Comment:  protoReview.GetComment(),
                }
                dtoResp.Reviews = append(dtoResp.Reviews, dtoReview)</span>
        }

        <span class="cov0" title="0">return dtoResp</span>
}</pre>
		
		<pre class="file" id="file38" style="display: none">package dto

import (
        "github.com/google/uuid"
        "github.com/guregu/null"
        "google.golang.org/protobuf/types/known/wrapperspb"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/user"
)

type UserDTO struct {
        ID          uuid.UUID   `json:"id"`
        Email       string      `json:"email"`
        Name        string      `json:"name"`
        Surname     null.String `json:"surname" swaggertype:"primitive,string"`
        ImageURL    null.String `json:"imageURL" swaggertype:"primitive,string"`
        PhoneNumber null.String `json:"phoneNumber,omitempty" swaggertype:"primitive,string"`
        Role        string      `json:"role"`
}

type UpdateRoleRequest struct {
        Title string             `json:"title"`
        Description string `json:"description"`
}

type UpdateUserProfileRequestDTO struct {
        Name        null.String `json:"name,omitempty" swaggertype:"primitive,string"`
        Surname     null.String `json:"surname,omitempty" swaggertype:"primitive,string"`
        PhoneNumber null.String `json:"phoneNumber,omitempty" swaggertype:"primitive,string"`
}

type UpdateUserEmailDTO struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

type UpdateUserPasswordDTO struct {
        OldPassword string `json:"OldPassword"`
        NewPassword string `json:"NewPassword"`
}

func (u *UserDTO) ConvertToGrpcUser() *gen.User <span class="cov0" title="0">{
        var surname *wrapperspb.StringValue
        if u.Surname.Valid </span><span class="cov0" title="0">{
                surname = wrapperspb.String(u.Surname.String)
        }</span>

        <span class="cov0" title="0">var imageURL *wrapperspb.StringValue
        if u.ImageURL.Valid </span><span class="cov0" title="0">{
                imageURL = wrapperspb.String(u.ImageURL.String)
        }</span>

        <span class="cov0" title="0">var phoneNumber *wrapperspb.StringValue
        if u.PhoneNumber.Valid </span><span class="cov0" title="0">{
                phoneNumber = wrapperspb.String(u.PhoneNumber.String)
        }</span>

        <span class="cov0" title="0">return &amp;gen.User{
                Id:          u.ID.String(),
                Email:       u.Email,
                Name:        u.Name,
                Surname:     surname,
                ImageURL:    imageURL,
                PhoneNumber: phoneNumber,
                Role:        u.Role,
        }</span>
}

func ConvertGrpcToUserDTO(u *gen.User) (*UserDTO, error) <span class="cov0" title="0">{
        id, err := uuid.Parse(u.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var surname null.String
        if u.Surname != nil </span><span class="cov0" title="0">{
                surname = null.StringFrom(u.Surname.Value)
        }</span>

        <span class="cov0" title="0">var imageURL null.String
        if u.ImageURL != nil </span><span class="cov0" title="0">{
                imageURL = null.StringFrom(u.ImageURL.Value)
        }</span>

        <span class="cov0" title="0">var phoneNumber null.String
        if u.PhoneNumber != nil </span><span class="cov0" title="0">{
                phoneNumber = null.StringFrom(u.PhoneNumber.Value)
        }</span>

        <span class="cov0" title="0">return &amp;UserDTO{
                ID:          id,
                Email:       u.Email,
                Name:        u.Name,
                Surname:     surname,
                ImageURL:    imageURL,
                PhoneNumber: phoneNumber,
                Role:        u.Role,
        }, nil</span>
}

func (u *UpdateUserProfileRequestDTO) ConvertToGrpcUpdateProfileReq() *gen.UpdateUserProfileRequest <span class="cov0" title="0">{
        var name *wrapperspb.StringValue
        if u.Name.Valid </span><span class="cov0" title="0">{
                name = wrapperspb.String(u.Name.String)
        }</span>

        <span class="cov0" title="0">var surname *wrapperspb.StringValue
        if u.Surname.Valid </span><span class="cov0" title="0">{
                surname = wrapperspb.String(u.Surname.String)
        }</span>

        <span class="cov0" title="0">var phoneNumber *wrapperspb.StringValue
        if u.PhoneNumber.Valid </span><span class="cov0" title="0">{
                phoneNumber = wrapperspb.String(u.PhoneNumber.String)
        }</span>

        <span class="cov0" title="0">return &amp;gen.UpdateUserProfileRequest{
                Name:        name,
                Surname:     surname,
                PhoneNumber: phoneNumber,
        }</span>
}</pre>
		
		<pre class="file" id="file39" style="display: none">package jwt

import (
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/golang-jwt/jwt/v4"
)

// JWTClaims структура для данных токена
type JWTClaims struct {
        UserID    string
        Version   int
        ExpiresAt int64
        Role      string
        jwt.StandardClaims
}

// Tokenator структура для создания и парсинга токенов
type Tokenator struct {
        sign          string
        tokenLifeSpan time.Duration
}

// NewTokenator создает новый экземпляр Tokenator
func NewTokenator(conf *config.JWTConfig) *Tokenator <span class="cov0" title="0">{
        return &amp;Tokenator{
                sign:          conf.Signature,
                tokenLifeSpan: conf.TokenLifeSpan,
        }
}</span>

// CreateJWT генерирует JWT токен для заданного userID и version
func (t *Tokenator) CreateJWT(userID string, role string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiration := now.Add(t.tokenLifeSpan)

        claims := JWTClaims{
                UserID:    userID,
                ExpiresAt: expiration.Unix(),
                Role:      role,
                StandardClaims: jwt.StandardClaims{
                        IssuedAt:  now.Unix(),
                        ExpiresAt: expiration.Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(t.sign))
}</span>

// ParseJWT парсит и валидирует JWT-токен
func (t *Tokenator) ParseJWT(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{

        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Проверяем, что метод подписи соответствует HMAC
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("unexpected signing method")
                }</span>

                <span class="cov0" title="0">return []byte(t.sign), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse jwt: %w", err)
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errs.ErrInvalidToken</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
)

func CORSMiddleware(next http.Handler, conf *config.ServerConfig) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                origin := r.Header.Get("Origin")

                if origin == "" </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Methods", conf.AllowMethods)
                w.Header().Set("Access-Control-Allow-Headers", conf.AllowHeaders)
                w.Header().Set("Access-Control-Allow-Credentials", conf.AllowCredentials)
                w.Header().Set("Access-Control-Allow-Origin", conf.AllowOrigin)

                allowedOrigin := conf.AllowOrigin
                //allowedOrigin := "*"

                if allowedOrigin != "*" &amp;&amp; allowedOrigin != origin </span><span class="cov0" title="0">{
                        http.Error(w, "CORS Origin not allowed", http.StatusForbidden)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package middleware

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
)

const (
        CSRFTokenHeader = "X-CSRF-Token"
)

func CSRFMiddleware(tokenator *jwt.Tokenator, next http.Handler, cfg *config.CSRFConfig) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet || r.Method == http.MethodHead || r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                //FIXME: вернуть
                // jwtCookie, err := r.Cookie(string(domains.TokenCookieName))
                // if err != nil {
                //         http.Error(w, "JWT token required", http.StatusForbidden)
                //         return
                // }
                // jwtToken := jwtCookie.Value
                
                // token := r.Header.Get(CSRFTokenHeader)
                // if token == "" {
                //         http.Error(w, "CSRF token missing", http.StatusForbidden)
                //         return
                // }
                
                // valid, err := CheckCSRFToken(jwtToken, token, cfg.SecretKey)
                // if err != nil || !valid {
                //         http.Error(w, "Invalid CSRF token", http.StatusForbidden)
                //         return
                // }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func CheckCSRFToken(tokenJWT string, tokenCSRF string, secretKey string) (bool, error) <span class="cov0" title="0">{
        csrfData := strings.Split(tokenCSRF, ":")
        if len(csrfData) != 2 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("bad tokenJWT data")
        }</span>

        <span class="cov0" title="0">csrfExp, err := strconv.ParseInt(csrfData[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("bad tokenJWT time")
        }</span>

        <span class="cov0" title="0">if csrfExp &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("tokenJWT expired")
        }</span>

        <span class="cov0" title="0">h := hmac.New(sha256.New, []byte(secretKey))
        data := fmt.Sprintf("%s:%d", tokenJWT, csrfExp)
        h.Write([]byte(data))
        expectedMAC := h.Sum(nil)
        messageMAC, err := hex.DecodeString(csrfData[0])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot hex decode tokenJWT")
        }</span>

        <span class="cov0" title="0">return hmac.Equal(messageMAC, expectedMAC), nil</span>
}

func GenerateCSRFToken(tokenJWT string, secretKey string, tokenExpiry time.Duration) (string, error) <span class="cov0" title="0">{
        expiry := time.Now().Add(tokenExpiry).Unix()

        h := hmac.New(sha256.New, []byte(secretKey))
        data := fmt.Sprintf("%s:%d", tokenJWT, expiry)
        h.Write([]byte(data))
        mac := hex.EncodeToString(h.Sum(nil))

        return fmt.Sprintf("%s:%d", mac, expiry), nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package grpc

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/google/uuid"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// UserIDInterceptor для обычных (unary) gRPC вызовов
func UserIDInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                newCtx, err := extractUserID(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(newCtx, req)</span>
        }
}

// UserIDStreamInterceptor для потоковых (stream) gRPC вызовов
func UserIDStreamInterceptor() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                newCtx, err := extractUserID(ss.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">wrappedStream := &amp;wrappedStream{
                        ServerStream: ss,
                        ctx:         newCtx,
                }
                return handler(srv, wrappedStream)</span>
        }
}

// Обертка для ServerStream с измененным контекстом
type wrappedStream struct {
        grpc.ServerStream
        ctx context.Context
}

func (w *wrappedStream) Context() context.Context <span class="cov0" title="0">{
        return w.ctx
}</span>

// extractUserID извлекает userID из метаданных и добавляет в контекст
func extractUserID(ctx context.Context) (context.Context, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        <span class="cov0" title="0">userIDs := md.Get("user-id")
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDs[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid user-id format")
        }</span>

        <span class="cov0" title="0">if roles := md.Get("role"); len(roles) &gt; 0 </span><span class="cov0" title="0">{
        ctx = context.WithValue(ctx, domains.RoleKey{}, roles[0])
    }</span>

        <span class="cov0" title="0">return context.WithValue(ctx, domains.UserIDKey{}, userID.String()), nil</span>
}</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/auth"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/sirupsen/logrus"
        "google.golang.org/grpc/metadata"
)

// JWTMiddleware проверяет наличие и валидность JWT-токена в куках
func JWTMiddleware(authClient gen.AuthServiceClient, tokenator *jwt.Tokenator, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Получаем request_id из контекста
                reqID := ctx.Value(domains.ReqIDKey{})
                if reqID == nil </span><span class="cov0" title="0">{
                        reqID = "unknown"
                }</span>

                // Логирование с request_id и remote_addr
                <span class="cov0" title="0">requestLogger := logrus.WithFields(logrus.Fields{
                        "request_id":  reqID,
                        "remote_addr": r.RemoteAddr,
                        "path":        r.URL.Path,
                })

                cookieValue, err := r.Cookie(string(domains.TokenCookieName))
                if err != nil </span><span class="cov0" title="0">{
                        requestLogger.Warn("Missing or invalid token cookie")
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                // Получаем токен из куки
                <span class="cov0" title="0">tokenString := cookieValue.Value

                // Если токен пустой, возвращаем ошибку
                if tokenString == "" </span><span class="cov0" title="0">{
                        requestLogger.WithFields(logrus.Fields{
                                "method": r.Method,
                                "path":   r.URL.Path,
                                "ip":     r.RemoteAddr,
                        }).Warn("Empty token")
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                // Вызываем gRPC метод CheckToken для проверки токена
                <span class="cov0" title="0">checkResp, err := authClient.CheckToken(ctx, &amp;gen.CheckTokenReq{
                        Token: tokenString,
                })
                if err != nil </span><span class="cov0" title="0">{
                        requestLogger.WithError(err).Error("Failed to check token via gRPC")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Invalid token")
                        return
                }</span>

                <span class="cov0" title="0">if !checkResp.Valid </span><span class="cov0" title="0">{
                        requestLogger.Warn("Token is not valid")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Invalid token")
                        return
                }</span>

                // Дополнительно парсим токен для получения claims (если нужно)
                <span class="cov0" title="0">claims, err := tokenator.ParseJWT(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        requestLogger.WithError(err).Error("Failed to parse token after gRPC validation")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Invalid token")
                        return
                }</span>

                // Проверяем, не истёк ли токен
                <span class="cov0" title="0">if claims.ExpiresAt &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        requestLogger.Warn("Token expired")
                        response.SendJSONError(ctx, w, http.StatusUnauthorized, "Token expired")
                        return
                }</span>

                // Передаем userID и role в контекст
                <span class="cov0" title="0">ctx = context.WithValue(ctx, domains.UserIDKey{}, claims.UserID)
                ctx = context.WithValue(ctx, domains.RoleKey{}, claims.Role)

                // Добавляем user-id в метаданные для gRPC
                ctx = metadata.AppendToOutgoingContext(ctx, 
                        "user-id", claims.UserID,
                        "role", claims.Role,  // &lt;- Добавьте эту строку
                )
                
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package logctx

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"

        "github.com/sirupsen/logrus"
)

func WithLogger(ctx context.Context, logger *logrus.Entry) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, domains.LoggerKey{}, logger)
}</span>

func GetLogger(ctx context.Context) *logrus.Entry <span class="cov8" title="1">{
        if logger, ok := ctx.Value(domains.LoggerKey{}).(*logrus.Entry); ok </span><span class="cov8" title="1">{
                return logger
        }</span>

        <span class="cov8" title="1">return logrus.NewEntry(logrus.New())</span>
}</pre>
		
		<pre class="file" id="file45" style="display: none">package middleware

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "math/rand"
        "net/http"
        "time"

        "github.com/sirupsen/logrus"
)

func LogRequest(logger *logrus.Logger, next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                rand.Seed(time.Now().UnixNano())
                reqID := fmt.Sprintf("%016x", rand.Int())[:10]

                ctx := context.WithValue(r.Context(), domains.ReqIDKey{}, reqID)

                middlewareLogger := logger.WithFields(logrus.Fields{
                        "request_id":  reqID,
                        "method":      r.Method,
                        "remote_addr": r.RemoteAddr,
                        "path":        r.URL.Path,
                })

                // Логгер для передачи в контекст (только request_id)
                contextLogger := logrus.NewEntry(logger).WithField("request_id", reqID) // Важно: создаём новый Entry
                ctx = logctx.WithLogger(ctx, contextLogger)

                middlewareLogger.Info("request started")

                startTime := time.Now()

                defer func() </span><span class="cov8" title="1">{
                        duration := time.Since(startTime)
                        middlewareLogger.WithField("duration", duration).Info("request completed")
                }</span>()

                <span class="cov8" title="1">next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package middleware

import (
        "fmt"
        "github.com/prometheus/client_golang/prometheus"
        "golang.org/x/net/context"
        "google.golang.org/grpc"
        "math/rand"
        "net/http"
        "regexp"
        "time"
)

const (
        ServiceMainName   = "bazaar_app"
        ServiceAuthName   = "auth_service"
        ServiceUserName   = "user_service"
        ServiceReviewName = "review_service"
)

var (
        UUIDRegExp = regexp.MustCompile(`[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}`)
)

const (
        ServiceName = "ServiceName"
        URL         = "Url"
        Method      = "Method"
        StatusCode  = "StatusCode"
)

type writer struct {
        http.ResponseWriter
        statusCode int
}

func NewWriter(w http.ResponseWriter) *writer <span class="cov0" title="0">{
        return &amp;writer{w, http.StatusOK}
}</span>

func (w *writer) WriteHeader(code int) <span class="cov0" title="0">{
        w.statusCode = code
        w.ResponseWriter.WriteHeader(code)
}</span>

type MetricsMiddleware struct {
        metric      *prometheus.GaugeVec
        counter     *prometheus.CounterVec
        durations   *prometheus.HistogramVec
        errors      *prometheus.CounterVec
        durationNew *prometheus.SummaryVec
        name        string
}

func NewMetricsMiddleware() *MetricsMiddleware <span class="cov0" title="0">{
        return &amp;MetricsMiddleware{}
}</span>

func (m *MetricsMiddleware) ServerMetricsInterceptor(ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{

        start := time.Now()
        h, err := handler(ctx, req)
        tm := time.Since(start)

        labels := prometheus.Labels{
                ServiceName: m.name,
                URL:         info.FullMethod,
                Method:      "GRPC",
                StatusCode:  "OK",
        }

        m.metric.With(labels).Inc()
        m.durations.With(labels).Observe(tm.Seconds())
        m.counter.With(labels).Inc()

        if err != nil </span><span class="cov0" title="0">{
                m.errors.With(labels).Inc()
        }</span>

        <span class="cov0" title="0">return h, err</span>
}

func (m *MetricsMiddleware) Register(name string) <span class="cov0" title="0">{
        m.name = name

        labels := []string{ServiceName, URL, Method, StatusCode}

        m.metric = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: name + "_requests_total",
                        Help: fmt.Sprintf("Total requests for service %s", name),
                },
                labels,
        )

        m.counter = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: name + "_counter_total",
                        Help: "Counter of all requests.",
                },
                labels,
        )

        m.durations = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    name + "_duration_seconds",
                        Help:    "Request duration distribution.",
                        Buckets: prometheus.ExponentialBuckets(0.001, 2, 15), // 1ms -&gt; ~16s
                },
                labels,
        )

        m.errors = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: name + "_errors_total",
                        Help: "Counter of errors.",
                },
                labels,
        )

        m.durationNew = prometheus.NewSummaryVec(
                prometheus.SummaryOpts{
                        Name:       name + "_duration_summary_seconds",
                        Help:       "Summary of request durations.",
                        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
                },
                labels,
        )

        rand.Seed(time.Now().Unix())

        prometheus.MustRegister(m.metric)
        prometheus.MustRegister(m.counter)
        prometheus.MustRegister(m.durations)
        prometheus.MustRegister(m.errors)
        prometheus.MustRegister(m.durationNew)
}</span>

func (m *MetricsMiddleware) LogMetrics(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                wrapper := NewWriter(w)

                next.ServeHTTP(wrapper, r)

                tm := time.Since(start)

                urlWithCuttedUUID := UUIDRegExp.ReplaceAllString(r.URL.Path, "&lt;uuid&gt;")

                labels := prometheus.Labels{
                        ServiceName: m.name,
                        URL:         urlWithCuttedUUID,
                        Method:      r.Method,
                        StatusCode:  fmt.Sprintf("%d", wrapper.statusCode),
                }

                m.metric.With(labels).Inc()
                m.counter.With(labels).Inc()
                m.durations.With(labels).Observe(tm.Seconds())
                m.durationNew.With(labels).Observe(tm.Seconds())

                if wrapper.statusCode != http.StatusOK </span><span class="cov0" title="0">{
                        m.errors.With(labels).Inc()
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package middleware

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/sirupsen/logrus"
)

// RoleMiddleware создает middleware для проверки роли
func RoleMiddleware(allowedRoles ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := r.Context()
                        logger := logctx.GetLogger(ctx)

                        // Получаем роль из контекста
                        role, ok := ctx.Value(domains.RoleKey{}).(string)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Role not found in context")
                                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "Role not found in context")
                                return
                        }</span>

                        <span class="cov0" title="0">for _, allowedRole := range allowedRoles </span><span class="cov0" title="0">{
                if role == allowedRole </span><span class="cov0" title="0">{
                    next.ServeHTTP(w, r)
                    return
                }</span>
            }

            <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "required_roles": allowedRoles,
                "user_role":      role,
                "path":           r.URL.Path,
            }).Warn("Access denied")
            
            response.SendJSONError(ctx, w, http.StatusForbidden, "Insufficient permissions")</span>
                })
        }
}</pre>
		
		<pre class="file" id="file48" style="display: none">package order

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/order"
        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

type OrderService struct {
        u order.IOrderUsecase
}

func NewOrderService(
        u order.IOrderUsecase,
) *OrderService <span class="cov0" title="0">{
        return &amp;OrderService{
                u: u,
        }
}</span>

// CreateOrder godoc
//
//        @Summary                Создать новый заказ
//        @Description        Создает новый заказ для текущего пользователя
//        @Tags                        order
//        @Accept                        json
//        @Produce                json
//        @Param                        orderData                body        dto.CreateOrderDTO        true        "Данные для создания заказа"
//        @Param                        X-Csrf-Token        header        string                                true        "CSRF-токен для защиты от подделки запросов"
//        @Success                200                                "Заказ успешно создан"
//        @Failure                400                                {object}        object        "Некорректные данные"
//        @Failure                401                                {object}        object        "Пользователь не авторизован"
//        @Failure                404                                {object}        object        "Ошибка при создании заказа"
//        @Failure                500                                {object}        object        "Внутренняя ошибка сервера"
//        @Security                TokenAuth
//        @Router                        /orders [post]
func (o *OrderService) CreateOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "OrderService.CreateOrder"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        userIDStr, isExist := r.Context().Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov0" title="0">{
                logger.Error("user not found in context")
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "user not found in context")
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("user_id", userIDStr).Error("invalid user id format")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid user id format")
                return
        }</span>

        <span class="cov0" title="0">var createOrderReq dto.CreateOrderDTO
        if err := request.ParseData(r, &amp;createOrderReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := validator.ValidateCreateOrderDTO(createOrderReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("invalid order data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">createOrderReq.UserID = userID
        logger = logger.WithFields(logrus.Fields{
                "user_id": userID,
                "order":   createOrderReq,
        })
        if err = o.u.CreateOrder(r.Context(), createOrderReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create order")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

// GetOrders godoc
//
//        @Summary                Получить список заказов
//        @Description        Возвращает список всех заказов текущего пользователя
//        @Tags                        order
//        @Produce                json
//        @Success                200        {object}        map[string][]dto.OrderPreviewDTO        "Список заказов"
//        @Failure                400        {object}        object                                                                "Некорректный ID пользователя"
//        @Failure                401        {object}        object                                                                "Пользователь не авторизован"
//        @Failure                500        {object}        object                                                                "Внутренняя ошибка сервера"
//        @Security                TokenAuth
//        @Router                        /orders [get]
func (o *OrderService) GetOrders(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "OrderService.GetOrders"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        userIDStr, isExist := r.Context().Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov0" title="0">{
                logger.Error("user id not found in context")
                response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "user id not found in context")
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("user_id", userIDStr).Error("invalid user id format")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid user id format")
                return
        }</span>

        <span class="cov0" title="0">logger = logger.WithField("user_id", userID)
        orders, err := o.u.GetUserOrders(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get user orders")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, map[string]*[]dto.OrderPreviewDTO{
                "orders": orders,
        })</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package product

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
)

//go:generate mockgen -source=product.go -destination=../../usecase/mocks/product_usecase_mock.go -package=mocks IProductUsecase
type IProductUsecase interface {
        GetAllProducts(ctx context.Context, offset int) ([]*models.Product, error)
        GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error)
        GetProductsByIDs(ctx context.Context, ids []uuid.UUID) ([]*models.Product, error)
        GetProductsByCategory(
                ctx context.Context, 
                id uuid.UUID, 
                offset int,
                minPrice, maxPrice float64,
                minRating float32,
                sortOption models.SortOption,
        ) ([]*models.Product, error)
        AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error)
}

type ProductService struct {
        u            IProductUsecase
        minioService minio.Provider
}

func NewProductService(u IProductUsecase, ms minio.Provider) *ProductService <span class="cov8" title="1">{
        return &amp;ProductService{
                u:            u,
                minioService: ms,
        }
}</span>

// GetAllProducts godoc
//
//        @Summary                Получить все продукты
//        @Description        Возвращает список всех доступных продуктов
//        @Tags                        products
//        @Produce                json
//        @Success                200        {array}                models.Product
//        @Failure                500        {object}        object
//        @Router                        /products [get]
func (h *ProductService) GetAllProducts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.GetAllProducts"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        offsetStr := vars["offset"]
        offset := 0
        var err error
    if offsetStr != "" </span><span class="cov8" title="1">{
        offset, err = strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
            response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
            return
        }</span>
    }

        <span class="cov8" title="1">products, err := h.u.GetAllProducts(r.Context(), offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get all products")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">productResponse := dto.ConvertToProductsResponse(products)

        response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

// GetProductByID godoc
//
//        @Summary                Получить продукт по ID
//        @Description        Возвращает детальную информацию о продукте по его ID
//        @Tags                        products
//        @Produce                json
//        @Param                        id        path                string        true        "UUID продукта"
//        @Success                200        {object}        models.Product
//        @Failure                400        {object}        object        "Некорректный формат UUID"
//        @Failure                404        {object}        object        "Продукт не найден"
//        @Router                        /products/{id} [get]
func (h *ProductService) GetProductByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.GetProductByID"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).WithField("product_id", idStr).Error("parse product ID")
                response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
                return
        }</span>

        <span class="cov8" title="1">logger = logger.WithField("product_id", id)
        product, err := h.u.GetProductByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get product by ID")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, product)</span>
}

// CreateOne godoc
//
//        @Summary                Загрузить изображение товара
//        @Description        Загружает изображение товара в хранилище MinIO
//        @Tags                        products
//        @Accept                        multipart/form-data
//        @Produce                json
//        @Param                        file        formData        file                                true        "Изображение товара"
//        @Success                200                {object}        map[string]string        "URL загруженного изображения"
//        @Failure                400                {object}        object                                "Ошибка в данных запроса"
//        @Failure                500                {object}        object
//        @Router                        /products/upload [post]
func (h *ProductService) CreateOne(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "ProductService.CreateOne"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Проверяем, что запрос содержит multipart/form-data
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse multipart form")
                response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
                return
        }</span>

        // Получаем файл из формы
        <span class="cov8" title="1">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get file from form")
                response.HandleDomainError(r.Context(), w, fmt.Errorf("no file uploaded"), op)
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Читаем содержимое файла
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("read file content")
                response.HandleDomainError(r.Context(), w, fmt.Errorf("failed to read file"), op)
                return
        }</span>

        // Создаем структуру для MinIO
        <span class="cov8" title="1">fileData := minio.FileData{
                Name: header.Filename,
                Data: fileBytes,
        }

        // Загружаем файл в MinIO
        productResponse, err := h.minioService.CreateOne(r.Context(), fileData)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("upload file to minio")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        // Возвращаем успешный ответ с URL файла
        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

// GetProductsByIDs godoc
//
//        @Summary                Получить товары по списку ID
//        @Description        Возвращает список товаров по переданным идентификаторам
//        @Tags                        products
//        @Accept                        json
//        @Produce                json
//        @Param                        request                        body                dto.GetProductsByIDRequest        true        "Список ID товаров"
//        @Param                        X-Csrf-Token        header                string                                                true        "CSRF-токен для защиты от подделки запросов"
//        @Success                200                                {array}                dto.ProductsResponse
//        @Failure                400                                {object}        object        "Некорректные данные"
//        @Failure                500                                {object}        object
//        @Router                        /products/batch [post]
func (p *ProductService) GetProductsByIDs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req dto.GetProductsByIDRequest
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if len(req.ProductIDs) == 0 </span><span class="cov8" title="1">{
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "at least one product ID is required")
                return
        }</span>

        <span class="cov8" title="1">products, err := p.u.GetProductsByIDs(r.Context(), req.ProductIDs)
        if err != nil </span><span class="cov0" title="0">{
                response.HandleDomainError(r.Context(), w, err, "failed to get products by IDs")
                return
        }</span>

        <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusOK, dto.ConvertToProductsResponse(products))</span>
}


func (h *ProductService) GetProductsByCategory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
    const op = "ProductService.GetProductsByCategoryWithFilterAndSort"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    // Парсинг ID категории
    vars := mux.Vars(r)
    idStr := vars["id"]
    id, err := uuid.Parse(idStr)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).WithField("category_id", idStr).Error("parse category ID")
        response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
        return
    }</span>

    // Парсинг offset
    <span class="cov8" title="1">offsetStr := vars["offset"]
        offset := 0
    if offsetStr != "" </span><span class="cov0" title="0">{
        offset, err = strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
            response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
            return
        }</span>
    }

    // Парсинг фильтров
    <span class="cov8" title="1">minPrice, _ := strconv.ParseFloat(r.URL.Query().Get("min_price"), 64)
    maxPrice, _ := strconv.ParseFloat(r.URL.Query().Get("max_price"), 64)
    minRating, _ := strconv.ParseFloat(r.URL.Query().Get("min_rating"), 32)

    // Парсинг параметра сортировки
    sortOption := models.SortOption(r.URL.Query().Get("sort"))
    switch sortOption </span>{
    case models.SortByPriceAsc, models.SortByPriceDesc, models.SortByRatingAsc, models.SortByRatingDesc, models.SortByDefault:<span class="cov8" title="1"></span>
        // допустимые значения
    default:<span class="cov0" title="0">
        sortOption = models.SortByDefault</span>
    }

    <span class="cov8" title="1">products, err := h.u.GetProductsByCategory(
        r.Context(), 
        id, 
        offset,
        minPrice,
        maxPrice,
        float32(minRating),
        sortOption,
    )
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get products by category with filter and sort")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov8" title="1">productResponse := dto.ConvertToProductsResponse(products)
    response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

func (p *ProductService) AddProduct(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
    const op = "ProductService.AddProduct"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    var req dto.AddProductRequest
    if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse request data")
        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
        return
    }</span>

    // Парсим UUID категории
    <span class="cov8" title="1">categoryID, err := uuid.Parse(req.Category)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("parse category ID")
        response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
        return
    }</span>

    // Парсим UUID продавца
    <span class="cov8" title="1">sellerID, err := uuid.Parse(req.SellerID)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("parse seller ID")
        response.HandleDomainError(r.Context(), w, errs.ErrInvalidID, op)
        return
    }</span>

        <span class="cov8" title="1">product := &amp;models.Product{
        SellerID:        sellerID,
        Name:           req.Name,
        PreviewImageURL: req.PreviewImageURL,
        Description:    req.Description,
        Price:          req.Price,
        PriceDiscount:   req.PriceDiscount,
        Quantity:       req.Quantity,
        Rating:         req.Rating,
        ReviewsCount:   req.ReviewsCount,
    }

    newProduct, err := p.u.AddProduct(r.Context(), product, categoryID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("add product")
        response.HandleDomainError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov8" title="1">response.SendJSONResponse(r.Context(), w, http.StatusCreated, newProduct)</span>
}</pre>
		
		<pre class="file" id="file50" style="display: none">package review

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/review"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/review"
        "github.com/google/uuid"
)

type ReviewGRPCServer struct {
        gen.UnimplementedReviewServiceServer
        reviewUsecase review.IReviewUsecase
}

func NewReviewGRPCServer (u review.IReviewUsecase) *ReviewGRPCServer <span class="cov0" title="0">{
        return &amp;ReviewGRPCServer{
                reviewUsecase: u,
        }
}</span>

func (s *ReviewGRPCServer) AddReview (ctx context.Context, req *gen.AddReviewRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        const op = "ReviewGRPCServer.AddReview"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        productID, err := uuid.Parse(req.ProductId)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("invalid prouct ID format")
                return &amp;gen.EmptyResponse{}, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov0" title="0">rating := req.Rating
        if 1 &lt; rating &amp;&amp; rating &gt; 5 </span><span class="cov0" title="0">{
                logger.Error("invalid rating")
                return &amp;gen.EmptyResponse{}, fmt.Errorf("%s: %w", op, errs.NewBusinessLogicError("invalid rating"))
        }</span>

        <span class="cov0" title="0">request := dto.AddReviewRequest {
                ProductID: productID,
                Rating: int(rating),
                Comment: req.Comment,
        }

        err = s.reviewUsecase.Add(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("add review")
                return &amp;gen.EmptyResponse{}, fmt.Errorf("%s: %w", op, errs.NewBusinessLogicError("failed add"))
        }</span>

        <span class="cov0" title="0">return &amp;gen.EmptyResponse{}, nil</span>
}

func (s *ReviewGRPCServer) GetReviews (ctx context.Context, req *gen.GetReviewsRequest) (*gen.GetReviewsResponse, error) <span class="cov0" title="0">{
        const op = "ReviewGRPCServer.GetReviews"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        productID, err := uuid.Parse(req.ProductId)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("invalid product ID format")
                return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov0" title="0">request := dto.GetReviewRequest {
                ProductID: productID,
                Offset: int(req.Offset),
        }

        reviews, err := s.reviewUsecase.Get(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get reviews")
                return nil, fmt.Errorf("%s: %w", op, errs.NewBusinessLogicError("get reviews"))
        }</span>

        <span class="cov0" title="0">return dto.ModelsToGRPC(reviews), nil</span>
}</pre>
		
		<pre class="file" id="file51" style="display: none">package review

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/review"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
)

type ReviewHandler struct {
        reviewClient gen.ReviewServiceClient
}

func NewReviewHandler(rc gen.ReviewServiceClient) *ReviewHandler<span class="cov0" title="0">{
        return &amp;ReviewHandler{
                reviewClient: rc,
        }
}</span>

func (h *ReviewHandler) Add(w http.ResponseWriter, r *http.Request)<span class="cov0" title="0">{
        const op = "ReviewHandler.Add"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var addReq dto.AddReviewRequest
        if err := request.ParseData(r, &amp;addReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">_, err := h.reviewClient.AddReview(r.Context(), dto.ConvertAddReviewRequestToGRPC(addReq))
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                logger.Error("add review")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusCreated, nil)</span>
}

func (h *ReviewHandler) Get(w http.ResponseWriter, r *http.Request)<span class="cov0" title="0">{
        const op = "ReviewHandler.Get"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var getReq dto.GetReviewRequest
        if err := request.ParseData(r, &amp;getReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">reviews, err := h.reviewClient.GetReviews(r.Context(), dto.ConvertGetReviewRequestToGRPC(getReq))
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                logger.Error("get review")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, dto.ConvertGRPCToReviewsResponse(reviews))</span>
}</pre>
		
		<pre class="file" id="file52" style="display: none">package search

import (
        "context"
        "github.com/guregu/null"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/suggestions"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/gorilla/mux"
)

//go:generate mockgen -source=search.go -destination=../../usecase/mocks/search_usecase_mock.go -package=mocks ISearchUsecase
type ISearchUsecase interface {
        SearchCategoryByName(context.Context, dto.CategoryNameResponse) ([]*models.Category, error)
        SearchProductsByNameWithFilterAndSort(
                ctx context.Context,
                categoryID null.String,
                subString string,
                offset int,
                minPrice, maxPrice float64,
                minRating float32,
                sortOption models.SortOption,
        ) ([]*models.Product, error)
}

type SearchService struct {
        u ISearchUsecase
        s suggestions.ISuggestionsUsecase
}

func NewSearchService(u ISearchUsecase, s suggestions.ISuggestionsUsecase) *SearchService <span class="cov0" title="0">{
        return &amp;SearchService{
                u: u,
                s: s,
        }
}</span>

func (h *SearchService) SearchWithFilterAndSort(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "SearchService.SearchWithFilterAndSort"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Парсинг offset
        vars := mux.Vars(r)
        offsetStr := vars["offset"]
        offset := 0
        var err error
        if offsetStr != "" </span><span class="cov0" title="0">{
                offset, err = strconv.Atoi(offsetStr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
                        response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
                        return
                }</span>
        }

        // Парсинг фильтров
        <span class="cov0" title="0">minPrice, _ := strconv.ParseFloat(r.URL.Query().Get("min_price"), 64)
        maxPrice, _ := strconv.ParseFloat(r.URL.Query().Get("max_price"), 64)
        minRating, _ := strconv.ParseFloat(r.URL.Query().Get("min_rating"), 32)

        // Парсинг параметра сортировки
        sortOption := models.SortOption(r.URL.Query().Get("sort"))
        switch sortOption </span>{
        case models.SortByPriceAsc, models.SortByPriceDesc, models.SortByRatingAsc, models.SortByRatingDesc, models.SortByDefault:<span class="cov0" title="0"></span>
                // допустимые значения
        default:<span class="cov0" title="0">
                sortOption = models.SortByDefault</span>
        }

        // Чтение строки запроса
        <span class="cov0" title="0">var req dto.SearchReq
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">var categories []*models.Category
        if !req.CategoryID.Valid </span><span class="cov0" title="0">{
                categoryResponse, err := h.s.GetCategorySuggestions(r.Context(), req.SubString)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to get category suggestions")
                        response.HandleDomainError(r.Context(), w, err, "get category suggestions")
                        return
                }</span>

                <span class="cov0" title="0">categories, err = h.u.SearchCategoryByName(r.Context(), categoryResponse)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to search categories by names")
                        response.HandleDomainError(r.Context(), w, err, "search categories by names")
                        return
                }</span>
        }

        // Получение продуктов с фильтрацией и сортировкой
        <span class="cov0" title="0">products, err := h.u.SearchProductsByNameWithFilterAndSort(
                r.Context(),
                req.CategoryID,
                req.SubString,
                offset,
                minPrice,
                maxPrice,
                float32(minRating),
                sortOption,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to search products by names")
                response.HandleDomainError(r.Context(), w, err, "search products by names")
                return
        }</span>

        // Формирование ответа
        <span class="cov0" title="0">searchResponse := dto.SearchResponse{
                Categories: dto.ConvertToCategoriesResponse(categories),
                Products:   dto.ConvertToProductsResponse(products),
        }

        response.SendJSONResponse(r.Context(), w, http.StatusOK, searchResponse)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package transport

import (
        "context"
        "io"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
)

type ISellerUsecase interface {
        AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error)
        UploadProductImage(ctx context.Context, productID uuid.UUID, imageURL string) error
        GetSellerProducts(ctx context.Context, sellerID uuid.UUID, offset int) ([]*models.Product, error)
        CheckProductBelongs(ctx context.Context, productID, sellerID uuid.UUID) (bool, error)
}

type SellerHandler struct {
        usecase ISellerUsecase
        minioService minio.Provider
}

func NewSellerHandler(u ISellerUsecase, ms minio.Provider) *SellerHandler <span class="cov0" title="0">{
        return &amp;SellerHandler{
                usecase: u,
                minioService: ms,
        }
}</span>

// AddProduct godoc
// @Summary Добавить товар (без изображения)
// @Description Добавляет новый товар без изображения
// @Tags seller
// @Accept json
// @Produce json
// @Param product body dto.AddProductRequest true "Данные товара"
// @Success 201 {object} models.Product
// @Failure 400 {object} object
// @Failure 403 {object} object
// @Failure 500 {object} object
// @Router /seller/products [post]
func (h *SellerHandler) AddProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "SellerHandler.AddProduct"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Получаем ID продавца из контекста
        sellerID, err := helpers.GetUserIDFromContext(r.Context())
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user ID from context")
        response.HandleDomainError(r.Context(), w, err, op)
    }</span>

        <span class="cov0" title="0">var req dto.AddProductRequest
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Конвертируем в модель
        <span class="cov0" title="0">product := &amp;models.Product{
                SellerID:       sellerID,
                Name:           req.Name,
                Description:    req.Description,
                Price:          req.Price,
                Quantity:       req.Quantity,
                PreviewImageURL: "", // Будет добавлено позже
        }

        categoryID, err := uuid.Parse(req.Category)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse category ID")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid category ID")
                return
        }</span>

        <span class="cov0" title="0">newProduct, err := h.usecase.AddProduct(r.Context(), product, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("add product")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusCreated, newProduct)</span>
}

// UploadProductImage godoc
// @Summary Загрузить изображение товара
// @Description Загружает изображение для указанного товара
// @Tags seller
// @Accept multipart/form-data
// @Produce json
// @Param id path string true "ID товара"
// @Param file formData file true "Изображение товара"
// @Success 200 {object} map[string]string
// @Failure 400 {object} object
// @Failure 403 {object} object
// @Failure 500 {object} object
// @Router /seller/products/{id}/image [post]
func (h *SellerHandler) UploadProductImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "SellerHandler.UploadProductImage"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Получаем ID продавца из контекста
        sellerID, err := helpers.GetUserIDFromContext(r.Context())
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user ID from context")
        response.HandleDomainError(r.Context(), w, err, op)
    }</span>

        // Получаем ID товара из URL
        <span class="cov0" title="0">vars := mux.Vars(r)
        productID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("parse product ID")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "invalid product ID")
                return
        }</span>

        // Проверяем, что товар принадлежит продавцу
        <span class="cov0" title="0">belongs, err := h.usecase.CheckProductBelongs(r.Context(), productID, sellerID)
        if err != nil || !belongs </span><span class="cov0" title="0">{
                logger.WithError(err).Error("product doesn't belong to seller")
                response.SendJSONError(r.Context(), w, http.StatusForbidden, "product doesn't belong to seller")
                return
        }</span>

        // Обработка загрузки файла
        <span class="cov0" title="0">if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{ // 10 MB max
                logger.WithError(err).Error("parse multipart form")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "failed to parse form")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get file from form")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "no file uploaded")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Читаем файл и загружаем
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("read file content")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "failed to read file")
                return
        }</span>

        <span class="cov0" title="0">fileData := minio.FileData{
                Name: header.Filename,
                Data: fileBytes,
        }

        // Загружаем файл в MinIO
        productResponse, err := h.minioService.CreateOne(r.Context(), fileData)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("upload file to minio")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">err = h.usecase.UploadProductImage(r.Context(), productID, productResponse.URL)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("upload product image")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}

// GetSellerProducts godoc
// @Summary Получить товары продавца
// @Description Возвращает список всех товаров текущего продавца
// @Tags seller
// @Produce json
// @Param offset query int false "Смещение для пагинации"
// @Success 200 {array} models.Product
// @Failure 403 {object} object
// @Failure 500 {object} object
// @Router /seller/products [get]
func (h *SellerHandler) GetSellerProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "SellerHandler.GetSellerProducts"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        // Получаем ID продавца из контекста
        sellerID, err := helpers.GetUserIDFromContext(r.Context())
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user ID from context")
        response.HandleDomainError(r.Context(), w, err, op)
    }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        offsetStr := vars["offset"]
        offset := 0
    if offsetStr != "" </span><span class="cov0" title="0">{
        offset, err = strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).WithField("offset", offsetStr).Error("parse offset")
            response.HandleDomainError(r.Context(), w, errs.ErrParseRequestData, op)
            return
        }</span>
    }

        <span class="cov0" title="0">products, err := h.usecase.GetSellerProducts(r.Context(), sellerID, offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get seller products")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">productResponse := dto.ConvertToSellerProductsResponse(products)
    response.SendJSONResponse(r.Context(), w, http.StatusOK, productResponse)</span>
}</pre>
		
		<pre class="file" id="file54" style="display: none">package suggestions

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "github.com/guregu/null"
        "net/http"
)

//go:generate mockgen -source=suggestions.go -destination=../../usecase/mocks/suggestions_usecase_mock.go -package=mocks ISuggestionsUsecase
type ISuggestionsUsecase interface {
        GetCategorySuggestions(context.Context, string) (dto.CategoryNameResponse, error)
        GetProductSuggestions(context.Context, null.String, string) (dto.ProductNameResponse, error)
}

type SuggestionsService struct {
        u ISuggestionsUsecase
}

func NewSuggestionsService(u ISuggestionsUsecase) *SuggestionsService <span class="cov0" title="0">{
        return &amp;SuggestionsService{
                u: u,
        }
}</span>

func (h *SuggestionsService) GetSuggestions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "SuggestionsService.GetSuggestions"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var req dto.SuggestionsReq
        if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">var categoryResponse dto.CategoryNameResponse
        var productResponse dto.ProductNameResponse
        var err error

        // Если категория не указана - получаем и категории и продукты
        if !req.CategoryID.Valid </span><span class="cov0" title="0">{
                categoryResponse, err = h.u.GetCategorySuggestions(r.Context(), req.SubString)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to get category suggestions")
                        response.HandleDomainError(r.Context(), w, err, "get category suggestions")
                        return
                }</span>

                <span class="cov0" title="0">productResponse, err = h.u.GetProductSuggestions(r.Context(), req.CategoryID, req.SubString)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to get product suggestions")
                        response.HandleDomainError(r.Context(), w, err, "get product suggestions")
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Если категория указана - получаем только продукты для этой категории
                productResponse, err = h.u.GetProductSuggestions(r.Context(), req.CategoryID, req.SubString)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to get product suggestions")
                        response.HandleDomainError(r.Context(), w, err, "get product suggestions")
                        return
                }</span>
                // Возвращаем пустой список категорий
                <span class="cov0" title="0">categoryResponse = dto.CategoryNameResponse{CategoriesNames: []models.CategorySuggestion{}}</span>
        }

        <span class="cov0" title="0">combined := dto.CombinedSuggestionsResponse{
                Categories: categoryResponse.CategoriesNames,
                Products:   productResponse.ProductNames,
        }

        response.SendJSONResponse(r.Context(), w, http.StatusOK, combined)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package user

import (
        "context"
        "io"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/user"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/user"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/validator"
        "github.com/guregu/null"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
)

type UserGRPCHandler struct {
        gen.UnimplementedUserServiceServer
        
        userProvider user.IUserUsecase
        minioService minio.Provider
}

func NewUserGRPCHandler(u user.IUserUsecase, ms minio.Provider) *UserGRPCHandler <span class="cov0" title="0">{
        return &amp;UserGRPCHandler{
                userProvider: u,
                minioService: ms,
        }
}</span>

func (h *UserGRPCHandler) GetMe(ctx context.Context, _ *emptypb.Empty) (*gen.User, error)<span class="cov0" title="0">{
        const op = "UserGRPCHandler.GetMe"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        user, token, err := h.userProvider.GetMe(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get current user")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
        if err := grpc.SetHeader(ctx, metadata.Pairs("x-new-token", token)); err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).Error("failed to set new token header")
        }</span>
    }

        <span class="cov0" title="0">return user.ConvertToGrpcUser(), nil</span>
}

func (h *UserGRPCHandler) UploadAvatar(stream gen.UserService_UploadAvatarServer) error <span class="cov0" title="0">{
        const op = "UserGRPCHandler.UploadAvatar"
        ctx := stream.Context()
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var fileData []byte
        for </span><span class="cov0" title="0">{
                chunk, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to receive chunk")
                        return errs.MapErrorToGRPC(errs.ErrInternal)
                }</span>
                <span class="cov0" title="0">fileData = append(fileData, chunk.Value...)</span>
        }

        <span class="cov0" title="0">contentType := http.DetectContentType(fileData)
        if err := validator.ValidateImageContentType(contentType); err != nil </span><span class="cov0" title="0">{
                logger.WithField("contentType", contentType).Error(err.Error())
                return status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">avatarURL, err := h.userProvider.UploadAvatar(ctx, minio.FileData{
                Name: "avatar",
                Data: fileData,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("upload failed")
                return errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return stream.SendAndClose(&amp;gen.UploadAvatarResponse{
                ImageURL: avatarURL,
        })</span>
}

func (h *UserGRPCHandler) UpdateUserProfile(ctx context.Context, req *gen.UpdateUserProfileRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        const op = "UserGRPCHandler.UpdateUserProfile"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var name null.String
        if req.Name != nil </span><span class="cov0" title="0">{
                name = null.StringFrom(req.Name.Value)
        }</span>

        <span class="cov0" title="0">var surname null.String
        if req.Surname != nil </span><span class="cov0" title="0">{
                surname = null.StringFrom(req.Surname.Value)
        }</span>

        <span class="cov0" title="0">var phoneNumber null.String
        if req.PhoneNumber != nil </span><span class="cov0" title="0">{
                phoneNumber = null.StringFrom(req.PhoneNumber.Value)
        }</span>

        <span class="cov0" title="0">request := dto.UpdateUserProfileRequestDTO{
                Name:        name,
                Surname:     surname,
                PhoneNumber: phoneNumber,
        }

        validator.SanitizeUserProfileUpdateRequest(&amp;request)
        if err := validator.ValidateUserUpdateProfileCreds(request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("validate profile update credentials")
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">if err := h.userProvider.UpdateUserProfile(ctx, request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("update profile failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (h *UserGRPCHandler) UpdateUserEmail(ctx context.Context, req *gen.UpdateUserEmailRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        const op = "UserGRPCHandler.UpdateUserEmail"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        request := dto.UpdateUserEmailDTO{
                Email:    req.Email,
                Password: req.Password,
        }

        validator.SanitizeUserEmailUpdateRequest(&amp;request)
        if err := validator.ValidateEmailCreds(request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("validate email update credentials")
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">if err := h.userProvider.UpdateUserEmail(ctx, request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("update email failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (h *UserGRPCHandler) UpdateUserPassword(ctx context.Context, req *gen.UpdateUserPasswordRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        const op = "UserGRPCHandler.UpdateUserPassword"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        request := dto.UpdateUserPasswordDTO{
                OldPassword: req.OldPassword,
                NewPassword: req.NewPassword,
        }

        validator.SanitizeUserPasswordUpdateRequest(&amp;request)
        if err := validator.ValidatePasswordCreds(request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("validate password update credentials")
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">if err := h.userProvider.UpdateUserPassword(ctx, request); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("update password failed")
                return nil, errs.MapErrorToGRPC(err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (h *UserGRPCHandler) BecomeSeller(ctx context.Context, req *gen.BecomeSellerRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
    const op = "UserGRPCHandler.BecomeSeller"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    request := dto.UpdateRoleRequest{
        Title:       req.Title,
        Description: req.Description,
    }

    if err := h.userProvider.BecomeSeller(ctx, request); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("become seller failed")
        return nil, errs.MapErrorToGRPC(err)
    }</span>

    <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}</pre>
		
		<pre class="file" id="file56" style="display: none">package user

import (
        "io"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        gen "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/generated/user"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/cookie"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/request"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/utils/response"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/protobuf/types/known/emptypb"
)

type UserHandler struct {
        userClient gen.UserServiceClient
        config     *config.Config
}

func NewUserHandler(
        userClient gen.UserServiceClient,
        cfg *config.Config,
) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userClient: userClient,
                config:     cfg,
        }
}</span>

// @Summary                Получить информацию о себе
// @Description        Возвращает информацию о текущем авторизованном пользователе
// @Tags                        users
// @Produce                json
// @Success                200        {object}        dto.UserDTO        "Информация о пользователе"
// @Failure                400        {string}        string                "Некорректный запрос"
// @Failure                401        {string}        string                "Пользователь не авторизован"
// @Failure                500        {string}        string                "Внутренняя ошибка сервера"
// @Router                        /users/me [get]
func (h *UserHandler) GetMe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "UserHandler.GetMe"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var header metadata.MD
    res, err := h.userClient.GetMe(
        r.Context(), 
        &amp;emptypb.Empty{},
        grpc.Header(&amp;header),
    )
    if err != nil </span><span class="cov0" title="0">{
        response.HandleGRPCError(r.Context(), w, err, op)
        return
    }</span>

        <span class="cov0" title="0">if newTokens := header.Get("x-new-token"); len(newTokens) &gt; 0 </span><span class="cov0" title="0">{
        cookieProvider := cookie.NewCookieProvider(h.config)
        cookieProvider.Set(w, newTokens[0], domains.TokenCookieName)

                csrfToken, err := middleware.GenerateCSRFToken(
            newTokens[0],
            h.config.CSRFConfig.SecretKey,
            h.config.CSRFConfig.TokenExpiry,
        )
        if err != nil </span><span class="cov0" title="0">{
            logger.WithError(err).Error("generate CSRF token")
            response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to generate CSRF token")
            return
        }</span>
        <span class="cov0" title="0">w.Header().Set("X-CSRF-Token", csrfToken)</span>
    }

        <span class="cov0" title="0">user, err := dto.ConvertGrpcToUserDTO(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to convert user")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to process user data")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, user)</span>
}

// @Summary                Загрузить аватар
// @Description        Загружает изображение профиля пользователя
// @Tags                        users
// @Accept                        multipart/form-data
// @Produce                json
// @Param                        file                        formData        file                                true        "Файл изображения"
// @Param                        X-Csrf-Token        header                string                                true        "CSRF-токен для защиты от подделки запросов"
// @Success                200                                {object}        map[string]string        "URL загруженного аватара"
// @Failure                400                                {string}        string                                "Ошибка загрузки или обработки формы"
// @Failure                500                                {string}        string                                "Внутренняя ошибка сервера"
// @Router                        /users/avatar [post]
func (h *UserHandler) UploadAvatar(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "UserHandler.UploadAvatar"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        userID, ok := r.Context().Value(domains.UserIDKey{}).(string)
    if !ok </span><span class="cov0" title="0">{
        logger.Error("user ID not found in context")
        response.SendJSONError(r.Context(), w, http.StatusUnauthorized, "user not authenticated")
        return
    }</span>

    // Создаем контекст с метаданными для gRPC
    <span class="cov0" title="0">ctx := metadata.AppendToOutgoingContext(r.Context(), "user-id", userID)

        if err := r.ParseMultipartForm(h.config.ServerConfig.MaxMultipartMemory); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse form data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "failed to parse form data")
                return
        }</span>

        <span class="cov0" title="0">file, _, err := r.FormFile(h.config.ServerConfig.AvatarKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("no file uploaded")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, "no file uploaded")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        stream, err := h.userClient.UploadAvatar(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to create upload stream")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to start upload")
                return
        }</span>

        <span class="cov0" title="0">buf := make([]byte, 1024)
        for </span><span class="cov0" title="0">{
                n, err := file.Read(buf)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to read file chunk")
                        response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to read file")
                        return
                }</span>

                <span class="cov0" title="0">if err := stream.Send(&amp;gen.BytesValue{Value: buf[:n]}); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to send chunk")
                        response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to upload file")
                        return
                }</span>
        }

        <span class="cov0" title="0">res, err := stream.CloseAndRecv()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to close stream")
                response.SendJSONError(r.Context(), w, http.StatusInternalServerError, "failed to complete upload")
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, map[string]string{
                "imageURL": res.ImageURL,
        })</span>
}

// @Summary                Обновить профиль пользователя
// @Description        Обновляет основную информацию пользователя
// @Tags                        users
// @Accept                        json
// @Produce                json
// @Param                        body                        body                dto.UpdateUserProfileRequestDTO        true        "Данные для обновления профиля"
// @Param                        X-Csrf-Token        header                string                                                        true        "CSRF-токен для защиты от подделки запросов"
// @Success                200                                {string}        string                                                        "Профиль успешно обновлён"
// @Failure                400                                {string}        string                                                        "Невалидные данные"
// @Failure                500                                {string}        string                                                        "Ошибка при обновлении профиля"
// @Security                TokenAuth
// @Router                        /users/update-profile [post]
func (h *UserHandler) UpdateUserProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "UserHandler.UpdateUserProfile"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var updateReq dto.UpdateUserProfileRequestDTO
        if err := request.ParseData(r, &amp;updateReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">_, err := h.userClient.UpdateUserProfile(r.Context(), updateReq.ConvertToGrpcUpdateProfileReq())
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

// @Summary                Обновить email пользователя
// @Description        Обновляет email текущего пользователя
// @Tags                        users
// @Accept                        json
// @Produce                json
// @Param                        body                        body                dto.UpdateUserEmailDTO        true        "Новый email"
// @Param                        X-Csrf-Token        header                string                                        true        "CSRF-токен для защиты от подделки запросов"
// @Success                200                                {string}        string                                        "Email успешно обновлён"
// @Failure                400                                {string}        string                                        "Невалидные данные"
// @Failure                500                                {string}        string                                        "Ошибка при обновлении email"
// @Security                TokenAuth
// @Router                        /users/update-email [post]
func (h *UserHandler) UpdateUserEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "UserHandler.UpdateUserEmail"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var updateReq dto.UpdateUserEmailDTO
        if err := request.ParseData(r, &amp;updateReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">_, err := h.userClient.UpdateUserEmail(r.Context(), &amp;gen.UpdateUserEmailRequest{
                Email:    updateReq.Email,
                Password: updateReq.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

// @Summary                Обновить пароль пользователя
// @Description        Меняет пароль текущего пользователя
// @Tags                        users
// @Accept                        json
// @Produce                json
// @Param                        body                        body                dto.UpdateUserPasswordDTO        true        "Старый и новый пароли"
// @Param                        X-Csrf-Token        header                string                                                true        "CSRF-токен для защиты от подделки запросов"
// @Success                200                                {string}        string                                                "Пароль успешно обновлён"
// @Failure                400                                {string}        string                                                "Невалидные данные"
// @Failure                500                                {string}        string                                                "Ошибка при обновлении пароля"
// @Security                TokenAuth
// @Router                        /users/update-password [post]
func (h *UserHandler) UpdateUserPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        const op = "UserHandler.UpdateUserPassword"
        logger := logctx.GetLogger(r.Context()).WithField("op", op)

        var updateReq dto.UpdateUserPasswordDTO
        if err := request.ParseData(r, &amp;updateReq); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to parse request data")
                response.HandleDomainError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">_, err := h.userClient.UpdateUserPassword(r.Context(), &amp;gen.UpdateUserPasswordRequest{
                OldPassword: updateReq.OldPassword,
                NewPassword: updateReq.NewPassword,
        })
        if err != nil </span><span class="cov0" title="0">{
                response.HandleGRPCError(r.Context(), w, err, op)
                return
        }</span>

        <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}

func (h *UserHandler) BecomeSeller(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    const op = "UserHandler.BecomeSeller"
    logger := logctx.GetLogger(r.Context()).WithField("op", op)

    var req dto.UpdateRoleRequest
    if err := request.ParseData(r, &amp;req); err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("failed to parse request data")
        response.SendJSONError(r.Context(), w, http.StatusBadRequest, err.Error())
        return
    }</span>

    <span class="cov0" title="0">_, err := h.userClient.BecomeSeller(r.Context(), &amp;gen.BecomeSellerRequest{
        Title:       req.Title,
        Description: req.Description,
    })
    if err != nil </span><span class="cov0" title="0">{
        response.HandleGRPCError(r.Context(), w, err, op)
        return
    }</span>

    <span class="cov0" title="0">response.SendJSONResponse(r.Context(), w, http.StatusOK, nil)</span>
}</pre>
		
		<pre class="file" id="file57" style="display: none">package cookie

import (
        "github.com/go-park-mail-ru/2025_1_ChillGuys/config"
        "log"
        "net/http"
        "time"
)

type CookieProvider struct {
        cfg *config.Config
}

func NewCookieProvider(cfg *config.Config) *CookieProvider <span class="cov0" title="0">{
        if cfg == nil || cfg.JWTConfig == nil </span><span class="cov0" title="0">{
                log.Println("Warning: nil config or JWTConfig provided to CookieProvider")
        }</span>
        <span class="cov0" title="0">return &amp;CookieProvider{cfg: cfg}</span>
}

func (cp *CookieProvider) Set(w http.ResponseWriter, token, name string) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                log.Println("Warning: empty token for cookie", name)
                return
        }</span>

        <span class="cov0" title="0">tokenLifeSpan := 24 * time.Hour
        if cp.cfg != nil &amp;&amp; cp.cfg.JWTConfig != nil </span><span class="cov0" title="0">{
                tokenLifeSpan = cp.cfg.JWTConfig.TokenLifeSpan
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     name,
                Value:    token,
                Path:     "/",
                SameSite: http.SameSiteStrictMode,
                HttpOnly: true,
                Expires:  time.Now().UTC().Add(tokenLifeSpan),
        })</span>
}

func (cp *CookieProvider) Unset(w http.ResponseWriter, name string) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     name,
                Value:    "",
                Path:     "/",
                Expires:  time.Now().UTC().AddDate(0, 0, -1),
                HttpOnly: true,
                Secure:   true,
        })
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package metadata

import (
        "context"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "google.golang.org/grpc/metadata"
        "strings"
)

const jwtKey = "authorization"

// ExtractJWTFromContext извлекает JWT токен из gRPC контекста
// Формат ожидаемого заголовка: "Bearer &lt;token&gt;"
func ExtractJWTFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // 1. Получаем метаданные из контекста
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", errs.ErrNoMetadata
        }</span>

        // 2. Извлекаем заголовок Authorization
        <span class="cov0" title="0">authHeaders := md.Get(jwtKey)
        if len(authHeaders) == 0 </span><span class="cov0" title="0">{
                return "", errs.ErrNoAuthHeader
        }</span>

        // 3. Проверяем формат "Bearer &lt;token&gt;"
        <span class="cov0" title="0">tokenHeader := authHeaders[0]
        if len(tokenHeader) &lt; 7 || !strings.HasPrefix(tokenHeader, "Bearer ") </span><span class="cov0" title="0">{
                return "", errs.ErrInvalidAuthFormat
        }</span>

        // 4. Возвращаем чистый токен (без "Bearer ")
        <span class="cov0" title="0">return tokenHeader[7:], nil</span>
}

func InjectJWTIntoContext(ctx context.Context, token string) context.Context <span class="cov0" title="0">{
        md := metadata.New(map[string]string{jwtKey: "Bearer " + token})
        return metadata.NewOutgoingContext(ctx, md)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package request

import (
        "encoding/json"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "io"
        "net/http"
)

func ParseData(r *http.Request, request any) error <span class="cov8" title="1">{
        defer r.Body.Close()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return errs.ErrReadRequestData
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, request); err != nil </span><span class="cov8" title="1">{
                return errs.ErrParseRequestData
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package response

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "net/http"
)

func SendJSONError(ctx context.Context, w http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        resp, err := json.Marshal(dto.ErrorResponseDTO{Message: message})
        if err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to marshal response: ", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if _, err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to write response: ", err.Error())
        }</span>
}

func SendJSONResponse(ctx context.Context, w http.ResponseWriter, statusCode int, body any) <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                w.WriteHeader(statusCode)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        resp, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                logctx.GetLogger(ctx).Error("failed to marshal response", err.Error())
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(statusCode)
        if _, err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                logctx.GetLogger(ctx).Error("failed to write response", err.Error())
        }</span>
}

func HandleDomainError(ctx context.Context, w http.ResponseWriter, err error, description string) <span class="cov8" title="1">{
        log := logctx.GetLogger(ctx)

        switch </span>{
        case errors.Is(err, errs.ErrInvalidCredentials):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusUnauthorized, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid credentials error: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusUnauthorized, fmt.Sprintf("%s: %v", description, err))
                log.Debug("user not found: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrAlreadyExists):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusConflict, fmt.Sprintf("%s: %v", description, err))
                log.Debug("user already exists: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrInvalidID):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid user id format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrInvalidToken):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusUnauthorized, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid token: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrAlreadyExists):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusConflict, fmt.Sprintf("%s: %v", description, err))
                log.Debug("resource already exists: ", description, errs.NewAlreadyExistsError(description))</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusNotFound, fmt.Sprintf("%s: %v", description, err))
                log.Debug("not found: ", description, errs.NewNotFoundError(description))</span>

        case errors.Is(err, errs.ErrInvalidID):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid id format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrBusinessLogic):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusUnprocessableEntity, fmt.Sprintf("%s: %v", description, err))
                log.Debug("business logic error: ", description, errs.NewBusinessLogicError(description))</span>

        case errors.Is(err, errs.ErrNotFound):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusNotFound, fmt.Sprintf("%s: %v", description, err))
                log.Debug("product not found: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrProductNotApproved):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusForbidden, fmt.Sprintf("%s: %v", description, err))
                log.Debug("product not approved: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrNotEnoughStock):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("not enough stock: ", description, err.Error())</span>
        
        case errors.Is(err, errs.ErrInvalidProductPrice):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrInvalidProductQuantity):<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid format: ", description, err.Error())</span>

        case errors.Is(err, errs.ErrEmptyProductName):<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusBadRequest, fmt.Sprintf("%s: %v", description, err))
                log.Debug("invalid format: ", description, err.Error())</span>

        default:<span class="cov8" title="1">
                SendJSONError(ctx, w, http.StatusInternalServerError, err.Error())
                log.Error("unexpected error: ", description, err.Error())</span>
        }
}

func HandleGRPCError(ctx context.Context, w http.ResponseWriter, err error, op string) <span class="cov0" title="0">{
        logger := logctx.GetLogger(ctx)
        st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                logger.WithError(err).Error(op + ": unexpected error type")
                SendJSONError(ctx, w, http.StatusInternalServerError, "internal server error")
                return
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.Unauthenticated:<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusUnauthorized, st.Message())</span>
        case codes.AlreadyExists:<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusConflict, st.Message())</span>
        case codes.NotFound:<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusNotFound, st.Message())</span>
        case codes.InvalidArgument:<span class="cov0" title="0">
                SendJSONError(ctx, w, http.StatusBadRequest, st.Message())</span>
        default:<span class="cov0" title="0">
                logger.WithError(err).Error(op + ": unexpected gRPC status code")
                SendJSONError(ctx, w, http.StatusInternalServerError, "internal server error")</span>
        }
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package validator

import (
        "errors"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/google/uuid"
        "regexp"
        "strconv"
        "strings"
)

var (
        emailRegexp       = regexp.MustCompile(`^\w+(\.\w*)*@\w+(\.\w{2,})+$`)
        nameRegexp        = regexp.MustCompile(`^[a-zA-Zа-яА-ЯёЁ\s-]+$`)
        digitRegexp       = regexp.MustCompile(`[0-9]`)
        lowercaseRegexp   = regexp.MustCompile(`[a-z]`)
        uppercaseRegexp   = regexp.MustCompile(`[A-Z]`)
        phoneNumberRegexp = regexp.MustCompile(`^(?:\+?\d{1,3})?[\s\-]?\(?\d{1,4}\)?[\s\-]?\d{1,4}[\s\-]?\d{1,4}$`)
        labelRegexp       = regexp.MustCompile(`^[a-zA-Zа-яА-ЯёЁ0-9\s\-]+$`)
        allowedImageTypes = map[string]bool{
                "image/jpeg": true,
                "image/png":  true,
                "image/webp": true,
        }
)

func itoa(i int) string <span class="cov0" title="0">{
        return strconv.Itoa(i)
}</span>

func ValidateLoginCreds(req dto.UserLoginRequestDTO) error <span class="cov0" title="0">{
        if err := validateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateRegistrationCreds проверяет корректность данных при регистрации
func ValidateRegistrationCreds(req dto.UserRegisterRequestDTO) error <span class="cov0" title="0">{
        if err := validateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateName(req.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if req.Surname.Valid </span><span class="cov0" title="0">{
                if err := validateName(req.Surname.String); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateUserUpdateProfileCreds(req dto.UpdateUserProfileRequestDTO) error <span class="cov0" title="0">{

        if req.Name.Valid &amp;&amp; strings.TrimSpace(req.Name.String) != "" </span><span class="cov0" title="0">{
                if err := validateName(req.Name.String); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if req.Surname.Valid &amp;&amp; strings.TrimSpace(req.Surname.String) != "" </span><span class="cov0" title="0">{
                if err := validateName(req.Surname.String); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if req.PhoneNumber.Valid &amp;&amp; strings.TrimSpace(req.PhoneNumber.String) != "" </span><span class="cov0" title="0">{
                if err := validatePhoneNumber(req.PhoneNumber.String); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateEmailCreds(req dto.UpdateUserEmailDTO) error <span class="cov0" title="0">{
        if err := validateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidatePasswordCreds(req dto.UpdateUserPasswordDTO) error <span class="cov0" title="0">{
        if err := validatePassword(req.OldPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEmail Функция валидации почты
func validateEmail(email string) error <span class="cov0" title="0">{
        if !emailRegexp.MatchString(email) </span><span class="cov0" title="0">{
                return errors.New("invalid email")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validatePassword проверяет валидность пароля
func validatePassword(password string) error <span class="cov0" title="0">{
        switch </span>{
        case len(password) &lt; 8:<span class="cov0" title="0">
                return errors.New("password must be at least 8 characters")</span>
        case !digitRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one number")</span>
        case !lowercaseRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one lowercase letter")</span>
        case !uppercaseRegexp.MatchString(password):<span class="cov0" title="0">
                return errors.New("password must contain at least one uppercase letter")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateName проверяет валидность имени пользователя
func validateName(name string) error <span class="cov0" title="0">{
        if len(name) &lt; 2 || len(name) &gt; 24 </span><span class="cov0" title="0">{
                return errors.New("name must be between 2 and 24 characters long")
        }</span>

        <span class="cov0" title="0">if !nameRegexp.MatchString(name) </span><span class="cov0" title="0">{
                return errors.New("name can only contain letters, spaces, and '-'")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validatePhoneNumber(phone string) error <span class="cov0" title="0">{
        if !phoneNumberRegexp.MatchString(phone) </span><span class="cov0" title="0">{
                return errors.New("invalid phone number format")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateImageContentType(contentType string) error <span class="cov0" title="0">{
        if !allowedImageTypes[contentType] </span><span class="cov0" title="0">{
                return errors.New("unsupported file type")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateLabel(label string) error <span class="cov0" title="0">{
        if len(label) &lt; 2 || len(label) &gt; 32 </span><span class="cov0" title="0">{
                return errors.New("label must be between 2 and 32 characters")
        }</span>
        <span class="cov0" title="0">if !labelRegexp.MatchString(label) </span><span class="cov0" title="0">{
                return errors.New("label can only contain letters, digits, spaces, and '-'")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateCreateOrderDTO(req dto.CreateOrderDTO) error <span class="cov0" title="0">{
        if req.AddressID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("addressID is required")
        }</span>

        <span class="cov0" title="0">if len(req.Items) == 0 </span><span class="cov0" title="0">{
                return errors.New("order must contain at least one item")
        }</span>

        <span class="cov0" title="0">for i, item := range req.Items </span><span class="cov0" title="0">{
                if item.ProductID == uuid.Nil </span><span class="cov0" title="0">{
                        return errors.New("productID is required for item " + itoa(i+1))
                }</span>
                <span class="cov0" title="0">if item.Quantity == 0 </span><span class="cov0" title="0">{
                        return errors.New("quantity must be greater than zero for item " + itoa(i+1))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SanitizeUserRegistrationRequest удаляет лишние пробелы из полей запроса регистрации пользователя
func SanitizeUserRegistrationRequest(req *dto.UserRegisterRequestDTO) <span class="cov0" title="0">{
        req.Email = strings.TrimSpace(req.Email)
        req.Name = strings.TrimSpace(req.Name)
        req.Password = strings.TrimSpace(req.Password)
        if req.Surname.Valid </span><span class="cov0" title="0">{
                req.Surname.String = strings.TrimSpace(req.Surname.String)
                req.Surname.Valid = req.Surname.String != ""
        }</span>
}

// SanitizeUserLoginRequest удаляет лишние пробелы из полей запроса для логина пользователя
func SanitizeUserLoginRequest(req *dto.UserLoginRequestDTO) <span class="cov0" title="0">{
        req.Email = strings.TrimSpace(req.Email)
        req.Password = strings.TrimSpace(req.Password)
}</span>

func SanitizeUserProfileUpdateRequest(req *dto.UpdateUserProfileRequestDTO) <span class="cov0" title="0">{
        if req.Name.Valid </span><span class="cov0" title="0">{
                req.Name.String = strings.TrimSpace(req.Name.String)
                req.Name.Valid = req.Name.String != ""
        }</span>

        <span class="cov0" title="0">if req.Surname.Valid </span><span class="cov0" title="0">{
                req.Surname.String = strings.TrimSpace(req.Surname.String)
                req.Surname.Valid = req.Surname.String != ""
        }</span>

        <span class="cov0" title="0">if req.PhoneNumber.Valid </span><span class="cov0" title="0">{
                req.PhoneNumber.String = strings.TrimSpace(req.PhoneNumber.String)
                req.PhoneNumber.Valid = req.PhoneNumber.String != ""
        }</span>
}

func SanitizeUserEmailUpdateRequest(req *dto.UpdateUserEmailDTO) <span class="cov0" title="0">{
        req.Email = strings.TrimSpace(req.Email)
        req.Password = strings.TrimSpace(req.Password)
}</span>

func SanitizeUserPasswordUpdateRequest(req *dto.UpdateUserPasswordDTO) <span class="cov0" title="0">{
        req.OldPassword = strings.TrimSpace(req.OldPassword)
        req.NewPassword = strings.TrimSpace(req.NewPassword)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package address

import (
        "context"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/address"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

//go:generate mockgen -source=address.go -destination=../mocks/address_usecase_mock.go -package=mocks IAddressUsecase
type IAddressUsecase interface {
        CreateAddress(context.Context, uuid.UUID, dto.AddressDTO) error
        GetAddresses(context.Context, uuid.UUID) ([]dto.GetAddressResDTO, error)
        GetPickupPoints(ctx context.Context) ([]dto.GetPointAddressResDTO, error)
}

type AddressUsecase struct {
        Repo address.IAddressRepository
}

func NewAddressUsecase(
        repo address.IAddressRepository,
) *AddressUsecase <span class="cov8" title="1">{
        return &amp;AddressUsecase{
                Repo: repo,
        }
}</span>

func (u *AddressUsecase) CreateAddress(ctx context.Context, userID uuid.UUID, in dto.AddressDTO) error <span class="cov8" title="1">{
        const op = "AddressUsecase.CreateAddress"
        logger := logctx.GetLogger(ctx).WithField("op", op).
                WithField("user_id", userID).
                WithField("address", in)

        addressID := uuid.New()
        addr := models.AddressDB{
                ID:            addressID,
                Region:        in.Region,
                City:          in.City,
                AddressString: in.AddressString,
                Coordinate:    in.Coordinate,
        }

        addrID, err := u.Repo.CheckAddressExists(ctx, addr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if addrID == uuid.Nil </span><span class="cov8" title="1">{
                if err = u.Repo.CreateAddress(ctx, addr); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("create address")
                        return fmt.Errorf("%s: %w", op, err)
                }</span>
        } else<span class="cov8" title="1"> {
                addressID = addrID
        }</span>

        <span class="cov8" title="1">userAddr := models.UserAddress{
                ID:        uuid.New(),
                Label:     in.Label,
                UserID:    userID,
                AddressID: addressID,
        }

        if err := u.Repo.CreateUserAddress(ctx, userAddr); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create user address")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *AddressUsecase) GetAddresses(ctx context.Context, userID uuid.UUID) ([]dto.GetAddressResDTO, error) <span class="cov8" title="1">{
        const op = "AddressUsecase.GetAddresses"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        addresses, err := u.Repo.GetUserAddress(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("no addresses found for user")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user addresses")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">res := make([]dto.GetAddressResDTO, 0, len(*addresses))
        for _, addr := range *addresses </span><span class="cov8" title="1">{
                res = append(res, dto.GetAddressResDTO{
                        ID:            addr.ID,
                        Label:         addr.Label,
                        AddressString: addr.AddressString,
                        Coordinate:    addr.Coordinate,
                })
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

func (u *AddressUsecase) GetPickupPoints(ctx context.Context) ([]dto.GetPointAddressResDTO, error) <span class="cov8" title="1">{
        const op = "AddressUsecase.GetPickupPoints"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        points, err := u.Repo.GetAllPickupPoints(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("no pickup points found")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get pickup points")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">res := make([]dto.GetPointAddressResDTO, 0, len(*points))
        for _, point := range *points </span><span class="cov8" title="1">{
                res = append(res, dto.GetPointAddressResDTO{
                        ID:            point.ID,
                        AddressString: point.AddressString,
                        Coordinate:    point.Coordinate,
                })
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package admin

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis"
        productRepo "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/product"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

//go:generate mockgen -source=admin.go -destination=../../infrastructure/repository/postgres/mocks/admin_repository_mock.go -package=mocks IAdminRepository
type IAdminRepository interface {
        GetPendingProducts(ctx context.Context, offset int) ([]*models.Product, error)
        UpdateProductStatus(ctx context.Context, productID uuid.UUID, status models.ProductStatus) error
        GetPendingUsers(ctx context.Context, offset int) ([]*models.User, error)
        UpdateUserRole(ctx context.Context, userID uuid.UUID, role models.UserRole) error
}

type AdminUsecase struct {
        repo        IAdminRepository
        repoProduct productRepo.IProductRepository
        redisRepo   *redis.SuggestionsRepository
}

func NewAdminUsecase(r IAdminRepository, redisRepo *redis.SuggestionsRepository, repoProduct productRepo.IProductRepository) *AdminUsecase <span class="cov8" title="1">{
        return &amp;AdminUsecase{
                repo:        r,
                repoProduct: repoProduct,
                redisRepo:   redisRepo,
        }
}</span>

func (u *AdminUsecase) GetPendingProducts(ctx context.Context, offset int) (dto.ProductsResponse, error) <span class="cov8" title="1">{
        const op = "AdminUsecase.GetPendingProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        products, err := u.repo.GetPendingProducts(ctx, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get pending products")
                return dto.ProductsResponse{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return dto.ConvertToProductsResponse(products), nil</span>
}

func (u *AdminUsecase) UpdateProductStatus(ctx context.Context, req dto.UpdateProductStatusRequest) error <span class="cov0" title="0">{
        const op = "AdminUsecase.UpdateProductStatus"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", req.ProductID)

        var status models.ProductStatus
        switch req.Update </span>{
        case 0:<span class="cov0" title="0">
                status = models.ProductRejected</span>
        case 1:<span class="cov0" title="0">
                status = models.ProductApproved</span>
        default:<span class="cov0" title="0">
                logger.Error("invalid update status value")
                return errs.ErrParseRequestData</span>
        }

        <span class="cov0" title="0">err := u.repo.UpdateProductStatus(ctx, req.ProductID, status)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to update product status")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">product, err := u.repoProduct.GetProductByID(ctx, req.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get product details")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">productNames := []string{product.Name}

        err = u.redisRepo.AddSuggestionsByKey(ctx, redis.ProductNamesKey, productNames)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to add product to Redis suggestions")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *AdminUsecase) GetPendingUsers(ctx context.Context, offset int) (dto.UsersResponse, error) <span class="cov8" title="1">{
        const op = "AdminUsecase.GetPendingUsers"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        users, err := u.repo.GetPendingUsers(ctx, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get pending users")
                return dto.UsersResponse{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return dto.ConvertToUsersResponse(users), nil</span>
}

func (u *AdminUsecase) UpdateUserRole(ctx context.Context, req dto.UpdateUserRoleRequest) error <span class="cov8" title="1">{
        const op = "AdminUsecase.UpdateUserRole"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", req.UserID)

        var role models.UserRole
        switch req.Update </span>{
        case 0:<span class="cov8" title="1">
                role = models.RoleBuyer</span>
        case 1:<span class="cov8" title="1">
                role = models.RoleSeller</span>
        default:<span class="cov8" title="1">
                logger.Error("invalid update role value")
                return errs.ErrParseRequestData</span>
        }

        <span class="cov8" title="1">err := u.repo.UpdateUserRole(ctx, req.UserID, role)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to update user role")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package auth

import (
        "context"
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
)

type ITokenator interface {
        CreateJWT(userID string, role string) (string, error)
        ParseJWT(tokenString string) (*jwt.JWTClaims, error)
}

//go:generate mockgen -source=auth.go -destination=../../infrastructure/repository/postgres/mocks/auth_repository_mock.go -package=mocks IAuthRepository
type IAuthRepository interface {
        CreateUser(context.Context, models.UserDB) error
        GetUserByEmail(context.Context, string) (*models.UserDB, error)
        GetUserByID(context.Context, uuid.UUID) (*models.UserDB, error)
        CheckUserExists(context.Context, string) (bool, error)
}

type IAuthRedisRepository interface {
    AddToBlacklist(ctx context.Context, userID, token string) error
    IsInBlacklist(ctx context.Context, userID, token string) (bool, error)
}

type AuthUsecase struct {
        token     ITokenator
        repo      IAuthRepository
        redisRepo IAuthRedisRepository 
}

func NewAuthUsecase(repo IAuthRepository, redisRepo IAuthRedisRepository , token ITokenator) *AuthUsecase <span class="cov8" title="1">{
        return &amp;AuthUsecase{
                repo:      repo,
                redisRepo: redisRepo,
                token:     token,
        }
}</span>

func (u *AuthUsecase) Register(ctx context.Context, user dto.UserRegisterRequestDTO) (string, error) <span class="cov8" title="1">{
        const op = "AuthUsecase.Register"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("email", user.Email)

        passwordHash, err := GeneratePasswordHash(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("generate password hash")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">existed, err := u.repo.CheckUserExists(ctx, user.Email)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("check user existence")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if existed </span><span class="cov8" title="1">{
                logger.Warn("user already exists")
                return "", fmt.Errorf("%s: %w", op, errs.ErrAlreadyExists)
        }</span>

        <span class="cov8" title="1">userID := uuid.New()
        userDB := models.UserDB{
                ID:           userID,
                Email:        user.Email,
                Name:         user.Name,
                Surname:      user.Surname,
                PasswordHash: passwordHash,
                Role:         models.RoleBuyer,
        }

        if err = u.repo.CreateUser(ctx, userDB); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create user in repository")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">token, err := u.token.CreateJWT(userDB.ID.String(), userDB.Role.String())
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create JWT token")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (u *AuthUsecase) Login(ctx context.Context, user dto.UserLoginRequestDTO) (string, error) <span class="cov8" title="1">{
        const op = "AuthUsecase.Login"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("email", user.Email)

        userDB, err := u.repo.GetUserByEmail(ctx, user.Email)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov8" title="1">{
                        logger.Warn("user not found")
                }</span> else<span class="cov0" title="0"> {
                        logger.WithError(err).Error("get user by email")
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword(userDB.PasswordHash, []byte(user.Password)); err != nil </span><span class="cov8" title="1">{
                logger.Warn("invalid credentials")
                return "", fmt.Errorf("%s: %w", op, errs.ErrInvalidCredentials)
        }</span>

        <span class="cov8" title="1">token, err := u.token.CreateJWT(userDB.ID.String(), userDB.Role.String())
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("create JWT token")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (u *AuthUsecase) Logout(ctx context.Context, token string) error <span class="cov8" title="1">{
        const op = "AuthUsecase.Logout"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        claims, err := u.token.ParseJWT(token)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to parse token")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidToken)
        }</span>

        // Add token to blacklist with userID association
        <span class="cov8" title="1">if err := u.redisRepo.AddToBlacklist(ctx, claims.UserID, token); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to add token to blacklist")
                return fmt.Errorf("%s: %w", op, errs.ErrInternal)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GeneratePasswordHash Генерация хэша пароля
func GeneratePasswordHash(password string) ([]byte, error) <span class="cov8" title="1">{
        return bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package basket

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
        "github.com/google/uuid"
)

//go:generate mockgen -source=basket.go -destination=../../infrastructure/repository/postgres/mocks/basket_repository_mock.go -package=mocks IBasketRepository
type IBasketRepository interface{
        Get(ctx context.Context, userID uuid.UUID) ([]*models.BasketItem, error)
        Add(ctx context.Context, userID uuid.UUID, productID uuid.UUID) (*models.BasketItem, error)
        Delete(ctx context.Context, userID uuid.UUID, productID uuid.UUID) error
        UpdateQuantity(ctx context.Context, userID uuid.UUID, productID uuid.UUID, quantity int) (*models.BasketItem, error)
        Clear(ctx context.Context, userID uuid.UUID) error
}

type BasketUsecase struct {
        repo IBasketRepository
}

func NewBasketUsecase(repo IBasketRepository) *BasketUsecase <span class="cov8" title="1">{
        return &amp;BasketUsecase{
                repo: repo,
        }
}</span>

func (u *BasketUsecase)Get(ctx context.Context)([]*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Get"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
    items, err := u.repo.Get(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get basket items from repo")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return items, nil</span>
}


func (u *BasketUsecase)Add(ctx context.Context, productID uuid.UUID)(*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Add"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    if productID == uuid.Nil </span><span class="cov8" title="1">{
        logger.Error("invalid product ID")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("get user ID from context")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        item, err := u.repo.Add(ctx, userID, productID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("add product to basket")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return item, nil</span>
}

func (u *BasketUsecase)Delete(ctx context.Context, productID uuid.UUID)(error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Delete"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        err = u.repo.Delete(ctx, userID, productID)
        if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("delete product from basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *BasketUsecase)UpdateQuantity(ctx context.Context, productID uuid.UUID, quantity int)(*models.BasketItem, error)<span class="cov8" title="1">{
        const op = "BasketUsecase.UpdateQuantity"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    if quantity &lt;= 0 </span><span class="cov8" title="1">{
        logger.WithField("quantity", quantity).Error("invalid quantity")
        return nil, fmt.Errorf("%s: %w", op, errs.NewBusinessLogicError("invalid quantity"))
    }</span>

        <span class="cov8" title="1">if productID == uuid.Nil </span><span class="cov8" title="1">{
        logger.Error("invalid product ID")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

        <span class="cov8" title="1">userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger.WithField("user_id", userID).WithField("product_id", productID)

        item, err := u.repo.UpdateQuantity(ctx, userID, productID, quantity)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("update product quantity")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return item, nil</span>
}

func (u *BasketUsecase)Clear(ctx context.Context,)(error)<span class="cov8" title="1">{
        const op = "BasketUsecase.Clear"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userID, err := helpers.GetUserIDFromContext(ctx)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get user ID from context")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
    err = u.repo.Clear(ctx, userID)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("clear basket")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file66" style="display: none">package category

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

//go:generate mockgen -source=category.go -destination=../../infrastructure/repository/postgres/mocks/category_repository_mock.go -package=mocks ICategoryRepository
type ICategoryRepository interface {
        GetAllCategories(ctx context.Context) ([]*models.Category, error)
        GetAllSubcategories(ctx context.Context, category_id uuid.UUID) ([]*models.Category, error)
        GetNameSubcategory(ctx context.Context, id uuid.UUID) (string, error)
}

type CategoryUsecase struct {
        repo ICategoryRepository
}

func NewCategoryUsecase(repo ICategoryRepository) *CategoryUsecase <span class="cov8" title="1">{
        return &amp;CategoryUsecase{
                repo: repo,
        }
}</span>

func (u *CategoryUsecase) GetAllCategories(ctx context.Context) ([]*models.Category, error) <span class="cov8" title="1">{
        const op = "CategoryUsecase.GetAllCategories"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        categories, err := u.repo.GetAllCategories(ctx)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get categories from repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return categories, nil</span>
}

func (u *CategoryUsecase) GetAllSubategories(ctx context.Context, category_id uuid.UUID) ([]*models.Category, error) <span class="cov0" title="0">{
        const op = "CategoryUsecase.GetAllCategories"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        categories, err := u.repo.GetAllSubcategories(ctx, category_id)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get subcategories from repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}

func (u *CategoryUsecase) GetNameSubcategory(ctx context.Context, id uuid.UUID) (string, error) <span class="cov0" title="0">{
        const op = "CategoryUsecase.GetNameSubcategory"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        name, err := u.repo.GetNameSubcategory(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get name subcategory from repository")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return name, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package csat

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

//go:generate mockgen -source=csat.go -destination=../../infrastructure/repository/postgres/mocks/csat_repository_mock.go -package=mocks ICsatRepository
type ICsatRepository interface {
        GetSurvey(ctx context.Context, topicName string) (*models.SurveyWithQuestions, error)
        AddSurveySubmission(ctx context.Context, surveyID uuid.UUID, answers []models.Answer, userID uuid.UUID) error
        GetStatistics(context.Context, uuid.UUID) (*models.GetStatisticsResponse, error)
        GetAllSurvey(ctx context.Context) ([]models.Survey, error)
}

type CsatUsecase struct {
        repo ICsatRepository
}

func NewCsatUsecase(repo ICsatRepository) *CsatUsecase <span class="cov8" title="1">{
        return &amp;CsatUsecase{
                repo: repo,
        }
}</span>

func (u *CsatUsecase) GetSurveyWithQuestions(ctx context.Context, name string) (*dto.SurveyWithQuestionsResponse, error) <span class="cov8" title="1">{
        const op = "CsatUsecase.GetSurveyWithQuestions"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        if name == "" </span><span class="cov8" title="1">{
                logger.Error("empty survey name")
                return nil, errs.ErrReadRequestData
        }</span>

        <span class="cov8" title="1">survey, err := u.repo.GetSurvey(ctx, name)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get survey from repository")
                return nil, err
        }</span>

        <span class="cov8" title="1">if survey == nil </span><span class="cov8" title="1">{
                logger.Error("survey not found")
                return nil, errs.NewNotFoundError("survey not found")
        }</span>

        <span class="cov8" title="1">return &amp;dto.SurveyWithQuestionsResponse{
                ID:          survey.ID,
                Title:       survey.Title,
                Description: survey.Description,
                Questions:   convertQuestionsToDTO(survey.Questions),
        }, nil</span>
}

func (u *CsatUsecase) SubmitAnswer(ctx context.Context, req *dto.SubmitAnswersRequest) error <span class="cov8" title="1">{
        const op = "CsatUsecase.SubmitAnswer"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist || userIDStr == "" </span><span class="cov8" title="1">{
                logger.Warn("user ID not found in context")
                return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("invalid user ID format")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov8" title="1">if req == nil </span><span class="cov8" title="1">{
                logger.Error("nil request")
                return errs.ErrParseRequestData
        }</span>

        <span class="cov8" title="1">if len(req.Answers) == 0 </span><span class="cov8" title="1">{
                logger.Error("empty answers list")
                return errs.NewBusinessLogicError("empty answers list")
        }</span>

        <span class="cov8" title="1">answers := make([]models.Answer, 0, len(req.Answers))
        for _, ans := range req.Answers </span><span class="cov8" title="1">{
                if ans.QuestionID == uuid.Nil </span><span class="cov8" title="1">{
                        logger.Error("empty question ID in answer")
                        return errs.NewBusinessLogicError("empty question ID in answer")
                }</span>
                <span class="cov8" title="1">if ans.Value &lt; 0 || ans.Value &gt; 10 </span><span class="cov8" title="1">{
                        logger.Error("invalid answer value")
                        return errs.NewBusinessLogicError("invalid answer value")
                }</span>

                <span class="cov8" title="1">answers = append(answers, models.Answer{
                        QuestionID: ans.QuestionID,
                        Value:      ans.Value,
                })</span>
        }

        <span class="cov8" title="1">err = u.repo.AddSurveySubmission(ctx, req.SurveyID, answers, userID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to store answers")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *CsatUsecase) GetSurveyStatistics(ctx context.Context, surveyID uuid.UUID) (*dto.SurveyStatisticsResponse, error) <span class="cov8" title="1">{
        const op = "CsatUsecase.GetSurveyStatistics"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        if surveyID == uuid.Nil </span><span class="cov8" title="1">{
                logger.Error("empty survey ID")
                return nil, errs.NewBusinessLogicError("empty survey ID")
        }</span>

        <span class="cov8" title="1">stats, err := u.repo.GetStatistics(ctx, surveyID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get survey statistics")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if stats == nil </span><span class="cov8" title="1">{
                logger.Error("survey statistics not found")
                return nil, errs.NewNotFoundError("survey statistics not found")
        }</span>

        <span class="cov8" title="1">return &amp;dto.SurveyStatisticsResponse{
                Description: stats.Description,
                Questions:   convertStatisticsQuestionsToDTO(stats.Questions),
        }, nil</span>
}

func convertStatisticsQuestionsToDTO(questions []models.QuestionStatistics) []dto.QuestionStatisticsDTO <span class="cov8" title="1">{
        result := make([]dto.QuestionStatisticsDTO, 0, len(questions))

        for _, q := range questions </span><span class="cov8" title="1">{
                stats := make([]uint32, 11)

                for _, answer := range q.Answers </span><span class="cov8" title="1">{
                        if answer &lt;= 10 </span><span class="cov8" title="1">{
                                stats[answer]++
                        }</span>
                }

                <span class="cov8" title="1">result = append(result, dto.QuestionStatisticsDTO{
                        ID:    q.ID,
                        Text:  q.Text,
                        Stats: stats,
                })</span>
        }

        <span class="cov8" title="1">return result</span>
}

func convertQuestionsToDTO(questions []models.Question) []dto.QuestionResponseDTO <span class="cov8" title="1">{
        result := make([]dto.QuestionResponseDTO, 0, len(questions))
        for _, q := range questions </span><span class="cov8" title="1">{
                result = append(result, dto.QuestionResponseDTO{
                        ID:   q.ID,
                        Text: q.Text,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (u *CsatUsecase) GetAllSurveys(ctx context.Context) (*dto.SurveysListDTO, error) <span class="cov8" title="1">{
        const op = "CsatUsecase.GetAllSurveys"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        surveys, err := u.repo.GetAllSurvey(ctx)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get surveys from repository")
                return nil, errs.ErrInternal
        }</span>

        <span class="cov8" title="1">return dto.ConvertModelsToSurveysListDTO(surveys), nil</span>
}</pre>
		
		<pre class="file" id="file68" style="display: none">package helpers

import "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"

func GetFinalPrice(p *models.Product) float64 <span class="cov8" title="1">{
    if p.PriceDiscount &gt; 0 </span><span class="cov8" title="1">{
        return p.PriceDiscount
    }</span>
    <span class="cov8" title="1">return p.Price</span>
}</pre>
		
		<pre class="file" id="file69" style="display: none">package helpers

import "golang.org/x/crypto/bcrypt"

// GeneratePasswordHash Генерация хэша пароля
func GeneratePasswordHash(password string) ([]byte, error) <span class="cov0" title="0">{
        return bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package helpers

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/google/uuid"
)

func GetUserIDFromContext(ctx context.Context) (uuid.UUID, error) <span class="cov8" title="1">{
        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov8" title="1">{
                return uuid.Nil, errs.NewNotFoundError("user not found")
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, errs.ErrInvalidID
        }</span>

        <span class="cov8" title="1">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package order

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/postgres/order"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
        "github.com/guregu/null"
)

//go:generate mockgen -source=order.go -destination=../mocks/order_usecase_mock.go -package=mocks IOrderUsecase
type IOrderUsecase interface {
        CreateOrder(context.Context, dto.CreateOrderDTO) error
        GetUserOrders(context.Context, uuid.UUID) (*[]dto.OrderPreviewDTO, error)
}

type OrderUsecase struct {
        repo order.IOrderRepository
}

func NewOrderUsecase(
        repo order.IOrderRepository,
) *OrderUsecase <span class="cov8" title="1">{
        return &amp;OrderUsecase{
                repo: repo,
        }
}</span>

func (u *OrderUsecase) CreateOrder(ctx context.Context, in dto.CreateOrderDTO) error <span class="cov8" title="1">{
        const op = "OrderUsecase.CreateOrder"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", in.UserID)
        
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        orderItems := make([]dto.CreateOrderItemDTO, len(in.Items))
        now := time.Now()

        var totalPrice float64 = 0
        var totalDiscountedPrice float64 = 0

        newQuantities := make(map[uuid.UUID]uint)

        mu := &amp;sync.Mutex{}
        var totalWg sync.WaitGroup
        errCh := make(chan error, 1)

        for i, item := range in.Items </span><span class="cov8" title="1">{
                item.ID = uuid.New()
                orderItems[i] = item

                totalWg.Add(1)
                go func(i int, item dto.CreateOrderItemDTO) </span><span class="cov8" title="1">{
                        defer totalWg.Done()

                        var innerWg sync.WaitGroup
                        innerWg.Add(2)

                        var (
                                product     *models.Product
                                productErr  error
                                discounts   []models.ProductDiscount
                                discountErr error
                        )

                        // Получаем статус количество и цену товара
                        go func() </span><span class="cov8" title="1">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov8" title="1">product, productErr = u.repo.ProductPrice(ctx, item.ProductID)
                                if productErr != nil </span><span class="cov8" title="1">{
                                        logger.WithError(productErr).
                                                WithField("product_id", item.ProductID).
                                                Error("failed to fetch product price")
                                        trySendError(productErr, errCh, cancel)
                                        return
                                }</span>
                        }()

                        // Получаем скидку товара, если она есть
                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov8" title="1">discounts, discountErr = u.repo.ProductDiscounts(ctx, item.ProductID)
                                if discountErr != nil &amp;&amp; !errors.Is(discountErr, errs.ErrNotFound) </span><span class="cov0" title="0">{
                                        logger.WithError(discountErr).
                                                WithField("product_id", item.ProductID).
                                                Error("failed to fetch product discount")
                                        trySendError(discountErr, errCh, cancel)
                                        return
                                }</span>
                        }()

                        <span class="cov8" title="1">innerWg.Wait()

                        // Проверяем отмену после запросов
                        if ctx.Err() != nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if product.Status != models.ProductApproved </span><span class="cov8" title="1">{
                                logger.WithFields(map[string]interface{}{
                                        "product_id":      item.ProductID,
                                        "status":          product.Status,
                                        "required_status": models.ProductApproved,
                                }).Warn("product not approved")
                                trySendError(errs.ErrProductNotApproved, errCh, cancel)
                                return
                        }</span>
                        <span class="cov8" title="1">if product.Quantity &lt; item.Quantity </span><span class="cov8" title="1">{
                                logger.WithFields(map[string]interface{}{
                                        "product_id":       item.ProductID,
                                        "requested":        item.Quantity,
                                        "available":        product.Quantity,
                                }).Warn("not enough stock")
                                trySendError(errs.ErrNotEnoughStock, errCh, cancel)
                                return
                        }</span>

                        <span class="cov8" title="1">discount, _ := findLatestDiscount(discounts)

                        mu.Lock()

                        var priceToSave float64
                        totalPrice += product.Price * float64(item.Quantity)
                        newQuantities[item.ProductID] = product.Quantity - item.Quantity

                        // Если есть скидка и она активна
                        if discount.DiscountedPrice != 0 &amp;&amp; discount.DiscountEndDate.After(now) </span><span class="cov0" title="0">{
                                totalDiscountedPrice += discount.DiscountedPrice * float64(item.Quantity)
                                priceToSave = discount.DiscountedPrice
                        }</span> else<span class="cov8" title="1"> {
                                totalDiscountedPrice += product.Price * float64(item.Quantity)
                                priceToSave = product.Price
                        }</span>
                        <span class="cov8" title="1">orderItems[i].Price = priceToSave
                        mu.Unlock()</span>

                }(i, item)
        }

        // Горутина для закрытия канала после завершения всех операций
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                totalWg.Wait()
                close(errCh)
        }</span>()

        // Возвращаем первую ошибку (если есть)
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">order := &amp;dto.Order{
                ID:                 uuid.New(),
                UserID:             in.UserID,
                Status:             models.Placed,
                TotalPrice:         totalPrice,
                TotalPriceDiscount: totalDiscountedPrice,
                AddressID:          in.AddressID,
                Items:              orderItems,
        }

        return u.repo.CreateOrder(ctx, dto.CreateOrderRepoReq{
                Order:             order,
                UpdatedQuantities: newQuantities,
        })</span>
}

func (u *OrderUsecase) GetUserOrders(ctx context.Context, userID uuid.UUID) (*[]dto.OrderPreviewDTO, error) <span class="cov0" title="0">{
        const op = "OrderUsecase.GetUserOrders"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("user_id", userID)

        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        orders, err := u.repo.GetOrdersByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("no orders found for user")
                        return nil, fmt.Errorf("%s: %w", op, errs.NewNotFoundError(op))
                }</span>
                <span class="cov0" title="0">logger.WithError(err).Error("failed to get orders by user ID")
                return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">mu := &amp;sync.Mutex{}
        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        ordersPreview := make([]dto.OrderPreviewDTO, len(*orders))
        for i, orderItem := range *orders </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()

                        innerWg := sync.WaitGroup{}
                        var (
                                address  *models.AddressDB
                                products []models.OrderPreviewProductDTO
                        )

                        innerWg.Add(2)
                        go func() </span><span class="cov0" title="0">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">productIDs, productErr := u.repo.GetOrderProducts(ctx, orderItem.ID)
                                if productErr != nil </span><span class="cov0" title="0">{
                                        logger.WithError(productErr).
                                                WithField("order_id", orderItem.ID).
                                                Error("failed to get order products")
                                        trySendError(productErr, errCh, cancel)
                                        return
                                }</span>

                                // Получаем изображения продуктов
                                <span class="cov0" title="0">productsData := make([]models.OrderPreviewProductDTO, len(*productIDs))
                                imgMu := &amp;sync.Mutex{}
                                imageWg := sync.WaitGroup{}
                                for i, productData := range *productIDs </span><span class="cov0" title="0">{
                                        imageWg.Add(1)

                                        go func() </span><span class="cov0" title="0">{
                                                defer imageWg.Done()
                                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                                        return
                                                }</span>

                                                <span class="cov0" title="0">productImg, imgErr := u.repo.GetProductImage(ctx, productData.ProductID)

                                                imgMu.Lock()
                                                if imgErr != nil </span><span class="cov0" title="0">{
                                                        // Ошибка получения изображения, значит будем отдавать nil
                                                        productsData[i] = models.OrderPreviewProductDTO{
                                                                ProductImageURL: null.String{},
                                                                ProductQuantity: productData.Quantity,
                                                        }
                                                        return
                                                }</span>

                                                <span class="cov0" title="0">productsData[i] = models.OrderPreviewProductDTO{
                                                        ProductImageURL: null.StringFrom(productImg),
                                                        ProductQuantity: productData.Quantity,
                                                }
                                                imgMu.Unlock()</span>
                                        }()
                                }

                                <span class="cov0" title="0">imageWg.Wait()
                                products = productsData</span>
                        }()

                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                defer innerWg.Done()
                                if ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">addressRes, addressErr := u.repo.GetOrderAddress(ctx, orderItem.AddressID)
                                if addressErr != nil </span><span class="cov0" title="0">{
                                        logger.WithError(addressErr).
                                                WithField("address_id", orderItem.AddressID).
                                                Error("failed to get order address")
                                        trySendError(addressErr, errCh, cancel)
                                        return
                                }</span>

                                <span class="cov0" title="0">address = addressRes
                                address.ID = orderItem.AddressID</span>
                        }()

                        <span class="cov0" title="0">innerWg.Wait()
                        if ctx.Err() != nil || address == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">mu.Lock()
                        ordersPreview[i] = orderItem.ConvertToGetOrderByUserIDResDTO(address, products)
                        mu.Unlock()</span>
                }()
        }

        // Горутина для закрытия канала после завершения всех операций
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Возвращаем первую ошибку (если есть)
        <span class="cov0" title="0">if err = &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get order details")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        
        <span class="cov0" title="0">return &amp;ordersPreview, nil</span>
}

// trySendError Вспомогательная функция для безопасной отправки ошибки
func trySendError(err error, errCh chan&lt;- error, cancel context.CancelFunc) <span class="cov8" title="1">{
        select </span>{
        case errCh &lt;- err:<span class="cov8" title="1">
                cancel()</span>
        default:<span class="cov0" title="0"></span>
                // Если ошибка уже есть - игнорируем (сохраняем первую)
        }
}

// findLatestDiscount Достаём последнюю созданную скидку
func findLatestDiscount(discounts []models.ProductDiscount) (models.ProductDiscount, bool) <span class="cov8" title="1">{
        if len(discounts) == 0 </span><span class="cov8" title="1">{
                return models.ProductDiscount{}, false
        }</span>

        <span class="cov0" title="0">latest := discounts[0]
        for _, discount := range discounts[1:] </span><span class="cov0" title="0">{
                if discount.DiscountStartDate.After(latest.DiscountStartDate) </span><span class="cov0" title="0">{
                        latest = discount
                }</span>
        }

        <span class="cov0" title="0">return latest, true</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package product

import (
        "context"
        "fmt"
        "sort"
        "sync"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
)

//go:generate mockgen -source=product.go -destination=../../infrastructure/repository/postgres/mocks/product_repository_mock.go -package=mocks IProductRepository
type IProductRepository interface {
        GetAllProducts(ctx context.Context, offset int) ([]*models.Product, error)
        GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error)
        GetProductsByCategory(
                ctx context.Context, 
                id uuid.UUID, 
                offset int,
                minPrice, maxPrice float64,
                minRating float32,
                sortOption models.SortOption,
        ) ([]*models.Product, error)
        AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error)
}

type ProductUsecase struct {
        repo IProductRepository
}

func NewProductUsecase(repo IProductRepository) *ProductUsecase <span class="cov8" title="1">{
        return &amp;ProductUsecase{
                repo: repo,
        }
}</span>

func (u *ProductUsecase) GetAllProducts(ctx context.Context, offset int) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductUsecase.GetAllProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        products, err := u.repo.GetAllProducts(ctx, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get products from repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}

func (u *ProductUsecase) GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductUsecase.GetProductByID"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_id", id)

        product, err := u.repo.GetProductByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get product by ID from repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">return product, nil</span>
}

// GetProductsByIDs возвращает список продуктов по их UUID
func (u *ProductUsecase) GetProductsByIDs(ctx context.Context, ids []uuid.UUID) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "ProductUsecase.GetProductsByIDs"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("product_ids", ids)

        if len(ids) == 0 </span><span class="cov8" title="1">{
                return []*models.Product{}, nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        mu := &amp;sync.Mutex{}
        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        products := make([]*models.Product, len(ids))
        for i, id := range ids </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, productID uuid.UUID) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">product, err := u.repo.GetProductByID(ctx, productID)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.WithError(err).WithField("product_id", productID).Warn("failed to get product by ID")
                                trySendError(err, errCh, cancel)
                                return
                        }</span>

                        <span class="cov8" title="1">mu.Lock()
                        products[idx] = product
                        mu.Unlock()</span>
                }(i, id)
        }

        // Горутина для закрытия канала после завершения всех операций
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Возвращаем первую ошибку (если есть)
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Фильтруем nil значения (продукты, которые не удалось получить)
        <span class="cov8" title="1">filteredProducts := make([]*models.Product, 0, len(products))
        for _, p := range products </span><span class="cov8" title="1">{
                if p != nil </span><span class="cov8" title="1">{
                        filteredProducts = append(filteredProducts, p)
                }</span>
        }

        <span class="cov8" title="1">return filteredProducts, nil</span>
}

// trySendError Вспомогательная функция для безопасной отправки ошибки
func trySendError(err error, errCh chan&lt;- error, cancel context.CancelFunc) <span class="cov8" title="1">{
        select </span>{
        case errCh &lt;- err:<span class="cov8" title="1">
                cancel()</span>
        default:<span class="cov0" title="0"></span>
                // Если ошибка уже есть - игнорируем (сохраняем первую)
        }
}

func (u *ProductUsecase) GetProductsByCategory(
    ctx context.Context, 
    id uuid.UUID, 
    offset int,
    minPrice, maxPrice float64,
    minRating float32,
    sortOption models.SortOption,
) ([]*models.Product, error) <span class="cov8" title="1">{
    const op = "ProductUsecase.GetProductsByCategoryWithFilterAndSort"
    logger := logctx.GetLogger(ctx).WithField("op", op).WithField("category_id", id)

    products, err := u.repo.GetProductsByCategory(
        ctx, 
        id, 
        offset,
        minPrice,
        maxPrice,
        minRating,
                sortOption,
    )
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("get products by category with filter and sort from repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

        <span class="cov8" title="1">switch sortOption </span>{
    case models.SortByPriceAsc:<span class="cov8" title="1">
        sort.Slice(products, func(i, j int) bool </span><span class="cov8" title="1">{
            priceI := helpers.GetFinalPrice(products[i])
            priceJ := helpers.GetFinalPrice(products[j])
            return priceI &lt; priceJ
        }</span>)
    case models.SortByPriceDesc:<span class="cov0" title="0">
        sort.Slice(products, func(i, j int) bool </span><span class="cov0" title="0">{
            priceI := helpers.GetFinalPrice(products[i])
            priceJ := helpers.GetFinalPrice(products[j])
            return priceI &gt; priceJ
        }</span>)
    case models.SortByRatingAsc:<span class="cov0" title="0">
        sort.Slice(products, func(i, j int) bool </span><span class="cov0" title="0">{
            return products[i].Rating &lt; products[j].Rating
        }</span>)
    case models.SortByRatingDesc:<span class="cov0" title="0">
        sort.Slice(products, func(i, j int) bool </span><span class="cov0" title="0">{
            return products[i].Rating &gt; products[j].Rating
        }</span>)
        }

    <span class="cov8" title="1">return products, nil</span>
}

func (u *ProductUsecase) AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
    const op = "ProductUsecase.AddProduct"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    // Валидация данных
    if product.Name == "" </span><span class="cov8" title="1">{
        logger.Error("empty product name")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrEmptyProductName)
    }</span>
    <span class="cov8" title="1">if product.Price &lt;= 0 </span><span class="cov8" title="1">{
        logger.Error("invalid product price")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidProductPrice)
    }</span>
    <span class="cov8" title="1">if product.Quantity &lt; 0 </span><span class="cov0" title="0">{
        logger.Error("invalid product quantity")
        return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidProductQuantity)
    }</span>

    // Если рейтинг не указан, ставим 0
    <span class="cov8" title="1">if product.Rating == 0 </span><span class="cov8" title="1">{
        product.Rating = 0
    }</span>

    // Если количество отзывов не указано, ставим 0
    <span class="cov8" title="1">if product.ReviewsCount == 0 </span><span class="cov8" title="1">{
        product.ReviewsCount = 0
    }</span>

        // Если URL превью не указан, ставим дефолтный
    <span class="cov8" title="1">if product.PreviewImageURL == "" </span><span class="cov8" title="1">{
        product.PreviewImageURL = "media/product-default"
    }</span>

    // Добавляем продукт в репозиторий
    <span class="cov8" title="1">newProduct, err := u.repo.AddProduct(ctx, product, categoryID)
    if err != nil </span><span class="cov0" title="0">{
        logger.WithError(err).Error("add product to repository")
        return nil, fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">return newProduct, nil</span>
}</pre>
		
		<pre class="file" id="file73" style="display: none">package review

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/google/uuid"
)

//go:generate mockgen -source=review.go -destination=../../infrastructure/repository/postgres/mocks/review_repository_mock.go -package=mocks IReviewRepository
type IReviewRepository interface{
        AddReview(ctx context.Context, review models.ReviewDB) error
        GetReview(ctx context.Context, productID uuid.UUID, offset int) ([]*models.Review, error)
}

type ReviewUsecase struct {
        repo IReviewRepository
}

func NewReviewUsecase(repo IReviewRepository) *ReviewUsecase <span class="cov8" title="1">{
        return &amp;ReviewUsecase{
                repo : repo,
        }
}</span>

func (u *ReviewUsecase) Add(ctx context.Context, req dto.AddReviewRequest) error <span class="cov8" title="1">{
        const op = "ReviewUsecase.Add"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist || userIDStr == "" </span><span class="cov8" title="1">{
                logger.Warn("user ID not found in context")
                return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("invalid user ID format")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>
        
        <span class="cov8" title="1">review := models.ReviewDB{
                ID:        uuid.New(),
                UserID:    userID,
                ProductID: req.ProductID,
                Rating:    req.Rating,
                Comment:   req.Comment,
        }

        if err := u.repo.AddReview(ctx, review); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *ReviewUsecase) Get(ctx context.Context, req dto.GetReviewRequest) ([]*models.Review, error) <span class="cov8" title="1">{
        reviews, err := u.repo.GetReview(ctx, req.ProductID, req.Offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return reviews, nil</span>
}</pre>
		
		<pre class="file" id="file74" style="display: none">package search

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
        "github.com/guregu/null"
        "sort"
        "sync"
)

//go:generate mockgen -source=search.go -destination=../../infrastructure/repository/postgres/mocks/search_repository_mock.go -package=mocks ISearchRepository
type ISearchRepository interface {
        GetCategoryByName(ctx context.Context, name string) (*models.Category, error)
        GetProductsByNameWithFilterAndSort(
                ctx context.Context,
                name string,
                categoryID null.String,
                offset int,
                minPrice, maxPrice float64,
                minRating float32,
                sortOption models.SortOption,
        ) ([]*models.Product, error)
}

type SearchUsecase struct {
        repo ISearchRepository
}

func NewSearchUsecase(repo ISearchRepository) *SearchUsecase <span class="cov8" title="1">{
        return &amp;SearchUsecase{
                repo: repo,
        }
}</span>

func (u *SearchUsecase) SearchProductsByNameWithFilterAndSort(
        ctx context.Context,
        categoryID null.String,
        subString string,
        offset int,
        minPrice, maxPrice float64,
        minRating float32,
        sortOption models.SortOption,
) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "SearchUsecase.SearchProductsByNameWithFilterAndSort"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("sub_string", subString)

        products, err := u.repo.GetProductsByNameWithFilterAndSort(ctx, subString, categoryID, offset, minPrice, maxPrice, minRating, sortOption)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Warn("failed to search products with filter and sort")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        // Локальная сортировка, если нужно (если БД не справляется)
        <span class="cov8" title="1">switch sortOption </span>{
        case models.SortByPriceAsc:<span class="cov8" title="1">
                sort.Slice(products, func(i, j int) bool </span><span class="cov8" title="1">{
                        return helpers.GetFinalPrice(products[i]) &lt; helpers.GetFinalPrice(products[j])
                }</span>)
        case models.SortByPriceDesc:<span class="cov8" title="1">
                sort.Slice(products, func(i, j int) bool </span><span class="cov8" title="1">{
                        return helpers.GetFinalPrice(products[i]) &gt; helpers.GetFinalPrice(products[j])
                }</span>)
        case models.SortByRatingAsc:<span class="cov0" title="0">
                sort.Slice(products, func(i, j int) bool </span><span class="cov0" title="0">{
                        return products[i].Rating &lt; products[j].Rating
                }</span>)
        case models.SortByRatingDesc:<span class="cov8" title="1">
                sort.Slice(products, func(i, j int) bool </span><span class="cov8" title="1">{
                        return products[i].Rating &gt; products[j].Rating
                }</span>)
        }

        <span class="cov8" title="1">return products, nil</span>
}

// trySendError Вспомогательная функция для безопасной отправки ошибки
func trySendError(err error, errCh chan&lt;- error, cancel context.CancelFunc) <span class="cov8" title="1">{
        select </span>{
        case errCh &lt;- err:<span class="cov8" title="1">
                cancel()</span>
        default:<span class="cov0" title="0"></span>
                // Если ошибка уже есть - игнорируем (сохраняем первую)
        }
}

func (u *SearchUsecase) SearchCategoryByName(ctx context.Context, req dto.CategoryNameResponse) ([]*models.Category, error) <span class="cov8" title="1">{
        const op = "SearchUsecase.SearchCategoryByName"
        logger := logctx.GetLogger(ctx).WithField("op", op).WithField("names_count", len(req.CategoriesNames))

        if len(req.CategoriesNames) == 0 </span><span class="cov8" title="1">{
                return []*models.Category{}, nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        var wg sync.WaitGroup
        mu := &amp;sync.Mutex{}
        errCh := make(chan error, 1)
        categories := make([]*models.Category, len(req.CategoriesNames))

        for i, suggestion := range req.CategoriesNames </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, name string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">category, err := u.repo.GetCategoryByName(ctx, name)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.WithError(err).WithField("category_name", name).Warn("failed to search category by name")
                                trySendError(err, errCh, cancel)
                                return
                        }</span>

                        <span class="cov8" title="1">if category != nil </span><span class="cov8" title="1">{
                                mu.Lock()
                                categories[idx] = category
                                mu.Unlock()
                        }</span>
                }(i, suggestion.Name)
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">filtered := make([]*models.Category, 0, len(categories))
        for _, c := range categories </span><span class="cov8" title="1">{
                if c != nil </span><span class="cov8" title="1">{
                        filtered = append(filtered, c)
                }</span>
        }

        <span class="cov8" title="1">return filtered, nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package seller

import (
        "context"
        "fmt"

        "github.com/google/uuid"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

//go:generate mockgen -source=seller.go -destination=../../infrastructure/repository/postgres/mocks/seller_repository_mock.go -package=mocks ISellerRepository
type ISellerRepository interface {
        AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error)
        UploadProductImage(ctx context.Context, productID uuid.UUID, imageURL string) error
        GetSellerProducts(ctx context.Context, sellerID uuid.UUID, offset int) ([]*models.Product, error)
        CheckProductBelongs(ctx context.Context, productID, sellerID uuid.UUID) (bool, error)
}

type SellerUsecase struct {
        repo ISellerRepository
}

func NewSellerUsecase(repo ISellerRepository) *SellerUsecase <span class="cov8" title="1">{
        return &amp;SellerUsecase{
                repo: repo,
        }
}</span>

func (u *SellerUsecase) AddProduct(ctx context.Context, product *models.Product, categoryID uuid.UUID) (*models.Product, error) <span class="cov8" title="1">{
        const op = "SellerUsecase.AddProduct"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        // Валидация данных
        if product.Name == "" </span><span class="cov8" title="1">{
                logger.Error("empty product name")
                return nil, fmt.Errorf("%s: %w", op, errs.ErrEmptyProductName)
        }</span>
        <span class="cov8" title="1">if product.Price &lt;= 0 </span><span class="cov8" title="1">{
                logger.Error("invalid product price")
                return nil, fmt.Errorf("%s: %w", op, errs.ErrInvalidProductPrice)
        }</span>

        // Добавляем продукт
        <span class="cov8" title="1">newProduct, err := u.repo.AddProduct(ctx, product, categoryID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("add product to repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return newProduct, nil</span>
}

func (u *SellerUsecase) UploadProductImage(ctx context.Context, productID uuid.UUID, imageURL string) error <span class="cov8" title="1">{
        const op = "SellerUsecase.UploadProductImage"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        err := u.repo.UploadProductImage(ctx, productID, imageURL)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("upload product image")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *SellerUsecase) GetSellerProducts(ctx context.Context, sellerID uuid.UUID, offset int) ([]*models.Product, error) <span class="cov8" title="1">{
        const op = "SellerUsecase.GetSellerProducts"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        products, err := u.repo.GetSellerProducts(ctx, sellerID, offset)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("get seller products from repository")
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}

func (u *SellerUsecase) CheckProductBelongs(ctx context.Context, productID, sellerID uuid.UUID) (bool, error) <span class="cov8" title="1">{
        const op = "SellerUsecase.CheckProductBelongs"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        belongs, err := u.repo.CheckProductBelongs(ctx, productID, sellerID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("check product belongs")
                return false, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return belongs, nil</span>
}</pre>
		
		<pre class="file" id="file76" style="display: none">package suggestions

import (
        "context"
        "fmt"
        "github.com/guregu/null"
        "strings"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/repository/redis"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
)

//go:generate mockgen -source=suggestions.go -destination=../../infrastructure/repository/postgres/mocks/suggestions_repository_mock.go -package=mocks ISuggestionsRepository
type ISuggestionsRepository interface {
        GetAllCategoriesName(ctx context.Context) ([]*models.CategorySuggestion, error)
        GetAllProductsName(ctx context.Context) ([]*models.ProductSuggestion, error)
        GetProductsNameByCategory(ctx context.Context, categoryID string) ([]*models.ProductSuggestion, error)
}

type ISuggestionsRedisRepository interface {
        AddProductSuggestionsByCategory(ctx context.Context, categoryID string, names []string) error
        AddSuggestionsByKey(ctx context.Context, key string, names []string) error
        GetProductSuggestionsByCategory(ctx context.Context, categoryID string) ([]string, error)
        GetProductSuggestionsByCategoryPaginated(ctx context.Context, categoryID string, pageNum int, limit int) ([]string, int64, error)
        GetSuggestionsByKey(ctx context.Context, key string) ([]string, error)
}

type SuggestionsUsecase struct {
        repo      ISuggestionsRepository
        redisRepo ISuggestionsRedisRepository
}

func NewSuggestionsUsecase(repo ISuggestionsRepository, redisRepo ISuggestionsRedisRepository) *SuggestionsUsecase <span class="cov8" title="1">{
        return &amp;SuggestionsUsecase{
                repo:      repo,
                redisRepo: redisRepo,
        }
}</span>

func (u *SuggestionsUsecase) GetCategorySuggestions(ctx context.Context, subString string) (dto.CategoryNameResponse, error) <span class="cov8" title="1">{
        const op = "SuggestionsUsecase.GetCategorySuggestions"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        names, err := u.redisRepo.GetSuggestionsByKey(ctx, redis.CategoryNamesKey)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to get category suggestions from Redis")
        }</span>

        <span class="cov8" title="1">if len(names) == 0 </span><span class="cov8" title="1">{
                categories, err := u.repo.GetAllCategoriesName(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("get categories from repository")
                        return dto.CategoryNameResponse{}, fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov8" title="1">names = make([]string, 0, len(categories))
                for _, c := range categories </span><span class="cov8" title="1">{
                        names = append(names, c.Name)
                }</span>
                <span class="cov8" title="1">_ = u.redisRepo.AddSuggestionsByKey(ctx, redis.CategoryNamesKey, names)</span>
        }

        <span class="cov8" title="1">filtered := filterSuggestions(names, subString)

        var suggestions []models.CategorySuggestion
        for _, name := range filtered </span><span class="cov8" title="1">{
                suggestions = append(suggestions, models.CategorySuggestion{Name: name})
        }</span>

        <span class="cov8" title="1">return dto.CategoryNameResponse{CategoriesNames: suggestions}, nil</span>
}

func (u *SuggestionsUsecase) GetProductSuggestions(ctx context.Context, categoryID null.String, subString string) (dto.ProductNameResponse, error) <span class="cov8" title="1">{
        const op = "SuggestionsUsecase.GetProductSuggestions"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        var names []string
        var err error

        // Пробуем достать из Redis
        if categoryID.Valid </span><span class="cov8" title="1">{
                names, err = u.redisRepo.GetProductSuggestionsByCategory(ctx, categoryID.String)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to get category-specific suggestions from Redis")
                }</span>
        } else<span class="cov8" title="1"> {
                names, err = u.redisRepo.GetSuggestionsByKey(ctx, redis.ProductNamesKey)
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to get general product suggestions from Redis")
                }</span>
        }

        // Если в Redis ничего нет — грузим из БД
        <span class="cov8" title="1">if len(names) == 0 </span><span class="cov8" title="1">{
                var products []*models.ProductSuggestion

                if categoryID.Valid </span><span class="cov8" title="1">{
                        products, err = u.repo.GetProductsNameByCategory(ctx, categoryID.String)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Error("get products by category from repository")
                                return dto.ProductNameResponse{}, fmt.Errorf("%s: %w", op, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        products, err = u.repo.GetAllProductsName(ctx)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.WithError(err).Error("get all products from repository")
                                return dto.ProductNameResponse{}, fmt.Errorf("%s: %w", op, err)
                        }</span>
                }

                <span class="cov8" title="1">names = make([]string, 0, len(products))
                for _, p := range products </span><span class="cov8" title="1">{
                        names = append(names, p.Name)
                }</span>

                // Кэшируем в Redis
                <span class="cov8" title="1">if categoryID.Valid </span><span class="cov8" title="1">{
                        _ = u.redisRepo.AddProductSuggestionsByCategory(ctx, categoryID.String, names)
                }</span> else<span class="cov8" title="1"> {
                        _ = u.redisRepo.AddSuggestionsByKey(ctx, redis.ProductNamesKey, names)
                }</span>
        }

        // Фильтрация по подстроке
        <span class="cov8" title="1">filtered := filterSuggestions(names, subString)

        // Возврат
        suggestions := make([]models.ProductSuggestion, 0, len(filtered))
        for _, name := range filtered </span><span class="cov8" title="1">{
                suggestions = append(suggestions, models.ProductSuggestion{Name: name})
        }</span>

        <span class="cov8" title="1">return dto.ProductNameResponse{ProductNames: suggestions}, nil</span>
}

func filterSuggestions(names []string, sub string) []string <span class="cov8" title="1">{
        lowerSub := strings.ToLower(sub)
        seen := make(map[string]struct{})
        var result []string

        for _, fullName := range names </span><span class="cov8" title="1">{
                lowerFull := strings.ToLower(fullName)

                if strings.HasPrefix(lowerFull, lowerSub) </span><span class="cov8" title="1">{
                        if _, ok := seen[fullName]; !ok </span><span class="cov8" title="1">{
                                result = append(result, fullName)
                                seen[fullName] = struct{}{}
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">for _, word := range strings.Fields(lowerFull) </span><span class="cov8" title="1">{
                        if strings.HasPrefix(word, lowerSub) </span><span class="cov0" title="0">{
                                if _, ok := seen[fullName]; !ok </span><span class="cov0" title="0">{
                                        result = append(result, fullName)
                                        seen[fullName] = struct{}{}
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/infrastructure/minio"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/domains"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models/errs"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/dto"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/middleware/logctx"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/auth"
        "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/usecase/helpers"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

//go:generate mockgen -source=user.go -destination=../../infrastructure/repository/postgres/mocks/user_repository_mock.go -package=mocks IUserRepository
type IUserRepository interface {
        GetUserByEmail(context.Context, string) (*models.UserDB, error)
        GetUserByID(context.Context, uuid.UUID) (*models.UserDB, error)
        UpdateUserImageURL(context.Context, uuid.UUID, string) error
        UpdateUserProfile(context.Context, uuid.UUID, models.UpdateUserDB) error
        UpdateUserEmail(context.Context, uuid.UUID, string) error
        UpdateUserPassword(context.Context, uuid.UUID, []byte) error
        CreateSellerAndUpdateRole(ctx context.Context, userID uuid.UUID, title, description string)  error
}

type UserUsecase struct {
        token        auth.ITokenator
        repo         IUserRepository
        minioService minio.Provider
}

func NewUserUsecase(repo IUserRepository, token auth.ITokenator, minioService minio.Provider) *UserUsecase <span class="cov8" title="1">{
        return &amp;UserUsecase{
                repo:         repo,
                token:        token,
                minioService: minioService,
        }
}</span>

func (u *UserUsecase) GetMe(ctx context.Context) (*dto.UserDTO, string, error) <span class="cov8" title="1">{
        const op = "UserUsecase.GetMe"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov8" title="1">{
                logger.Warn("user ID not found in context")
                return nil, "", fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("invalid user ID format")
                return nil, "", fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov8" title="1">role, isExist := ctx.Value(domains.RoleKey{}).(string)
        fmt.Println(role, isExist)
        if !isExist </span><span class="cov0" title="0">{
                logger.Warn("role not found in context")
                return nil, "", fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
        userRepo, err := u.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov8" title="1">{
                        logger.Warn("user not found")
                        return nil, "", fmt.Errorf("%s: %w", op, errs.ErrNotFound)
                }</span>
                <span class="cov0" title="0">logger.WithError(err).Error("get user from repository")
                return nil, "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">user := userRepo.ConvertToUser()
        if user == nil </span><span class="cov0" title="0">{
                logger.Error("failed to convert user from db model")
                return nil, "", fmt.Errorf("%s: %w", op, errs.ErrBusinessLogic)
        }</span>

        <span class="cov8" title="1">userDTO := &amp;dto.UserDTO{
                ID:          user.ID,
                Email:       user.Email,
                Name:        user.Name,
                Surname:     user.Surname,
                ImageURL:    user.ImageURL,
                PhoneNumber: user.PhoneNumber,
                Role:        user.Role.String(),
        }

        if role != user.Role.String() </span><span class="cov8" title="1">{
                token, err := u.token.CreateJWT(userIDStr, user.Role.String())
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("create JWT token")
                        return nil, "", fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">return userDTO, token, nil</span>
        }

        <span class="cov8" title="1">return userDTO, "", nil</span>
}

func (u *UserUsecase) UploadAvatar(ctx context.Context, fileData minio.FileData) (string, error) <span class="cov0" title="0">{
        const op = "UserUsecase.UploadAvatar"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov0" title="0">{
                logger.Warn("user ID not found in context")
                return "", fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("invalid user ID format")
                return "", fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov0" title="0">logger = logger.WithField("user_id", userID)
        avatar, err := u.minioService.CreateOne(ctx, fileData)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("upload avatar to storage")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">if err = u.repo.UpdateUserImageURL(ctx, userID, avatar.URL); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("update user avatar URL")
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return avatar.URL, nil</span>
}

func (u *UserUsecase) UpdateUserProfile(ctx context.Context, user dto.UpdateUserProfileRequestDTO) error <span class="cov8" title="1">{
        const op = "UserUsecase.UpdateUserProfile"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
        if !isExist </span><span class="cov0" title="0">{
                logger.Warn("user ID not found in context")
                return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("invalid user ID format")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
        currentUser, err := u.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("user not found")
                        return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get current user data")
                return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">userDB := models.UpdateUserDB{}

        if user.Name.Valid &amp;&amp; strings.TrimSpace(user.Name.String) != "" </span><span class="cov8" title="1">{
                userDB.Name = user.Name.String
        }</span> else<span class="cov0" title="0"> {
                userDB.Name = currentUser.Name
        }</span>

        <span class="cov8" title="1">if user.Surname.Valid &amp;&amp; strings.TrimSpace(user.Surname.String) != "" </span><span class="cov8" title="1">{
                userDB.Surname = user.Surname
        }</span> else<span class="cov8" title="1"> {
                userDB.Surname = currentUser.Surname
        }</span>

        <span class="cov8" title="1">if user.PhoneNumber.Valid &amp;&amp; strings.TrimSpace(user.PhoneNumber.String) != "" </span><span class="cov8" title="1">{
                userDB.PhoneNumber = user.PhoneNumber
        }</span> else<span class="cov8" title="1"> {
                userDB.PhoneNumber = currentUser.PhoneNumber
        }</span>

        <span class="cov8" title="1">if err := u.repo.UpdateUserProfile(ctx, userID, userDB); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update user profile")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *UserUsecase) UpdateUserEmail(ctx context.Context, user dto.UpdateUserEmailDTO) error <span class="cov8" title="1">{
        const op = "UserUsecase.UpdateUserEmail"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userID, err := helpers.GetUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get user ID from context")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
        userDB, err := u.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("user not found")
                        return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user data")
                return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword(userDB.PasswordHash, []byte(user.Password)); err != nil </span><span class="cov8" title="1">{
                logger.Warn("invalid password provided")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidCredentials)
        }</span>

        <span class="cov8" title="1">if err := u.repo.UpdateUserEmail(ctx, userID, user.Email); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update user email")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *UserUsecase) UpdateUserPassword(ctx context.Context, user dto.UpdateUserPasswordDTO) error <span class="cov8" title="1">{
        const op = "UserUsecase.UpdateUserPassword"
        logger := logctx.GetLogger(ctx).WithField("op", op)

        userID, err := helpers.GetUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("get user ID from context")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
        }</span>

        <span class="cov8" title="1">logger = logger.WithField("user_id", userID)
        userRepo, err := u.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrNotFound) </span><span class="cov0" title="0">{
                        logger.Warn("user not found")
                        return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
                }</span>
                <span class="cov8" title="1">logger.WithError(err).Error("get user data")
                return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword(userRepo.PasswordHash, []byte(user.OldPassword)); err != nil </span><span class="cov8" title="1">{
                logger.Warn("invalid old password provided")
                return fmt.Errorf("%s: %w", op, errs.ErrInvalidCredentials)
        }</span>

        <span class="cov8" title="1">passwordHash, err := auth.GeneratePasswordHash(user.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("generate password hash")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if err := u.repo.UpdateUserPassword(ctx, userID, passwordHash); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("update user password")
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (u *UserUsecase) BecomeSeller(ctx context.Context, req dto.UpdateRoleRequest) error <span class="cov8" title="1">{
    const op = "UserUsecase.BecomeSeller"
    logger := logctx.GetLogger(ctx).WithField("op", op)

    userIDStr, isExist := ctx.Value(domains.UserIDKey{}).(string)
    if !isExist </span><span class="cov0" title="0">{
        logger.Warn("user ID not found in context")
        return fmt.Errorf("%s: %w", op, errs.ErrNotFound)
    }</span>

    <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("invalid user ID format")
        return fmt.Errorf("%s: %w", op, errs.ErrInvalidID)
    }</span>

    <span class="cov8" title="1">err = u.repo.CreateSellerAndUpdateRole(ctx, userID, req.Title, req.Description)
    if err != nil </span><span class="cov8" title="1">{
        logger.WithError(err).Error("failed to become seller")
        return fmt.Errorf("%s: %w", op, err)
    }</span>

    <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
