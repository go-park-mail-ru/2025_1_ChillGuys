// Code generated by MockGen. DO NOT EDIT.
// Source: auth.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	models "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/models"
	jwt "github.com/go-park-mail-ru/2025_1_ChillGuys/internal/transport/jwt"
	gomock "github.com/golang/mock/gomock"
	uuid "github.com/google/uuid"
)

// MockITokenator is a mock of ITokenator interface.
type MockITokenator struct {
	ctrl     *gomock.Controller
	recorder *MockITokenatorMockRecorder
}

// MockITokenatorMockRecorder is the mock recorder for MockITokenator.
type MockITokenatorMockRecorder struct {
	mock *MockITokenator
}

// NewMockITokenator creates a new mock instance.
func NewMockITokenator(ctrl *gomock.Controller) *MockITokenator {
	mock := &MockITokenator{ctrl: ctrl}
	mock.recorder = &MockITokenatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITokenator) EXPECT() *MockITokenatorMockRecorder {
	return m.recorder
}

// CreateJWT mocks base method.
func (m *MockITokenator) CreateJWT(userID, role string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJWT", userID, role)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateJWT indicates an expected call of CreateJWT.
func (mr *MockITokenatorMockRecorder) CreateJWT(userID, role interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJWT", reflect.TypeOf((*MockITokenator)(nil).CreateJWT), userID, role)
}

// ParseJWT mocks base method.
func (m *MockITokenator) ParseJWT(tokenString string) (*jwt.JWTClaims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseJWT", tokenString)
	ret0, _ := ret[0].(*jwt.JWTClaims)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseJWT indicates an expected call of ParseJWT.
func (mr *MockITokenatorMockRecorder) ParseJWT(tokenString interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseJWT", reflect.TypeOf((*MockITokenator)(nil).ParseJWT), tokenString)
}

// MockIAuthRepository is a mock of IAuthRepository interface.
type MockIAuthRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIAuthRepositoryMockRecorder
}

// MockIAuthRepositoryMockRecorder is the mock recorder for MockIAuthRepository.
type MockIAuthRepositoryMockRecorder struct {
	mock *MockIAuthRepository
}

// NewMockIAuthRepository creates a new mock instance.
func NewMockIAuthRepository(ctrl *gomock.Controller) *MockIAuthRepository {
	mock := &MockIAuthRepository{ctrl: ctrl}
	mock.recorder = &MockIAuthRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAuthRepository) EXPECT() *MockIAuthRepositoryMockRecorder {
	return m.recorder
}

// CheckUserExists mocks base method.
func (m *MockIAuthRepository) CheckUserExists(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckUserExists", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckUserExists indicates an expected call of CheckUserExists.
func (mr *MockIAuthRepositoryMockRecorder) CheckUserExists(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckUserExists", reflect.TypeOf((*MockIAuthRepository)(nil).CheckUserExists), arg0, arg1)
}

// CreateUser mocks base method.
func (m *MockIAuthRepository) CreateUser(arg0 context.Context, arg1 models.UserDB) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIAuthRepositoryMockRecorder) CreateUser(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIAuthRepository)(nil).CreateUser), arg0, arg1)
}

// GetUserByEmail mocks base method.
func (m *MockIAuthRepository) GetUserByEmail(arg0 context.Context, arg1 string) (*models.UserDB, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserByEmail", arg0, arg1)
	ret0, _ := ret[0].(*models.UserDB)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockIAuthRepositoryMockRecorder) GetUserByEmail(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockIAuthRepository)(nil).GetUserByEmail), arg0, arg1)
}

// GetUserByID mocks base method.
func (m *MockIAuthRepository) GetUserByID(arg0 context.Context, arg1 uuid.UUID) (*models.UserDB, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserByID", arg0, arg1)
	ret0, _ := ret[0].(*models.UserDB)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockIAuthRepositoryMockRecorder) GetUserByID(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockIAuthRepository)(nil).GetUserByID), arg0, arg1)
}

// MockIAuthRedisRepository is a mock of IAuthRedisRepository interface.
type MockIAuthRedisRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIAuthRedisRepositoryMockRecorder
}

// MockIAuthRedisRepositoryMockRecorder is the mock recorder for MockIAuthRedisRepository.
type MockIAuthRedisRepositoryMockRecorder struct {
	mock *MockIAuthRedisRepository
}

// NewMockIAuthRedisRepository creates a new mock instance.
func NewMockIAuthRedisRepository(ctrl *gomock.Controller) *MockIAuthRedisRepository {
	mock := &MockIAuthRedisRepository{ctrl: ctrl}
	mock.recorder = &MockIAuthRedisRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAuthRedisRepository) EXPECT() *MockIAuthRedisRepositoryMockRecorder {
	return m.recorder
}

// AddToBlacklist mocks base method.
func (m *MockIAuthRedisRepository) AddToBlacklist(ctx context.Context, userID, token string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToBlacklist", ctx, userID, token)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToBlacklist indicates an expected call of AddToBlacklist.
func (mr *MockIAuthRedisRepositoryMockRecorder) AddToBlacklist(ctx, userID, token interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToBlacklist", reflect.TypeOf((*MockIAuthRedisRepository)(nil).AddToBlacklist), ctx, userID, token)
}

// IsInBlacklist mocks base method.
func (m *MockIAuthRedisRepository) IsInBlacklist(ctx context.Context, userID, token string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsInBlacklist", ctx, userID, token)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsInBlacklist indicates an expected call of IsInBlacklist.
func (mr *MockIAuthRedisRepositoryMockRecorder) IsInBlacklist(ctx, userID, token interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsInBlacklist", reflect.TypeOf((*MockIAuthRedisRepository)(nil).IsInBlacklist), ctx, userID, token)
}
